<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hwchiu.com/</id>
    <title>hwchiu learning note Blog</title>
    <updated>2023-10-09T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hwchiu.com/"/>
    <subtitle>hwchiu learning note Blog</subtitle>
    <icon>https://hwchiu.com/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[[MacOS ]隨手筆記 Sed 與 Rename 的使用]]></title>
        <id>https://hwchiu.com/2023/10/09/sed-rename</id>
        <link href="https://hwchiu.com/2023/10/09/sed-rename"/>
        <updated>2023-10-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[刪除特定一行]]></summary>
        <content type="html"><![CDATA[<p>刪除特定一行</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sed '/^keywords:/d' input &gt; output</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>刪除符合字串後的所有行數</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sed '/^keywords/,$d' input &gt; output</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>搭配 Find 達到大量修改所有檔案</p><p>統一刪除所有檔案</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">find . -type f -exec sed -i '' '/^authors:/d' {} +</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Append 一行新的，換行要特別注意處理</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">find . -type f -exec sed -i '' '/^title/a\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">authors: hwchiu\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">' {} +</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>假設環境中有大量檔案需要改名稱，透過 rename 這個工具可以快速達成
譬如以下範例會先用正規表達式找尋所有符合的檔案名稱，接者將所有 read-notes 都改名為 reading-notes</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">rename 's/read-notes/reading-notes/' *read-notes-*</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Mac" term="Mac"/>
        <category label="System" term="System"/>
        <category label="Tool" term="Tool"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docusaurus 使用 blog mode 後連結一直反白的問題]]></title>
        <id>https://hwchiu.com/2023/10/08/docusaurus-link-active</id>
        <link href="https://hwchiu.com/2023/10/08/docusaurus-link-active"/>
        <updated>2023-10-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[根據文件將 ladning page 移除並且使用 blog 做為首頁後，發現上方的連結永遠都會顯示反白，仔細檢查後發現連結被加上一個 navbarlink--active 的屬性。]]></summary>
        <content type="html"><![CDATA[<p>根據文件將 ladning page 移除並且使用 blog 做為首頁後，發現上方的連結永遠都會顯示反白，仔細檢查後發現連結被加上一個 <code>navbar__link--active</code> 的屬性。
仔細研究後發現官方有相關 <a href="https://github.com/facebook/docusaurus/discussions/5810" target="_blank" rel="noopener noreferrer">Issue</a>，根據 issue 所述針對 items 內補上 <code>activeBaseRegex: '^/$',</code> 即可。</p><p>最後呈現</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">      {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        to: '/', </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        label: '短篇筆記',</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        position: 'left',</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        activeBaseRegex: '^/$',</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="docusaurus" term="docusaurus"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「SRE 的工作介绍」]]></title>
        <id>https://hwchiu.com/2022/07/11/reading-notes-65</id>
        <link href="https://hwchiu.com/2022/07/11/reading-notes-65"/>
        <updated>2022-07-11T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「SRE 的工作介绍」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「SRE 的工作介绍」
類別: others
連結: <a href="https://www.kawabangga.com/posts/4481" target="_blank" rel="noopener noreferrer">https://www.kawabangga.com/posts/4481</a></p><p>本篇是簡體中文的文章，所以就不針對文章進行導讀。</p><p>文內我覺得有趣的部分是從各個面向來探討 SRE 這個職位的可能內容，畢竟一直以來 DevOps, SRE 等相關概念的詢問就沒有停止過，而事實上每個公司的 DevOps 工程師, SRE 工程師的工作內容也都不盡相同。</p><p>也因為不盡相同，本來就很難一言概括到底 SRE 的可能內容，因此個人算是滿推崇本篇文章的分析與整理方式，從不同角度出發去列舉各種可能的工作內容，譬如文章中分成三大類</p><ol><li>架構</li><li>服務平台</li><li>業務導向</li></ol><p>三種不同類型的 SRE 面對的對象不同，專注的事物也不同，我猜想很多人看完架構類型的論述可能第一個想法就跟以前的 SA/NA 網管有什麼不同？</p><p>也許從 SRE 的 R 出發，去探討你今天到底想要針對什麼樣的目標去提供高可用性，也許更能夠方便探討彼此對於 SRE 的需求與認知</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="SRE" term="SRE"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「DevOps is a failure」]]></title>
        <id>https://hwchiu.com/2022/06/29/reading-notes-64</id>
        <link href="https://hwchiu.com/2022/06/29/reading-notes-64"/>
        <updated>2022-06-29T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「DevOps is a failure」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「DevOps is a failure」
類別: others
連結: <a href="https://leebriggs.co.uk/blog/2022/06/21/devops-is-a-failure" target="_blank" rel="noopener noreferrer">https://leebriggs.co.uk/blog/2022/06/21/devops-is-a-failure</a></p><p>本篇文章作者從不同的角度來聊聊 DevOps 這個詞所代表的含義與實作意義</p><p>第一段作者先閒聊一下自己與 DevOps 詞的歷史，接者直接拋出一個作者長期好奇的觀點
「每個人都一定聽過 DevOps 是一個需要 Dev + Ops 共同參與的文化，但是作者自己參與的 DevOps 相關會議與討論，與會者大部分都是 Ops 人員，而不是那些真正參與開發的 Dev 人」</p><h1>困惑時期</h1><p>接者作者聊聊自身多年前的經驗，當時的開發團隊宣稱該團隊是「true devops」，同時不跟作者的維運團隊討論各種維運需求，這過程讓作者非常困惑，為什麼對方會說自己是 true devops 而又不找自己探討維運需求</p><p>作者後來與該開發團隊深聊後終於理解對方的意思，原來該開發團隊身兼開發與維運，該團隊使用 boto3 加上一些腳本來管理應用程式的生命週期，同時該團隊招募的 「full stack engineer」除了基本的後端技術外，也要對 AWS 有不少的熟悉與經驗。</p><p>對方的舉動更加困惑了作者，畢竟公司當時採取類似 Netflix 的方式來打造一個平台來讓所有開發者可以更輕鬆的去管理這些東西，而該開發團隊的舉動完全是反其道而行，到底為什麼要這麼做？？</p><h1>Pulumi 時期</h1><p>當作者加入 Pulumi 時期時，作者開始使用一些知名工具如 GitLab, Terraform, Kubernetes 等工具來打造一個適合開發者的好用平台，然而每次想要將該平台給推廣給開發者時總是屢屢碰壁，總是會聽到如「你們的東西我不熟悉，我們還是習慣自己打造的工具」等類似說詞給打發掉。</p><p>作者接下來不斷嘗試說服開發團隊來使用自己打造的超級平台，鼓勵他們參加 DevOps 相關活動等各種方式，最終得到的還是類似「我們會按照我們自己的方式去嘗試～謝囉」之類的回覆</p><h1>回顧</h1><p>回顧過往，作者發現錯的是自己，一直以來相信的 DevOps 願景「讓 Ops 停止說 No, 讓 Dev 停止說"yo~ 今天部署吧"」 其實並不真實，作者認為 2022 的今天， DevOps 真正的含義是
「維運端的人努力說服開發人員按照維運人員的想法去做事情」</p><p>綜觀所有號稱跟 DevOps 有關的工具，你會發現幾乎都跟維運有關，每個跟 DevOps 有關的職缺列舉的技能也是滿滿的跟維運有關，對作者來說， DevOps 工程師跟過往的 System Admin 根本沒有太大分別，差異只有把「實體機房建置，上架機器」 v.s 「雲端機器建置，創立VM」而已。</p><p>文章內後半部分還有一些作者的想法，有興趣的可以閱讀完畢</p><p>本篇文章的想法滿有趣的，譬如作者提到想要幫開發團隊建立一個維運平台卻屢屢碰壁。</p><p>Ops 可能會覺得 Dev 一直不停重複打造工具沒有效率，不如使用自己打造的好平台
Dev 可能會覺得 Ops 不懂自己的需求，不如自己根據需求打造</p><p>同樣的敘述放到不同的規模，譬如</p><p>dev -&gt; 5 人的專職開發團隊
dev -&gt; 50 人的專職產品團隊</p><p>後者的角度也許會覺得團隊人數夠多，可以自己處理自己的需求，不需要仰賴公司提供一個萬能平台來處理一切，同時跨 team 合作可能還會使得很多事情效率低落，溝通成本過大。</p><p>歡迎留言探討你的想法</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="DevOps" term="DevOps"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「面試人生 - 設計一個簡易的分散式 Job Scheduler」]]></title>
        <id>https://hwchiu.com/2022/06/27/reading-notes-63</id>
        <link href="https://hwchiu.com/2022/06/27/reading-notes-63"/>
        <updated>2022-06-27T02:05:08.000Z</updated>
        <summary type="html"><![CDATA[「面試人生 - 設計一個簡易的分散式 Job Scheduler」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「面試人生 - 設計一個簡易的分散式 Job Scheduler」
類別: others
連結: <a href="https://medium.com/@raxshah/system-design-design-a-distributed-job-scheduler-kiss-interview-series-753107c0104c" target="_blank" rel="noopener noreferrer">https://medium.com/@raxshah/system-design-design-a-distributed-job-scheduler-kiss-interview-series-753107c0104c</a></p><p>本篇文章是一個面試技術文，探討開發一個類似 Job Scheduler 的專案時應該要如何去設計整體系統來完成需求，整體的架構基於 KISS 的原則，就是簡單為主。</p><p>整個流程原則基本上是</p><ol><li>理解所有功能需求，包含功能面以及非功能面</li><li>瞭解可能的資料，根據規模大小與功能需求去推估出整體的規模大小</li><li>根據上述需求去規劃整體架構，其中規模大小有時候可以幫忙歸納出 ”讀寫“彼此的比例，這個會影響架構設計</li></ol><p>功能面常見類型如</p><ol><li>針對使用者提供何種操作，譬如遞交一個 Job, 列出所有 Job(當前，歷史)</li><li>每個 Job 的運行時間限制(ex, 5min)，同時 Job 可以重複運行或是只運行一次等不同用法</li><li>Job 本身也有優先度的設計，可以插隊等</li></ol><p>非直接功能面如</p><ol><li>可動態擴充規模來支援不同量級的需求</li><li>不論發生任何錯誤問題，使用者提交過的 Job 資訊都不能遺失</li><li>非同步設計，使用者遞交 Job 後就可以繼續別的工作， Job 完成後會主動通知使用者</li></ol><p>有了功能面的需求，接下來就是數量大小的需求，譬如該架構要可以達到每秒 1000 個 Job(1000QPS),
從這些需求下去估算大概需要多少 CPU 以及多少 Memory，同時這些數量還可以滿足功能面的需求，譬如每個 Job 可以運行最多五分鐘。</p><p>所以也許會得到需要 10,000 台的 (16C) 機器，以及 100 台(16GB) 的機器來提供服務
基本的運算可以快速的理解該需求到底需不需要分散式的架構來處理，本文的範例資料量就很明顯是 scale up 沒有辦法完成的。</p><p>接下來就基於分散式的架構去設計相關架構，包含如</p><ol><li>Load Balancer</li><li>Backend</li><li>DB</li><li>Job scheduler</li><li>Job Executor</li><li>Queue</li><li>File system</li></ol><p>逐步的規劃這些架構，並且探討彼此元件之間的溝通方式，這些方式是如何互相組合來滿足功能面/非功能面的需求</p><p>詳細需求可以參考全文</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Cloudflare 06/21 災後報告」]]></title>
        <id>https://hwchiu.com/2022/06/23/reading-notes-62</id>
        <link href="https://hwchiu.com/2022/06/23/reading-notes-62"/>
        <updated>2022-06-23T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「Cloudflare 06/21 災後報告」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「Cloudflare 06/21 災後報告」
類別: networks
連結: <a href="https://blog.cloudflare.com/cloudflare-outage-on-june-21-2022/" target="_blank" rel="noopener noreferrer">https://blog.cloudflare.com/cloudflare-outage-on-june-21-2022/</a></p><p>Cloudflare 官方文章詳細解釋 06/21/2022 當天到底發生什麼事情導致用戶受到影響，</p><p>這次的問題影響範圍概括了 Cloudflare 底下的 19 個資料中心，而很不幸的這 19 個資料中心剛好都是負責處理繁忙的全球流量，所以受到影響的用戶數量才會如此的多。
問題主因是網路設定的調整(有問題先猜BGP，不行再猜DNS...)，整體的發生時間沒有非常長</p><ol><li>06:27 UTC 問題發生</li><li>06:58 UTC 第一個資料中心修復並且上線</li><li>07:42 UTC 所有資料中心修復並且上線 </li></ol><h1>背景</h1><p>過去 18 個月以來， Cloudflare 致力於將其底下繁忙的資料中心進行架構改造來達成更為堅韌與彈性的網路架構，內部稱該架構為 Multi-Colo POP(MCP)，影響的 19 個資料中心包含 Tokyo, Singapore ... 等</p><p>新架構最重要的部分就是其網路的部分是基於 Clos network 的架構設計，透過多層次的設計達成類似 mesh network 般的網路連結，該架構使得未來要維護與調整時能夠更輕鬆針對部分網路設備去處理而不會影響到整體網路(文章有架構圖片)。</p><h1>問題</h1><p>這次的問題主要跟 BGP 有關，Cloudflare 更新 BGP 的過程中有部分的 subnet 沒有順利的被傳遞出去，最終使得部分 subnet 的流量無法被順利轉發，進而導致整個網路問題。</p><p>文章內部有針對 BGP 問題更詳細的介紹，熟悉 BGP 的朋友可以花點時間看一下</p><h1>反思</h1><p>這次的問題影響範圍很廣，Cloudflare 針對下列三面向反思了一下問題的發生原因</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="process">Process<a href="#process" class="hash-link" aria-label="Direct link to Process" title="Direct link to Process">​</a></h2><p>雖然嶄新的 MCP 架構其目的就是要提供更好更強的可用性，但是將舊架構給升級到新架構的過程中還是不夠完善。整體的更新流程直到最後一步驟才算是真正的接觸到全新 MCP 架構，這使得如果中間更新流程有錯必須要到最後才會觀察到 MCP 資料中心的網路炸了。
改善的方式則是未來的這些流程與自動化必須要加入更多關於 MCP 架構的測試來確保整體部署不會遇到預期外的結果。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="architecture">Architecture<a href="#architecture" class="hash-link" aria-label="Direct link to Architecture" title="Direct link to Architecture">​</a></h2><p>路由器的錯誤設定使得正確的路由規則沒有辦法順利的被傳達下去，最終使得網路封包無法如預期般地到達這些資料中心。
所以修復過程中就是要找出這些錯誤的設定並且修正，最終使得這些 BGP 能夠將正確的路由政策給轉發下去。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="automaiton">Automaiton<a href="#automaiton" class="hash-link" aria-label="Direct link to Automaiton" title="Direct link to Automaiton">​</a></h2><p>當前的自動化流程中有非常多的部分可以改進，這些改進有機會完全或是部分的去減緩問題發生時的影響程度。
有兩個目標是想要透過改善自動化機制達成的</p><ol><li>減少問題發生時的影響範圍</li><li>減少問題發生時的修復時間</li></ol><h1>結論</h1><p>CDN 不通先上社群看同業有沒有哀嚎，大概就可以知道是不是自己的問題了?</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「啟動 container 直接 kernel panic 的 bug」]]></title>
        <id>https://hwchiu.com/2022/06/15/reading-notes-61</id>
        <link href="https://hwchiu.com/2022/06/15/reading-notes-61"/>
        <updated>2022-06-15T01:05:08.000Z</updated>
        <summary type="html"><![CDATA[「啟動 container 直接 kernel panic 的 bug」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「啟動 container 直接 kernel panic 的 bug」
類別: others
連結: <a href="https://bugs.launchpad.net/ubuntu/+source/linux-aws-5.13/+bug/1977919" target="_blank" rel="noopener noreferrer">https://bugs.launchpad.net/ubuntu/+source/linux-aws-5.13/+bug/1977919</a></p><p>本篇文章探討的是一個關於 Ubuntu kernel(5.13+) bug 產生的各種悲劇，已知受害的雲端業者包含</p><p>linux-oracle
linux-azure
linux-gcp
linux-aws</p><p>等常見大廠。</p><p>簡單來說，預設設定下只要簡單跑一個 container 譬如
<code>docker run -it ubuntu bash</code> 就可以直接觸發 kernel panic，直接讓你系統死亡強迫重啟</p><p>整個 bug 結論來說就是，一連串的操作最後有機會導致使用到一個 null pointer，然後 kernel 就炸拉...</p><p>相關的修復可以參閱這個連結，裡面有大概提到問題發生點以及修復方式。
<a href="https://kernel.ubuntu.com/git/ubuntu/ubuntu-impish.git/commit/?id=6a6dd081d512c812a937503d5949e4479340accb" target="_blank" rel="noopener noreferrer">https://kernel.ubuntu.com/git/ubuntu/ubuntu-impish.git/commit/?id=6a6dd081d512c812a937503d5949e4479340accb</a></p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Container" term="Container"/>
        <category label="Linux" term="Linux"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「分散式系統上的常見網路謬誤」]]></title>
        <id>https://hwchiu.com/2022/06/13/reading-notes-60</id>
        <link href="https://hwchiu.com/2022/06/13/reading-notes-60"/>
        <updated>2022-06-13T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「分散式系統上的常見網路謬誤」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「分散式系統上的常見網路謬誤」
類別: others
連結: <a href="https://architecturenotes.co/fallacies-of-distributed-systems/" target="_blank" rel="noopener noreferrer">https://architecturenotes.co/fallacies-of-distributed-systems/</a></p><p>本篇文章是探討分散式系統上很常被開發者所忽略的網路情況，這些情境都容易被忽略與考慮，但是每個點實際上都會影響整個系統的效能與功能</p><p>這些常常被忽略的網路情況包含</p><ol><li>The network is reliable</li><li>Latency is zero</li><li>Bandwidth is infinite</li><li>The network is secure</li><li>Topology doesn't change</li><li>There is one administrator</li><li>Transport cost is zero</li><li>The network is homogeneous</li></ol><h1>The network is reliable</h1><p>開發分散式系統的時候，一定要去考慮網路壞掉的情況，切記網路中的任何傳輸都不是 100% 穩定的。千萬不要假設所有封包與傳輸都沒有問題，必要時還要考慮重新連線，重新傳輸的情況。</p><h1>Latency</h1><p>網路時間還有一個要注意的就是延遲時間，通常 Client/Server 如果都是同一個系統內的服務時，這類型的時間可能非常短，如 ms 等級。
但是當 client 可能是來自真實使用者的手機裝置時，就要將 latency 這些因素給考慮進去，不能假設所有的 API 與網路請求都是秒回的情況。</p><p>更常見的還有導入 CDN 等方式透過地理性的位置來減少 client/server 之間要傳輸的距離。</p><p>文章內針對剩下的類別都有簡單的圖文並茂來解釋，淺顯易懂，有興趣的可以參閱全文</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Network" term="Network"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「為什麼有些工程師不相信 Best Practices 」]]></title>
        <id>https://hwchiu.com/2022/06/09/reading-notes-59</id>
        <link href="https://hwchiu.com/2022/06/09/reading-notes-59"/>
        <updated>2022-06-09T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「為什麼有些工程師不相信 Best Practices 」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「為什麼有些工程師不相信 Best Practices 」
類別: others
連結: <a href="https://blog.devgenius.io/why-some-developers-dont-believe-in-best-practices-8c03ea4f7e88" target="_blank" rel="noopener noreferrer">https://blog.devgenius.io/why-some-developers-dont-believe-in-best-practices-8c03ea4f7e88</a></p><p>工程師想必對於 DRY, KISS(Keep It Simple, Stupid), YAGNI(You Ain’t Gonna Need It) 這些廣為流傳的開發原則並不陌生，這些原則都是過去許許多多優秀工程師透過自己的經驗而濃縮的開發準則。</p><p>但是作者觀察到有滿多工程師對於這些 開發原則/命名標準/最佳實驗經驗 等採取一個不信任態度，甚至覺得導入這些東西都是浪費時間。
因此本文章是作者探討什麼樣的工程師可能會不太願意去學習與導入這些廣為流傳的開發原則與經驗</p><h1>Small projects and experience</h1><p>作者開宗明義地說，小專案的成功經驗基本上是沒有辦法導入到大專案的開發的，小專案的特型譬如 1) 合作人員很少 2)專案時間少
這類型的特性只得技術債或是欠缺設計的程式架構不太會影響整個專案，畢竟專案太小，時間太短，後續的人不一定有機會真的觀察到這些潛在的問題。</p><p>而小專案還有一個很大的特性就是後續維護的人很有可能跟當初的開發者不同，所以對於開發者來說非常難去感受後續維護的痛苦與需求。</p><p>上述特性有可能會使得開發者覺得自己的開發經驗非常足夠且堪用，因此就會基於這樣的經驗來抵抗其他更多被推廣且推崇的開發原則與最佳實戰經驗。</p><p>因此對於一些只開發過小專案且沒有後續維護的工程師來說，其有可能就不會想要學習這些原則與經驗，畢竟自己的工作流程根本沒有機會感受到好處。</p><h1>Reward and incentive</h1><p>簡單來說就是「劣幣逐良幣」的概念，從工程師開發的角度來看，寫一個「可能比較好維護，未來比較不會有問題，高品質的程式碼」如果實務上不會帶來任何好處，甚至可能「績效表現比較不好」的情況下，那為什麼工程師要努力寫出高品質的程式碼？</p><p>軟體團隊除了開發者之外，還會有相關的專案管理人員，產品管理人員以及最終使用者。
對於非技術人員來說，其在意的點更有可能專注於「程式開發速度，產品上線速度」，至於專案的後續維護性，開發靈活性等長時間才會看到的問題都不是他們所在意的點。</p><p>這種情況下，如何評價一個工程師的能力很有可能就變成「能夠多快的滿足專案需求，而不是寫出的程式碼品質」，所以對於工程師來說，快速寫出功能不考慮後續其他維護等長期問題反而更可能受到團隊重視，因為「功能出的快」。</p><p>所以如果團隊沒有辦法好好的去重視「高品質程式碼等考慮長期問題的開發原則」就有可能會導致工程師不會想要好好的去撰寫好的程式碼，長期下來這些工程師就可能會開始拒絕學習各種開發原則與最佳實踐的經驗，畢竟導入這些東西沒有任何實質上的幫助，反而初期可能會降低功能的上線速度。</p><h1>Ignorance</h1><p>「知彼知己，百戰百勝」，沒有花時間去學習這些開發原則的前後脈絡與適用情景就沒有辦法很順利的導入到開發專案中，所以實際上這些導入都要工程師花時間去學習與理解，然後嘗試導入與使用。</p><p>然而並不是每個工程師都願意花時間去學習，畢竟平常工作就是寫寫程式碼，寫寫文件，結果來說能動就好。花這些時間去學習這些東西</p><p>作者認為很多工程師「其實都不知道自己不知道什麼」，這導致他們很難去學習新技術與新概念，畢竟未知領域帶來的好處與優勢不是他們工作經驗中有機會去體驗到的，就如同前面所述，對一個擅長開發短期專案就拋棄給別人維護的人來說，其很難體會到各種長期維護與技術債的問題。
practices.</p><h1>Best practices, and poor practices get the same results initially</h1><p>另外一個非常常見的問題就是「導入開發原則與好的開發經驗」與否對於初期開發來說很有可能沒有很任何明顯的差異。
從短期目標來看，兩者開發角度產生的結果不會差異太大，但是對於只有幾個月的小專案來說，後者甚至能夠更快的完成需求然後拍拍屁股結束閃人。</p><p>架構複雜性，技術債以及其他的爛程式碼可能產生的後續問題都需要時間發酵，所以團隊事主如果沒有辦法以長期觀念來看到程式開發的話，上述的問題就沒有辦法被重視，就如同前面所述，開發者就會「速度為主，品質為輔」的概念來開發，至於後續維護痛苦與否就是後續接手人的事情。</p><p>剩下其他論點就可以到原文去觀賞</p><h1>Professionalism</h1><h1>Short-term approach</h1>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「使用 StressChaos 的經驗來學習 Pod Memory 使用情況」]]></title>
        <id>https://hwchiu.com/2022/06/06/reading-notes-58</id>
        <link href="https://hwchiu.com/2022/06/06/reading-notes-58"/>
        <updated>2022-06-06T03:05:07.000Z</updated>
        <summary type="html"><![CDATA[「使用 StressChaos 的經驗來學習 Pod Memory 使用情況」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「使用 StressChaos 的經驗來學習 Pod Memory 使用情況」
類別: others
連結: <a href="https://chaos-mesh.org/blog/how-to-efficiently-stress-test-pod-memory/" target="_blank" rel="noopener noreferrer">https://chaos-mesh.org/blog/how-to-efficiently-stress-test-pod-memory/</a></p><p>本篇文章是來自於 Chaos Mesh 內的官方文章，主要是想要探討為什麼使用 Chaso Mesh 來測試記憶體狀況時結果實際狀況與設定的狀況不一致
文章一步一步的探討所有問題最後同時也整理了一些關於 Kubernetes 內的 Memory 相關機制</p><p>文章開頭，作者先部署了一個簡單的 Pod(只有一個 container)，該 Pod 針對 Memory 的部分設定 request: 200Mi, limits: 500Mi
結果作者到該 Container 中透過 free 與 top 的指令，都觀察到顯示的記憶體使用量高達 4G，這部分明顯與設定的 limits 500Mi 有所衝突
因此這邊產生了第一個點要特別注意</p><p>Kubernetes 是透過 cgroup 來計算與控管 Pod 的 Memory 用量，然而 free/top 等指令並沒有跟 cgroup 整合，因此就算跑到 container 中執行這兩個
指令看到的輸出其實都是 host 相關的，如果想要知道真正 container 相關的數量，還是要使用 cgroup 相關的指令來取得，譬如
cat /sys/fs/cgroup/memory/memory.usage_in_bytes </p><p>文章還有特別提到 Kubernetes 會針對 Request/Limit 的設定方式來將你的 Pod 分為三個等級，分別是 BestEffort, Burstable 以及 Guaranteed
其中當系統因為 OOM 不足要開始找受害者下手時，被設定為 Guaranteed 的應用程式則會是最低優先度，只有真的找不到其他受害者時才會來處理 Guaranteed 類型的 Pod。</p><p>最後則是更細部的去探討 Kubernetes 關於 Memory 的使用與管理
對於 Kubernetes 來說， 當系統上 Memory 數量不足時，可能會觸發 Evict 的行為，開始將部分運行的 Pod 給踢出該節點，而如同前面所述， Kubernetes 是依賴
Cgroup 來處理的，因此 /sys/fs/cgroup/memory/memory.usage_in_bytes 自然而然就成為其決策的重要參數</p><p>其中要注意的是 /sys/fs/cgroup/memory/memory.usage_in_bytes 代表的並不是 "剛剛好系統上正在被使用的 Memory 數量"，其數值則是由
"resident set", "cache", "total_inactive_file" 等三個面向組合而成，因此 Kubernetes 實際上會先從
/sys/fs/cgroup/memory/memory.usage_in_bytes 與 /sys/fs/cgroup/memory/memory.stat 取得相關參數，其中後者可以得到如 total_inactive_file 的數量
最後透過下列算式
working_set = usage_in_bytes - total_inactive_file 來得到一個名為 working_set 變數，該變數實際上也可以由 kubectl top 獲取，這也是 kubernetes 用來判斷是否執行 evict 的主要指標。</p><p>一個節點還有多少可用的 Memory 則是透過
memory.available = nodes.status.capacity<!-- -->[memory]<!-- --> - working_set
所以每個節點的總共量扣掉 workign_set 就是當前可用量，一旦當前可用量低於門檻時，也就是 k8s 執行 evict 之時
官網文件中其實有滿仔細的去描述這些操作行為
有興趣的可以花點時間全部看完
<a href="https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/" target="_blank" rel="noopener noreferrer">https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/</a></p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
        <category label="ResourceManagement" term="ResourceManagement"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「/proc/meminfo 與 free 指令的內容比較」]]></title>
        <id>https://hwchiu.com/2022/06/03/reading-notes-57</id>
        <link href="https://hwchiu.com/2022/06/03/reading-notes-57"/>
        <updated>2022-06-03T02:05:07.000Z</updated>
        <summary type="html"><![CDATA[「/proc/meminfo 與 free 指令的內容比較」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「/proc/meminfo 與 free 指令的內容比較」
類別: others
連結: <a href="https://access.redhat.com/solutions/406773" target="_blank" rel="noopener noreferrer">https://access.redhat.com/solutions/406773</a></p><p>本篇文章要探討的是到底 /proc/meminfo 與 free 這個指令所列出來的 memory 相關資訊到底該怎麼匹配</p><p>雖然文章有特別強調主要是針對 RedHat Enterprise Linux 5,6,7,8,9，但是我認為大部分的 Linux 發行版的差異不會太大，畢竟整體都是來自於 Kernel 內的實作，我認為還是值得閱讀與理解。</p><p>對於大部分的系統管理員來說，勢必都有聽過 free 這個指令，該指令可以列出系統上當前的 memory 使用狀況，舉例來說通常會有
Total, Used, Free, Shared, Buffers, Cached 之類的欄位(不同版本可能會有些許差異)。
不熟悉的人可能會認為系統上的記憶體就只有“全部“,"使用中","閒置" 等三種類型，而實際上的記憶體處理遠比這些複雜，這也是為什麼 free 的輸出欄位會比較多的原因</p><p>除了 Free 指令外， Kernel 本身還有提供一個特殊的檔案位置讓使用者可以讀取當前的 memory 狀況，該位置為 /proc/memifno，其會提供如
MemTotal, MemFree, Buffers, Cached 等相關欄位</p><p>本文並不會針對每個欄位去探討實際上的意義，取而代之的是簡單的比對，透過幾個列表讓你清楚的知道 free 指令輸出的每個欄位要如何與 /proc/meminfo 去比較，要如何轉換等
特別要注意的是文章內有仔細地針對不同 RedHat Enterprise Linux 版本去分別探討，所以如果是 RedHat 系列的使用者更要好得閱讀並確保能夠理解自己當前使用版本的狀況</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Linux" term="Linux"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「goss, 一個簡易且迅速的 server 驗證工具」]]></title>
        <id>https://hwchiu.com/2022/06/01/reading-notes-56</id>
        <link href="https://hwchiu.com/2022/06/01/reading-notes-56"/>
        <updated>2022-06-01T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「goss, 一個簡易且迅速的 server 驗證工具」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「goss, 一個簡易且迅速的 server 驗證工具」
類別: others
連結: <a href="https://github.com/aelsabbahy/goss" target="_blank" rel="noopener noreferrer">https://github.com/aelsabbahy/goss</a></p><p>今天要介紹的是一個驗證工具 goss，該工具的目的非常簡單，讓系統管理員可以透過 YAML 的方式幫機器上的服務撰寫 Unit Testing
什麼情況會需要使用這類型工具？</p><p>舉例來說，當你今天部署了一個全新機器(手動/自動後)，你安裝了下列軟體</p><ol><li>sshd</li><li>nginx</li><li>docker</li><li>....</li></ol><p>同時你也根據需求事先創建了一些使用者，接者你想要驗證這些軟體與相關設定是否設定完成
最直覺的方式就是手動檢查，一個一個服務與設定人工檢查</p><p>而 goss 這套軟體的目的就是讓你用 YAML 的方式去撰寫你想要驗證的所有服務，可以用來驗證包含</p><ol><li>使用者 (uid, gid, home, shell)</li><li>Package: 系統是否有透過 rpm, de, pacman, apk 等安裝套件</li><li>File: 檢查檔案資料夾是否存在</li><li>Addr: 用來檢查 $IP:$Port 是否可以被存取</li><li>Port: 用來檢查 $Port 是否有開啟</li><li>DNS: 用來檢查是否可以解析特定 DNS </li><li>Process: 檢查特定 Process 是否有開啟</li><li>Mount: 檢查是 Mount Point 以及相關參數</li><li>Kernel Param: 檢查 Kernel 參數</li><li>...等</li></ol><p>Goss 除了基本用法外，也有人基於其概念往上疊加 dgoss，用來驗證 Docker 的運行狀態，還有類似的 dcgoss，針對 docker-compose 來使用。
當然目前也很多人會透過 Ansible 的方式來自動化部屬，而 Ansible 本身其實也有相關的測試框架可以用來測試部署結果，所以到底要用哪類型的工具
來驗證 Server 等級的狀態就根據團隊需求與現有流程而定，比較沒有一個獨大的工具用法。</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「如何寫出有意義的討論訊息 」]]></title>
        <id>https://hwchiu.com/2022/05/30/reading-notes-55</id>
        <link href="https://hwchiu.com/2022/05/30/reading-notes-55"/>
        <updated>2022-05-30T00:05:07.000Z</updated>
        <summary type="html"><![CDATA[「如何寫出有意義的討論訊息 」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「如何寫出有意義的討論訊息 」
類別: others
連結: <a href="https://conventionalcomments.org/" target="_blank" rel="noopener noreferrer">https://conventionalcomments.org/</a></p><p>本篇文章非常短，大意就是探討透過文字討論事項時如何讓這些訊息更有意義，能夠讓目標受眾可以更快的理解該訊息的意義
假如今天有人想要反應「This is not worded correctly.」的概念，作者認為相對於直接撰寫「該文字措辭不當」，可以適當的加上一些是先定義好的前綴形容詞
譬如
「suggestion: This is not worded correctly.
Can we change this to match the wording of the marketing page?」</p><p>「nitpick (non-blocking): This is not worded correctly.」</p><p>透過這些有共識的形容詞可以讓團隊之間的溝通速度快，減少誤解與猜測的可能性，讓整體的溝通效率更高，譬如
「suggestion: Let's avoid using this specific function…
If we reference much of a function marked Deprecated, it is almost certain to disagree with us, sooner or later.」</p><p>「issue (ux,non-blocking): These buttons should be red, but let's handle this in a follow-up.」   </p><p>透過這些形容詞能夠提醒目標受眾該討論的一些概念，同時也能夠讓對方更有想法下一步驟可以怎麼做。
作者就自己的習慣列舉了幾個下列前綴形容詞</p><ol><li>Praise: 正面的去稱讚該事項</li><li>Nitpick: 大部分都是一些非常小然後不會影響整體功能的小問題，譬如個人偏好等相關討論</li><li>Suggestion: 針對當前目標有想要改進的部分，而且重點是要很明確且清楚的描述到底問題是什麼，以及為什麼需要這個改進。</li><li>Issue: 強調當前主題下的潛在問題，如果確定該問題已經存在，搭配 Suggestion 來描述，否則可搭配 Question 來確認該問題是否存在</li><li>Todo: 針對簡單且非必要的一些修改，主要是讓受眾能夠區分這些討論的重要性，能夠專注於當前更重要的事項</li><li>Question: 如果對於當前主題有一些不確定的問題，就使用 Question 讓其他人認知到你有問題要發問，能夠幫助你更快的得到解答。</li></ol><p>說到底這類型的討論都是一個習慣，就如同 coding style 一樣，所有共事者有一個共識原則，大家合作起來會更加有效率有方便
文中說的方法也不是唯一的辦法，但是團隊內有一個準則文化絕對會帶來好處的</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「如何提供專業 Code Review 意見」]]></title>
        <id>https://hwchiu.com/2022/05/27/reading-notes-54</id>
        <link href="https://hwchiu.com/2022/05/27/reading-notes-54"/>
        <updated>2022-05-27T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「如何提供專業 Code Review 意見」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「如何提供專業 Code Review 意見」
類別: others
連結: <a href="https://medium.com/@yar.dobroskok/how-to-review-the-code-like-a-pro-6b656101eb89" target="_blank" rel="noopener noreferrer">https://medium.com/@yar.dobroskok/how-to-review-the-code-like-a-pro-6b656101eb89</a></p><p>作者開門見山提到，如果團隊中沒有任何 code review 文化的話，請直接忽略這篇文章。
當團隊真的有 code review 的經驗時，才有機會透過本篇文章分享的一些概念來改善整個 code review 的流程，高效率低耗時。</p><p>作者認為一個好品質的 code review 能夠幫助團隊帶來下列好處</p><ol><li>避免合併一些充滿 bug, 難讀, 無效率的程式碼到專案中</li><li>開發者可以互相分享彼此的知識</li><li>獲得關於實作上的各種意見</li><li>確保團隊內的 coding style 一致</li></ol><p>為了讓上述概念可以充分的導入到團隊專案中，作者分享了一些自己常用的概念與招式</p><p><em>事先準備一份 Checklist</em>
一個好的 review 流程就是要有一份檢查清單，這份清單上面描述的是每次程式碼合併都“必須”要符合的規則，同時也是團隊很重視的規則
這份清單沒有絕對標準，主要是根據團隊去思考哪些東西是最重要的，舉例來說</p><ol><li>Branch, Commit 內容與名稱是否符合規範</li><li>Code 是否有足夠的可讀性</li><li>Codesytle 以及命名規範是否符合團隊文化</li><li>資料夾/檔案結構是否符合團隊文化</li><li>是否有包含相關測試</li><li>文件是否有一起準備</li></ol><p>這份清單的重點是只要列入那些被視為是非常必須且重要的項目就好，不然整個清單落落長其實意義也不高</p><p><em>盡可能的自動化上述檢查</em>
準備好前述清單後，下一個步驟就是想辦法將上述清單規範給自動化，譬如</p><ol><li>透過 linters 來檢查 codesytle</li><li>運行一些如 SonarQube, Codacy 等工具來幫忙檢查是否有潛在的低效率或是有漏洞的程式碼</li><li>透過相關框架運行自動化測試並且得到相關的覆蓋率報表</li></ol><p>當有辦法自動化這些操作後，下一個步驟就是要思考什麼時候執行？</p><ol><li>針對一些快速檢查，譬如 linter, beautifer 等工具，可以考慮整合到 pre-commit hook/ pre-push Git hook 等時間點運行
這樣就可以讓開發者快速檢查簡單錯誤</li><li>針對一些比較花時間的檢查，譬如分析工具，測試以及相關建置流程這些都可以放到 CI pipeline 去運行</li></ol><p>一切都準備完畢後就可以將其整合到整個 git 工具中，譬如只有當 CI pipeline 通過的 PR 才有被人 review 的需求，如果連自動化測試都沒有辦法通過，那就是開發者的
責任要去將其完成，一切準備就緒後才要開始最後一步</p><ul><li>人工介入 review *
開始人工 review 時，因為前述自動化的過程已經幫忙檢查非常多的事項，所以這時候要專注的就是運作邏輯。
能的話作者建議 review 與其慢慢看 code 猜想不如直接跟開發者一起討論 review，可以避免來回溝通花費的無效時間
此外開發者也可以更清楚地去解釋所有實作的背後理由與考量。</li></ul><p>作者也推薦採用 IDE 來進行 code review，很多 IDE 強大的功能都能夠幫助開發者更有效率地去檢視程式碼，譬如快速找到宣告點，被呼叫點以及整個資料結構的面貌等
這些都可以省下不少時間</p><p>最後最重要的是每次 PR 的大小不能太大，這點其實也是 Linux Kernel 內一直奉行的原則，過大的修改有太多檔案要看，同時也有更多可能潛在的不相容問題要注意
這對開發者與 reviewer 來說都是個沈重的負擔，因此能的話將修改以拆分成數個有意義的 PR 分別檢視會使得整體流程更講有效率，同時也可以避免
檔案太多時可能看不下去就直接無腦 +2 的蓋章行為</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Mizu, 一套用來檢視 Kubernetes Traffic 的視覺化工具」]]></title>
        <id>https://hwchiu.com/2022/05/25/reading-notes-53</id>
        <link href="https://hwchiu.com/2022/05/25/reading-notes-53"/>
        <updated>2022-05-25T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「Mizu, 一套用來檢視 Kubernetes Traffic 的視覺化工具」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「Mizu, 一套用來檢視 Kubernetes Traffic 的視覺化工具」
類別: tools
連結: <a href="https://getmizu.io/docs/" target="_blank" rel="noopener noreferrer">https://getmizu.io/docs/</a></p><p>Mizu 是一個專門針對 Kubernetes 開發的流量分析工具，該工具透過簡單好用的 UI 讓你檢視叢集內的流量走向，其支持的協定有
HTTP, REST, gRPC, Kafka, AMQP 以及 Redis 等相關的應用程式封包。</p><p>雖然說透過大部分的 Service Mesh 也都可以提供一樣的功能，但是 Mizu 的特色就是其輕量的架構設計，就是針對流量分析而已，所以如果團隊目前沒有現成的解決方案時，
可以考慮試試看 Mizu 這套輕量級的解決方案。</p><p>Mizu 本身由兩個元件組成，分別是 CLI 以及 Agent，當你安裝 Mizu 的 Kubernetes 內時，其會安裝兩個元件</p><ol><li>透過 Daemonset 安裝 Agent 到所有節點</li><li>透過 Pod 安裝一個 API Server</li></ol><p>Agent 會針對需求去抓取節點上特定的 TCP 封包(目前也只有支援 TCP 流量，這意味如 ICMP, UDP, SCTP 等就沒有辦法)，此外要特別注意這類型的解決方案為了能夠
抓取到節點上的所有流量，通常都會讓這類型的 Agent 都設定為 hostnetwork: true，如此一來該 Agent 才有辦法觀察到節點上的所有網卡來進行流量擷取。</p><p>有些 k8s 環境會透過如 OPA(Gatekeeper) 等機制去控管要求所有的 Pod 不准使用 hostnetwork，有這些規範的可能就要注意一下整合上的問題。</p><p>有興趣的可以稍微玩看看，看看這類型的工具是否可以幫忙除錯</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Network" term="Network"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Tetragon, 基於 eBPF 的 Kubernetes 資安管理工具」]]></title>
        <id>https://hwchiu.com/2022/05/23/reading-notes-52</id>
        <link href="https://hwchiu.com/2022/05/23/reading-notes-52"/>
        <updated>2022-05-23T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「Tetragon, 基於 eBPF 的 Kubernetes 資安管理工具」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「Tetragon, 基於 eBPF 的 Kubernetes 資安管理工具」
類別: others
連結: <a href="https://isovalent.com/blog/post/2022-05-16-tetragon" target="_blank" rel="noopener noreferrer">https://isovalent.com/blog/post/2022-05-16-tetragon</a></p><p>Cillium 的開發團隊 isovalent 最近公布其內部一直使用的資安相關專案， Teragon (可愛的蜜蜂戰士)。</p><p>Teragon 底層是基於 eBPF 的技術，其目的就是讓你的 Kubernetes 於資安方面可以獲得超級強大的能力，包含</p><ol><li>詳細的視覺化功能，讓你可以一目瞭然到底系統中各項資源的發生過程</li><li>動態強化，可以讓你透過 Kubernetes CRD, OPA, Json 等各種格式來描述相關規範，然後動態無縫的套入到你的 Kubernetes 叢集中</li></ol><p>探討 Teragon 前，要先理解以前目前已知的相關解決方案有哪些，而這些解決方案又有什麼樣的優缺點，包含</p><ol><li>App Instrumentation</li><li>LD_PRELOAD</li><li>ptrace</li><li>seccomp</li><li>SELinux/LSM</li><li>Kernel Module</li></ol><p>上述六個方式都有各自的特點，這邊簡單敘述</p><p>App Instrumentation
O 效率高，可以看到非常細部的資訊
X 程式碼需要修改，不夠透明
X 單純的視覺化，不能套入資安規則來防護應用程式
X 應用程式為主，不能理解整個系統的狀況</p><p>LD_PRELOAD (動態切換載入的 Library )
O 效率高
O 應用程式不需要修改
X 如果是 Static Llinking 的應用程式那就沒有用了
X 幾乎沒有什麼觀察性可言</p><p>ptrace (透過 kernel 提供的功能來檢視使用的 syscall)
O 透明，應用程式不用修改
X 效能負擔比較高
X 應用程式有辦法偵測到自己目前被 ptrace 給監控
X 整體範圍只能針對 syscall(系統呼叫)</p><p>seccomp (可以過濾應用程式呼叫的 syscall)
O 有效率，應用程式不需要修改
X 規則只能針對 syscall 去阻擋
X 沒有很好的視覺化方式</p><p>SELinux/LSM (Kernel 內建的 security 框架，可以針對存取去控制)
O 有效率，應用程式不需要修改
O 可防 TOCTTOU 攻擊
X 針對 Contaienr/Kubernetes 的整合很有限
X 不容易擴充
X 要針對攻擊類型去設定</p><p>Kernel Module
O 有效率，應用程式不需要修改
O 不用修改 Kernel 就可以擴充功能
X 不是每個環境都允許使用者去載入 kenrel Module
X Module 有問題會打爆你的 Kernel
X 沒辦法無縫升級，意味你升級功能的過程中必須要將kernel module給 uninstall ，然後重新安裝</p><p>上列六個解決方案有的只能檢視相關流程，有的只能設定規則去防護，但是就是沒有一個工具可以全面處理，而基於 eBPF 實作的 Tetragon 則是一個
能夠提供兩項功能的全新解決方案。</p><p>首先資安防護方面， Tetragon 採取的是更底層的概念，不去探討特定的 CVE 操作手法，取而代之的是從幾個常見的攻擊方式來防禦。
假如有任何應用程式有不預期的下列行為，就可以直接將該 Process 移除</p><ol><li>使用到不該使用的 capability</li><li>使用到不該使用的 linux namespace</li><li>使用到不該使用的 binary</li><li>看到不該出現的 Pid </li><li>...</li></ol><p>這些規則都可以透過 Kubernetes CRD 來描述，當這些規則被送到 Kubernetes 後，相關的 Controller 就會將規則給轉換後續讓 eBPF 來處理
此外因為 eBPF 以及 kprobe 的架構，Tetragon 能夠看到非常多 kernel 的資源存取與操作，譬如</p><ol><li>syscall(系統呼叫)</li><li>Virtual FS</li><li>TCP/IP</li><li>namespace</li><li>Storage</li><li>Network</li></ol><p>Tetragon 收集上列不同資訊的資料後進行二次處理，透過精美的網頁來顯示系統中的各種資訊，這些資訊可以提供包含</p><ol><li>哪些 Pod 一直存取 /etc/passwd, 採用何種方式存取 /etc/passwd</li><li>特定 Pod 中對外的網路流量資訊，從封包內容到用什麼指令去存取都可以看光光</li><li>...</li></ol><p>eBPF 的應用愈來愈多，而目前看起來 isovalent 更是 Kubernetes 生態系中的領頭羊，雖然不確定未來是否能夠被廣泛採用，但是至少這方面還沒有看到其他解決方案有這麼積極的基於 eBPF 來開發
有餘力的話花點時間學習一下 eBPF 的概念可以加強自己對於這類型文章的速度與理解度</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="ePBF" term="ePBF"/>
        <category label="Security" term="Security"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Datree, Kubernetes Configuration 檢查工具」]]></title>
        <id>https://hwchiu.com/2022/05/20/reading-notes-51</id>
        <link href="https://hwchiu.com/2022/05/20/reading-notes-51"/>
        <updated>2022-05-20T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「Datree, Kubernetes Configuration 檢查工具」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「Datree, Kubernetes Configuration 檢查工具」
類別: tools
連結: <a href="https://opensource.com/article/22/4/kubernetes-policies-config-datree" target="_blank" rel="noopener noreferrer">https://opensource.com/article/22/4/kubernetes-policies-config-datree</a></p><p>如同各類程式語言的測試框架， Kubernetes 的部署文件(YAML)實際上也是可以導入 CI 的概念，那到底 YAML 檔案有什麼東西需要檢驗？
最基本的概念大致上可以分成三種</p><ol><li>YAML 語法的檢查</li><li>Kubernetes YAML 的語意檢查</li><li>Kubernetes YAML 的設定規範檢查</li></ol><p>除了基本的 YAML 部署外，還要考慮一下團隊是採用何種方式來管理 Kubernetes App，譬如原生 YAML, Helm, Kustomize 等各種不同方法。</p><p>(1) 的話其實最基本的方式就是使用 yq 指令，其本身就可以檢查基本的 YAML 語法，如果是 Helm 的使用者也可以透過 Helm template 的方式來嘗試渲染，渲染的過程也會幫忙檢查 YAML 的合法性。
(2) 的話其實也有其他如 kubeval 等類型的工具去幫忙檢驗 YAML 內容是否符合 Kubernees Scheme，這邊要特別注意的還有版本問題，畢竟每次升級都會有很多 API Version 被調整
(3) 的話講究的是規範，譬如要求所有 workload 都必須要描述 CPU/Memory 的Request/Limit，或是要求所有容器都要以 non-root 的身份運行，
這部分有如 kube-score，或是基於 REGO 的 conftest 等工具可以檢測。</p><p>而今天分享的這個工具 datree 基本上就是一個人包辦上述三個工具，該工具基本上有兩種模式使用</p><ol><li>local 使用，就如同上述所有工具一樣，你可以把所有策略與規則都放到本地環境，搭配 git hook, CI pipeline 等概念去執行</li><li>datree 還提供了一個中央管理 Policy 的伺服器，每個運行 datree 的環境都可以與該團隊維護的 server 連動，讓你透過網頁的方式去設定想要驗證的 k8s 版本以及想要檢測的規範有哪些。</li></ol><p>基本上這類型的工具愈來愈多，找到一個適合團隊的工具將其整合到 CI 中，讓團隊的 Kubernetes YAML 都能夠符合團隊規範，同時也透過 CI 的流程盡可能提早地找出問題</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「基於 eBPF 的 ServiceMesh」]]></title>
        <id>https://hwchiu.com/2022/05/11/reading-notes-50</id>
        <link href="https://hwchiu.com/2022/05/11/reading-notes-50"/>
        <updated>2022-05-11T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「基於 eBPF 的 ServiceMesh」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「基於 eBPF 的 ServiceMesh」
類別: networking
連結: <a href="https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh" target="_blank" rel="noopener noreferrer">https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh</a></p><p>本篇文章是 2021末 由 Cilium 背後的 isovalent 公司團隊所發表的文章，主要探討一個全新的 Service Mesh 的架構可能帶來的好處，整篇文章以 Cillium + eBPF 為背景去探討
我認為如果對於 eBPF 沒有全面理解的情況下，其實只能讀懂這篇文章想要帶來的果，沒有辦法去理解到底整體實作與運作原理，同時因為 eBPF 本身的用途除了網路(Cilium)之外有愈來愈多的底層除錯工具都是透過 eBPF 的概念來實作的，因此學習 eBPF 的概念其實帶來的好處很多，有空的都推薦大家花點時間去學習。</p><p>本文主要分成幾個部分</p><ol><li>什麼是 Service Mesh 以及目前的主流做法</li><li>聊一下 Linux 網路傳輸的歷史發展</li><li>基於 eBPF 的 Service Mesh 架構</li><li>不同架構下的差異以及可能的隱性成本</li></ol><p>隨者分散式應用程式架構的興起，如何針對這些散落各地的應用程式提供關於網路連線方面的資訊一直以來都是維運上的問題，過往最簡單的方式就是針對各種開發環境導入相關框架
每個應用程式都需要修改來整合這些框架，但是隨者整個架構發展與要求愈來愈多，譬如開發環境有不同程式語言，甚至有不可修改的第三方應用程式，除了網路監控外還想要導入認證授權，負載平衡等各種功能
要求每個應用程式開發者引用這些框架已經沒有辦法漂亮的滿足所有需求，因此一個能夠無視應用程式本體的透明性框架架構就變成眾人追捧與渴望的解決方案。</p><p>現今大部分的 Service Mesh 就是採取這種透明性的架構，透過額外 Proxy 來攔截應用程式的封包進行後續管理與監控，使得</p><ol><li>應用程式開發者專注自己的商業邏輯開發</li><li>第三方不可修改應用程式也可以導入這些進階網路功能</li></ol><p>以 kubernetes 來說，目前主流都是透過 sidecar 的概念，讓每個應用程式旁邊都放一個 Proxy 的應用程式，同時基於 Pod 內 Containers 可以使用 localhost 互通的方式來處理連線。
應用程式本身都透過 localhost 打到 Proxy，而所有對外連線都讓 Proxy 幫忙處理，因此所有的進階功能都實作於該 Proxy 上。</p><p>Isovalent 認為這種方式功能面上可行，但是認為如果導入 Sidecar 其實有很多隱性成本</p><ol><li>根據測試不管哪種 Service Mesh/Proxy 的解決方案都會使得真正連線的 Latency 提高 3~4 倍，這主因是 Linux Kernel 的架構導致，所有的網路封包
都必須要於 Linux Kernel Network Stack 來回繞行很多次，封包這種東西來回本身又會牽扯到 Context Switch, Memory Copy 等各種成本，所以整體 Latency 的提升是不可避免的。</li><li>系統的額外資源需求，每個 Pod 都需要一個額外的 Proxy 來處理，以一個 500 節點，同時每個節點都有 30 Pod 來說，整個環境就要額外部署 15,000 的 Proxy 的 Container，每個 Container 消耗 50MB 就至少要額外 750G 的記憶體，
同時也要注意隨者 Pod/Node 等數量增加，每個 Proxy 可能就需要更多的記憶體來維護這些 Mesh(網格) 之間的資訊，因此使用的 Memory 量只會愈來愈多。</li></ol><p>所以 Cillium/Isovalent 想要引入基於 eBPF 的架構來打造一個不同架構的 Service Mesh。透過 eBPF 的架構使得整個 Service Mesh 的發生點是發生於 Kernel 階段，而非一個獨立的 Uses Proxy。
這邊帶來的改變有</p><ol><li>基於 eBPF 的特性，其本身就有辦法針對系統上所有 Socket 去執行特定的函式，所以 Cillium 就可以偷偷去修改應用程式的網路流量，不論是修改封包內容，偵錯與監控等都可以達到</li><li>不需要如同之前一樣每個 Pod 都部署一個獨立的應用程式，取而代之的是撰寫通用的 eBPF 程式來提供各種功能</li><li>由於所有的事情都發生於 Kernel，甚至可以達到基於 Socket-level 的封包處理，所以封包不需要繞來繞去，整個處理的路徑非常的短，因此產生的 Latency 非常的小</li></ol><p>非常對於這系列戰爭有興趣的人花點時間去把 eBPF 的概念補齊，接下來針對這系列的大戰與討論就能夠有更多的背景去理解</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="eBPF" term="eBPF"/>
        <category label="ServiceMesh" term="ServiceMesh"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「提升 DevOps 技術的免費書籍」]]></title>
        <id>https://hwchiu.com/2022/05/09/reading-notes-49</id>
        <link href="https://hwchiu.com/2022/05/09/reading-notes-49"/>
        <updated>2022-05-09T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「提升 DevOps 技術的免費書籍」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「提升 DevOps 技術的免費書籍」
類別: others
連結: <a href="https://vladimir-mukhin.medium.com/free-books-that-will-boost-your-devops-game-to-the-next-level-5940482b0f96" target="_blank" rel="noopener noreferrer">https://vladimir-mukhin.medium.com/free-books-that-will-boost-your-devops-game-to-the-next-level-5940482b0f96</a></p><p>本篇文章的重點很簡單</p><ol><li>閱讀書籍提升對於 DevOps 領域的掌握度</li><li>所有書籍都是免費</li></ol><p>這邊節錄文章中列出的所有書籍</p><ol><li><p>Kubernetes Up &amp; Running — Dive into the Future of Infrastructure
Kubernetes 從 2014 發行以來的八個年頭席捲全世界，作為一個 DevOps 不論你當下的環境適不適合使用 Kubernetes，你都必須要瞭解到底這個容器管理平台的魅力是什麼
為什麼可以打趴眾多競爭者成為所有容器管理平台的主要首選。
本書從開發者(Dev)以及維運者(Ops)的角度來看到底 Kubernetes 是如何提升整體工作的效率，速度與整體的靈活度</p></li><li><p>Designing Distributed Systems — Patterns and Paradigms for Scalable, Reliable Services
這本由 Brendan Burns 所攥寫的書籍探討了分散式系統架構上幾個常見的設計模式，事實上這些設計模式有些都可以於 Kubernetes 的設計與用法中反覆發現
所以花點時間去研究一下大師所分享的分散式系統模式的設計理念，對於未來去學習理解新系統，或是設計一套系統都會有所幫助</p></li><li><p>97 Things Every Cloud Engineer Should Know — Collective Wisdom from the Experts
這本有紅帽所發行的免費書籍，書中收集了眾多資深雲端工程師的經驗，列舉了 97 個每個雲端工程師都應該要知道的事情，這 97 項包含很多東西，譬如
資料，自動化，網路，公司文化，個人發展，軟體開發以及雲端預算評估等眾多常見議題</p></li><li><p>Linux — Notes for Professionals</p></li><li><p>Production Kubernetes — Building Successful Application Platforms</p></li><li><p>Git — Notes for Professionals</p></li><li><p>Automate The Boring Stuff with Python — Practical Programming For Total Beginners</p></li></ol><p>剩下的書本也都非常有趣，大家有需要時可以閱讀下列書籍</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="DevOps" term="DevOps"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「新手閱讀，我踩過的 Terraform 各種雷」]]></title>
        <id>https://hwchiu.com/2022/05/06/reading-notes-48</id>
        <link href="https://hwchiu.com/2022/05/06/reading-notes-48"/>
        <updated>2022-05-06T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「新手閱讀，我踩過的 Terraform 各種雷」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「新手閱讀，我踩過的 Terraform 各種雷」
類別: terraform
連結: <a href="https://medium.com/contino-engineering/10-things-i-wish-i-knew-before-learning-terraform-f13637a01aa6" target="_blank" rel="noopener noreferrer">https://medium.com/contino-engineering/10-things-i-wish-i-knew-before-learning-terraform-f13637a01aa6</a></p><p>本篇文章作者分享自己學習與使用 Terraform 多年來遇過的各種雷，也希望藉由這類型的文章可以讓每個踏入 Terraform 的人都不要走冤枉路</p><ol><li><p>Make sure you have a terraform block in your configuration
TF 檔案中可以透過 Terraform 區塊來描述關於 Terraform 本身的一些限制，譬如版本條件，相關的 provider 來源以及版本。
這個區塊非常重要但是本身是一個 optional 選項，所以不寫其實不影響整體功能，但是沒有去限制使用的版本範圍其實就跟任何的軟體環境一樣非常危險，
很容易踩到「昨天還可以，今天就不行的」通靈現象，所以作者希望每個人都好好的將 Terraform 區塊描述清楚，確定當前支援的版本是哪個確保該 TF 能夠用正確的版本於任何環境執行</p></li><li><p>Statefile 實際上本身是純文字格式，作者想要提醒的是 State 檔案作為 Terraform 同步上最重要的檔案，其本身是一個純文字明碼的格式，這意味你運行過程中的任何帳號密碼其實都是純文字的格式存放於該檔案中。
所以 State 檔案的保存非常重要，需要用很嚴肅的資安態度來保護這個檔案，否則該檔案被人取得則你 TF 中的各種資訊都會被對方取得。
作者直接於文章中展示一個範例，該範例會創建一個 AWS aws_secretsmanager_secret_version，而該物件的 secret_id, secret_string 都會以明碼的方式被存放於 State 檔案中。</p></li><li><p>Have verbose variables and outputs blocks
TF 中的所有變數都可以用非常簡易的方式去宣告，但是如果妥善地利用這些內建的功能將可以使得變數的使用變得更加方便，特別是當該變數要跨 Module 使用時，呼叫者可以透過更輕易的方式
去理解該變數的格式與用法。
其中最為重要的則是 validation 的內容，作者以 AWS image_id 為範例，該變數基本上就是一個字串，所以使用者可以傳遞任何變數到該欄位去使用，但是如果搭配 validation，就可以讓 TF Apply 提早
先觀察到這些變數是否合法，能夠降低與避免不必要的失敗。
所以針對每個變數都好好的撰寫相關敘述與驗證，能夠讓團隊使用上減少無謂的猜想與溝通。</p></li><li><p>Integrate your environment with a pipeline early
Terraform 的入門非常容易，但是當你想要將 Terraform 導入到團隊中並且與其他人共同合作時，整個使用上的複雜度會大幅度增加。
作者認為如果真的要導入 Terraform 到整個團隊中，則要盡快且盡可能地將 Terraform 導入到現有的 pipeline 架構中，譬如 Terraform Cloud 服務
能夠幫你妥善的管理這些 Lock/State 並且透過 Terraform Apply 來執行變化。</p></li></ol><p>作者還有第二篇探討剩下的用法，包含
Keep your code together as much as possible
Have clear lines of demarcation on responsibility
Use multiple environment files for the same code
Familiarise yourself with HCL’s functions and meta-arguments
Terraform is not a golden bullet</p><p>有興趣的讀者建議兩篇文章都閱讀一下</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Terraform" term="Terraform"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「容器的除錯之路，遇到 Permission Denied 該怎麼辦」]]></title>
        <id>https://hwchiu.com/2022/05/04/reading-notes-47</id>
        <link href="https://hwchiu.com/2022/05/04/reading-notes-47"/>
        <updated>2022-05-04T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「容器的除錯之路，遇到 Permission Denied 該怎麼辦」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「容器的除錯之路，遇到 Permission Denied 該怎麼辦」
類別: container
連結: <a href="https://live-rhes.pantheonsite.io/sysadmin/container-permission-denied-errors" target="_blank" rel="noopener noreferrer">https://live-rhes.pantheonsite.io/sysadmin/container-permission-denied-errors</a></p><p>作者提到大部分遇到 Container 權限問題時，最無腦的一招就是 --privileged 直接硬上權限，但是其實大家都不知道自己到底缺少什麼權限，盲目地使用 --privileged 的確可以解決問題
但是實務上卻是犧牲 Security 換來的，因為不知道缺少什麼而直接硬開，其實就是硬生生的將幾乎所有保護功能都關閉。</p><p>本篇文章就來探討當遇到權限問題時有可能是什麼造成的，以及應該如何精準地去設定這些權限而不是用一招 --privileged 跳過。
此外由於作者本身就是 Podman 開發團隊，因此文章之後的介紹與範例都會基於 Podman 來完成，</p><ol><li>錯誤定位</li></ol><p>如果你的容器問題透過 --privileged 也不能解決，那至少你的問題跟本篇文章的關聯性不大，或是說你的問題其實根本不是安全性方面的設定問題，只有當妳確認你的問題
可以因為 --privileged 而解決時本篇文章的內容才會對你有幫助</p><ol><li>Is SELinux the issue?</li><li>Is AppArmor the issue?</li><li>Test capabilities</li><li>Test SECCOMP</li><li>Test masked kernel filesystem</li></ol><p>除了上述五個安全性設定外，作者也針對 namespace 探討可能會出現的問題，包含</p><ol><li>Is user namespace the issue?</li><li>Is network namespace the issue?</li><li>Is pid namespace the issue?</li></ol><p>最後就是不免俗的推薦大家使用看看 rootless container，畢竟大部分的應用程式其實都沒有要寫入系統的需求，理論上來說應該都要可以運行於 rootless 的模式</p><p>整篇文章整理的非常的好，每個類別都有指令操作來介紹概念，對於這些資安控管不熟的人來說可以說是一個溫習的好機會</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Container" term="Container"/>
        <category label="Debug" term="Debug"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「成為軟體架構師的閱讀之路」]]></title>
        <id>https://hwchiu.com/2022/05/02/reading-notes-46</id>
        <link href="https://hwchiu.com/2022/05/02/reading-notes-46"/>
        <updated>2022-05-02T00:05:09.000Z</updated>
        <summary type="html"><![CDATA[「成為軟體架構師的閱讀之路」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「成為軟體架構師的閱讀之路」
類別: others
連結: <a href="https://haitham-raik.medium.com/books-for-great-software-architect-34c81fc70e12" target="_blank" rel="noopener noreferrer">https://haitham-raik.medium.com/books-for-great-software-architect-34c81fc70e12</a></p><p>作者認為網路上有很多文章分享想要成為一個軟體架構師應該要閱讀哪些書籍來補充知識，但是這些文章都沒有提供一個好的閱讀路徑，沒有告訴你說
這些書有什麼樣的前置條件，這群書有什麼樣的閱讀順序等，這很容易造成讀者沒有系統的四處閱讀，容易導致無聊與沮喪。</p><p>作者根據自己的經驗整理特這些書籍，並且從中找到一個閱讀順序，透過這些閱讀順序可以讓你掌握每本書籍的前置知識同時也能夠有更好的知識去思考書本所談論的內容。</p><p>作者認為軟體架構實際上還可以根據領域進行二次細分，包含</p><ol><li>應用架構</li><li>整合架構</li><li>資料架構</li></ol><p>不同專項其內榮與知識都不同，因此閱讀時的路徑也會不同。所以本篇文章實際是個系列文，總共會有四篇
本篇是一個探討大綱的文章，探討一下基本概念，而後續系列文則是會針對上述三個不同面向去深度探討該怎麼閱讀</p><p>要認真踏入軟體架構前，必須要先掌握基本概念，如相關技術與工具，而作者認為學習這些基本概念的路徑就是所謂的 Design Path.
Design Path 中將會學習到</p><ol><li>Domain-Driver Design(DDD)</li><li>Object-Oriented Design Patterns</li><li>Basic agile Development conecpts</li><li>Modeling using UML</li><li>Respoinsiblity-driven design(RDD)</li><li>..等</li></ol><p>針對這 Design Path，作者推薦依照順序閱讀下列書籍</p><ol><li>Applying UML and Patterns, by Larman</li><li>Head First Design Patterns, by Freeman</li><li>bject Design: Roles, Responsibilities and Collaboration, by Ivar</li><li>Domain-Driven Design Tackling Complexity in the Heart of Software, by Eric</li></ol><p>掌握好 Design Path 後，下一個就是 Architecture Fundamentals 的技術掌握，該過程要學習關於架構的基本概念，原則，模式與實踐方式，閱讀書籍如下</p><ol><li>Fundamentals of Software Architecture, by Mark Richards</li><li>Clean Architecture, by Robert Martin</li><li>Documenting Software Architecture, by Paul Clements</li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「使用 serverless 5年後的心酸經驗談」]]></title>
        <id>https://hwchiu.com/2022/04/29/reading-notes-45</id>
        <link href="https://hwchiu.com/2022/04/29/reading-notes-45"/>
        <updated>2022-04-29T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「使用 serverless 5年後的心酸經驗談」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「使用 serverless 5年後的心酸經驗談」
類別: usecases
連結: <a href="https://dev.to/brentmitchell/after-5-years-im-out-of-the-serverless-compute-cult-3f6d" target="_blank" rel="noopener noreferrer">https://dev.to/brentmitchell/after-5-years-im-out-of-the-serverless-compute-cult-3f6d</a></p><p>本文作者想要分享自己過去五年來使用 Serveless 的經驗談，從不同角度切入導入 Serveless 後的痛點。
作者的 serverless 環境是基於 AWS 環境，使用了包含</p><ol><li>API GAteway</li><li>Cognito</li><li>Lambda</li><li>DynamoDB</li><li>DAX</li><li>SQS/SNS/EventBridge</li></ol><p>作者提及了幾個痛點，包含</p><ol><li>Testing</li><li>Account Chaos</li><li>Security</li><li>No Fundamental Enforcement</li><li>DNS Migration Failures</li><li>Microservice Hell</li><li>API Respones 回傳不一致</li></ol><p>這篇文章最有趣的點不是文章本身，而是底下的留言討論，雖然有少數留言是支持作者但是大部分的人都是秉持反對的意見來看這篇文章。
我自己的角度是這篇文章提出非常多問題，但是這些問題我看不太出來跟 Serveless 的關係是什麼，更多的是公司的文化，工程品質與開發工具有關
譬如作者說團隊內有很多非資深工程師會因為 serveless 的易用而依賴自己的想法去攥寫，譬如光 Auth 就有十種不同方式。
但是仔細思考這個問題，似乎 server-based 的架構也會有這問題，完全是公司的文化與規範問題。
其他問題還有很多寫 serveless 的人都沒有 HTTP 的深厚底子，所以 200,400,500 想回就回，然後回傳格式也都沒有統一固定
這些東西其實跟 serverless 也沒有直接關係，更多依然是 Code Review 的問題，工程師品質的問題。</p><p>所以有時候看文章除了單純閱讀外，也要思考一下作者講的東西自己是否認同，同時也可以看下留言處，來自不同文化與團隊的留言往往能夠帶來更大的啟發，也是閱讀網路文章上我覺得非常有價值的地方</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Serverless" term="Serverless"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「istio 下因為YAML 與 Go template 結合產生的 CVE」]]></title>
        <id>https://hwchiu.com/2022/04/27/reading-notes-44</id>
        <link href="https://hwchiu.com/2022/04/27/reading-notes-44"/>
        <updated>2022-04-27T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「istio 下因為YAML 與 Go template 結合產生的 CVE」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「istio 下因為YAML 與 Go template 結合產生的 CVE」
類別: others<br>
<!-- -->連結: <a href="https://paper.seebug.org/1882/" target="_blank" rel="noopener noreferrer">https://paper.seebug.org/1882/</a></p><p>熟悉 Kubernetes 的使用者一定對於各式各樣的資源格式感到不陌生，譬如描寫一個 Pod 需要準備些關於 containers 的基本資料，其餘還有 Label, Annotation 等
各種資料需要填寫。</p><p>Kubernetes 內透過 apimachinery 的方式來驗證每個欄位是不是合法，譬如最常見的就是創建資源名稱時有時候會因為<em>等出現格式不符合，準確來說是 Pod 的方式來驗證每個欄位是不是合法，譬如最常見的就是創建資源名稱時有時候會因為</em>等出現格式不符合，準確來說是
透過 DNS RFC 1123 來驗證 Pod 是否合法。
部分的數值資料可能會於 Controller 中額外去檢查，至於自定義的 CRD(Customer Resource Definition) 則是創建時可以透過 openAPIV3Schema 去定義每個欄位的合法數值。</p><p>今天這篇文章要介紹的問題是跟 istio 環境的問題，當使用者創建一個名為 Gateway 的資源到叢集中時， istio 會去讀取該 Gateway 資料並且轉換為 Service/Deployment 兩個底層資源。
作者仔細研究發現創建 Service 時會從 Gateway 中的 Annotation 找到名為 "networking.istio.io/service-type" 的資料，並用其作為 Serivce 的 type.</p><p>然而 Annotation 的數值沒有並沒有任何檢查機制，所以使用者可以於該欄位 "networking.istio.io/service-type" 填入各種數值，因此作者就嘗試撰寫一個非常長的 Annotation，譬如</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  annotations:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    networking.istio.io/service-type: |-</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      "LoadBalancer"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      apiVersion: apps/v1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      kind: Deployment</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      metadata:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name: pwned-deployment</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        namespace: istio-ingress</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      spec:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        selector:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          matchLabels:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            app: nginx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        replicas: 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        template:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          metadata:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            labels:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              app: nginx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          spec:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            containers:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            - name: nginx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              image: nginx:1.14.3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              ports:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              - containerPort: 80</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              securityContext:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                privileged: true</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>結果非常順利的， isio 最終創造了一個作者故意描述的 deployment，而該 deployment 還特別的設定 privileged: true 的選項並且透過這次的測試證明該 YAML 的檢查問題導致使用者有機會插入任何想要的資源到環境中
對本文有興趣的可以觀看一下</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="ServiceMesh" term="ServiceMesh"/>
        <category label="Security" term="Security"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「三座獨立 k8s cluster 還是一個跨三個地區的 k8s cluster ?」]]></title>
        <id>https://hwchiu.com/2022/04/25/reading-notes-43</id>
        <link href="https://hwchiu.com/2022/04/25/reading-notes-43"/>
        <updated>2022-04-25T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「三座獨立 k8s cluster 還是一個跨三個地區的 k8s cluster ?」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「三座獨立 k8s cluster 還是一個跨三個地區的 k8s cluster ?」
類別: kubernetes
連結: <a href="https://itnext.io/3-reasons-to-choose-a-wide-cluster-over-multi-cluster-with-kubernetes-c923fecf4644" target="_blank" rel="noopener noreferrer">https://itnext.io/3-reasons-to-choose-a-wide-cluster-over-multi-cluster-with-kubernetes-c923fecf4644</a></p><p>講到多套 kubernetes 的情況下，目前大部分的文章都會推薦用三套獨立的 kubernetes 叢集而非架設一套同時管理三個地點的 kubernetes 叢集。
本篇文章作者從不同的面向分享為什麼要選擇一個 kubernetes 管全部，而不是要架設三套 kubernetes 叢集。</p><h1>Latency</h1><p>一套 kubernetes 最令人詬病且很難處理的就是 Latency 的問題，作者提到 Latency 的問題會影響 ETCD
ETCD 被影響後會影響整個叢集的運作，甚至連應用程式相關的處理都會變慢。</p><p>作者提到其實這個問題能夠採取兩個步驟來解決</p><ol><li>重新安排 etcd 的節點位置，或是使用 non-etcd 的解決方案</li><li>透過 node labels 讓要使用 etcd 的服務跟 etcd 盡量靠近</li></ol><p>註: 我是覺得這說法不能解決問題，一般應用程式要是被分散到不同地區你的存取還是有機會跨地區，除非要很認真地針對不同地區去設計 label，讓應用程式的部屬都只會固定同個地區，但是要這樣搞跟我直接搞三套不覺得後者會比較累。</p><h1>Security</h1><p>作者一直強調使用 mesh VPN 來打通底層所有網路封包處理，讓你一個大 k8s 管理多個地區，就不用擔心底層網路問題</p><p>單套 k8s 的好處有什麼？作者認為有</p><h1>No Complicated tooling</h1><p>作者提到 2021 年的 KubeConf 有各種管理多套 k8s 叢集的工具，如 KubeEdge, OpenShift Edge, Akri, Baetyl,
Kubermatic, Rancher, KubeFed... 等，如果用一套大 k8s 就可以不使用這些工具，直接減少與這類型複雜工具的依賴性
一套 k8s 叢集可以讓你使用最簡單也是最習慣的方式來管理所有環境</p><h1>No extra overhead</h1><p>每套 K8s 環境中都會有如監控，日誌， registry 等各種工具，多套 k8s 的架構就是每個叢集都要安裝一份，但是如果採用一個大 k8s 的架構就只要維護一份即可
所以可以減少很多不必要的重複安裝。</p><h1>Ultimate Flexibility</h1><p>這段其實不很理解，為什麼作者這麼想要推廣 mesh VPN ... </p><p>註: 這篇文章底下有留言說探討到說 RBAC 等相關權限問題是個很大的問題，你一套 k8s 很難處理這些，事情沒有想像的這麼簡單</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「DevOps 的 2022 學習之路」]]></title>
        <id>https://hwchiu.com/2022/04/20/reading-notes-41</id>
        <link href="https://hwchiu.com/2022/04/20/reading-notes-41"/>
        <updated>2022-04-20T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「DevOps 的 2022 學習之路」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「新一代 Helm Chart 的管理套件 helmwave」
類別: tools
連結: <a href="https://medium.com/wriketechclub/new-wave-for-helm-b9800733587f" target="_blank" rel="noopener noreferrer">https://medium.com/wriketechclub/new-wave-for-helm-b9800733587f</a></p><p>Helm 作為現在包裝與安裝 Kubernetes 應用服務的主流方式，單單使用 Helm 很多時候不能滿足部署需求，譬如公司的業務是由多套 Helm Chart 同時組成的，這時候可能會有幾種做法</p><ol><li>使用 Helm Dependency 的方式來產生一個 Umbrella charts 讓你可以安裝一個 Helm 實際上會把相關的服務一起搞定</li><li>透過 Helmfile 等相關工具以更上層的概念來管理你的應用，用多套 Helm Chart 來管理與部屬你的應用程式</li></ol><p>而作者長期使用 Helmfile 來管理各種 Helm 的安裝方式，而今天作者終於發現一個相對於 Helmfile 來說更容易使用，而且整體使用方式更為簡潔的解決方案，helmwave.</p><p>Helmwave 的官方介紹很簡單， Helmwave is like docker-compoose for helm.</p><p>其本身的實作更為簡潔，直接使用 Helm Library 於整個實作中，所以下載單獨的 binary 即可，不需要如同 helmfile 一樣還要於系統中先安裝 helm 等相關工具。
文章中透過範例來示範如何滿足</p><ol><li>服務需要安裝多套 Helm chart</li><li>有兩個不同環境， prod 與 stage 有不同的 values 要使用</li></ol><p>整個使用的方式跟 docker-compose 有點類似，可以透過 helmwave up, helmwave down 的概念來啟動與停止服務，只不過所有的服務都是基於 k8s + helm-charts 來完成。</p><p>有使用 helmfile 的人可能會對這類型的工具比較有感覺，也許可以看看其差異性是否真的有如作者所提這麼好</p><hr><p>標題: 「DevOps 的 2022 學習之路」
類別: others<br>
<!-- -->連結: <a href="https://medium.com/faun/devops-roadmap-2022-340934d360f9" target="_blank" rel="noopener noreferrer">https://medium.com/faun/devops-roadmap-2022-340934d360f9</a></p><p>本篇文章是作者根據自己的觀察與經驗，列出 2022 需要繼續學習與觀察的 13 項技能與概念，希望讓每個 DevOps(SRE) 相關領域的人有一個方向去精進自己。</p><ol><li><p>Network Technologies
網路的概念短時間內很難被顛覆，所以掌握基本的 L4/L7, HTTP2/, HTTP3/(QUIC), DNS, BGP, Load-Balancing 等基本網路概念絕對不吃虧，作為一個熟悉架構的專家，能夠描述環境中的封包流向是不可缺少的能力。</p></li><li><p>OS, particularly Linux
Linux 很重要，請學習系統上的各種基本概念， CPU/Memory 基本概念, Init, cgroup 等</p></li><li><p>CI/CD
Jenkins 作為老牌的解決方案，能夠使用其實也很好，不過要注意的是現在有愈來愈多的環境嘗試使用其他的 pipeline 來搭建，所以有時間的話也可以學習一下其他的解決方式，讓自己能夠有能力去面對各種需求</p></li><li><p>Containerlization/Virtualization
除了最知名的 Docker 環境外，也嘗試看看 containerd, podman 等不同專案，同時也考慮如何將 container security 的概念給導入到日常生活中</p></li><li><p>Container Orchestration
K8s 幾乎變成容器管理維運的 de facto 標準，單純的 k8s 叢集還不足以面對所有正式環境的問題，所以還需要搭配各個面向的概念將其整合才可以打造出一個適合團隊的 k8s 叢集。</p></li><li><p>Observability at Scale
除了最基本常見的 Prometheus 之外，也看一下其他基於 Prometheus 所打造更適合大規模的架構，如 Thanos, Cortex, VictoriaMetrics 等
此外可以試試看 Continuous Profiling 等持續觀察系統效能的工具，如 Parca, Pyroscope, hypertrace 以及順便試試看導入 Open Telemetry。</p></li><li><p>Platform team as a Product team
稍微有規模的團隊可能會慢慢的感覺到 Platform 逐漸轉型成為一個 Product 的概念，只不過該 Product 的面向對象是內部開發與測試人員而並非外部使用者。
整體目標就是打造一個更好的協同平臺，讓開發與測試人員能夠更有效地去滿足日常工作需求，同時 Platform team 除了維護產品之外也要教授使用人員讓他們有能力去使用該平台來滿足需求
而不是所有問題都要一直讓 Platform 的人來幫忙處理，這種模式小團隊可行，但是當團隊過大時就沒有辦法處理。</p></li><li><p>Security</p></li><li><p>Programming</p></li><li><p>Infrastructure as Code</p></li><li><p>Cloud</p></li><li><p>Technical Writing</p></li><li><p>Site Reliability Engineering</p></li></ol><p>剩下的內容就留給有興趣的人自行到文章去觀看，每個類別都有舉出幾個趨勢與值得關注的專案，其中特別注意的是 Technical Writing 這項技能非常重要
遠端工作的趨勢使得透過文字交流的機會比過往多很多，所以如何寫出一個有效不會浪費彼此時間的設計文件，架構，開發文件等則是一個很重要的技能，所以即使是個開發人員也要努力練習
將腦中的想法有系統地呈現出來</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="DevOps" term="DevOps"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「強化 Kubernetes 叢集的必備工具」]]></title>
        <id>https://hwchiu.com/2022/04/18/reading-notes-40</id>
        <link href="https://hwchiu.com/2022/04/18/reading-notes-40"/>
        <updated>2022-04-18T00:05:09.000Z</updated>
        <summary type="html"><![CDATA[「強化 Kubernetes 叢集的必備工具」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「強化 Kubernetes 叢集的必備工具」
類別: kubernetes
連結: <a href="https://medium.com/mycloudseries/must-haves-for-your-kubernetes-cluster-to-be-production-ready-dc7d1d18c4a2" target="_blank" rel="noopener noreferrer">https://medium.com/mycloudseries/must-haves-for-your-kubernetes-cluster-to-be-production-ready-dc7d1d18c4a2</a></p><p>作者本篇文章想要分享一個其用來讓一個 Kubernetes 變得能夠真正上戰場的相關工具，因此文章中特別強調是 Production-Ready 的情況。
一個 Production Ready 的 K8s 叢集必須對於下列每個大項目都要有相關處理方式，譬如</p><ol><li>Reliability and Availability</li><li>Security</li><li>Network, Monitoring &amp; Observability</li><li>Backup/Recovery</li><li>Cost Optimization</li><li>Cluster Visualization</li></ol><p>Reliability and Availability:
該領域的兩個指標代表的意義不太一樣，但是對於一個提供服務的叢集來說都一樣重要</p><p>這邊作者列舉了幾個工具譬如</p><ol><li>K8s 內建的 HPA</li><li>AWS 的 karpenter，讓你針對基於節點為單位來擴充</li><li>Cluster-Autoscaler</li><li>Goldilocks</li></ol><p>Backup/Recovery
有不少人團隊都對於對於叢集的備份與還原感到頭痛，目前最知名的開源專案莫過於 Velero，其支援不同的儲存設備如 Cloud Storage 等來存放，讓不同環境的 k8s 使用者都有辦法去備份其叢集內的資料</p><p>Cost Optimization</p><p>對於雲端架構來說，基本上雲端業者的內建功能已經可以針對如 VM, 底層架構等各種服務去列舉出各自的花費金錢，將此概念套入到 Kubernetes 本身大抵上只能理解到 Master Node, Worker Node 等之類的花費，
因此透過 Kubecost 之類的專案來將成本的洞察範圍擴充到 Kubernetes 內部，以 namespace, pod 等各種 k8s 的資源為單位來列舉實際花費的金額，能夠讓團隊更有效地去管理相關花費</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「你真的有正確使用 SSH 嗎?」]]></title>
        <id>https://hwchiu.com/2022/04/15/reading-notes-39</id>
        <link href="https://hwchiu.com/2022/04/15/reading-notes-39"/>
        <updated>2022-04-15T00:05:09.000Z</updated>
        <summary type="html"><![CDATA[「你真的有正確使用 SSH 嗎?」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「你真的有正確使用 SSH 嗎?」
類別: tools
連結: <a href="https://smallstep.com/blog/use-ssh-certificates/" target="_blank" rel="noopener noreferrer">https://smallstep.com/blog/use-ssh-certificates/</a></p><p>SSH 基本上是每個系統管理員都熟悉不過的工具，而本文的作者指出 SSH 使用上有一些小缺陷，譬如</p><ol><li>使用者體驗很差，每一個新使用 SSH 的人如果不熟悉其概念，每次連線到新機器都會看到一次 Yes/No 的選擇，就因為不熟大部分的人都會直接選擇 Yes 來通過，
背後實際發生什麼事情都不清楚，只知道會動就好</li><li>大規模的管理 SSH 非常麻煩且花費時間，Hostname 如果前後有出現重複的還會出現問題，需要重新處理 known_hosts 等相關資料</li><li>透過 Key 的管理聽起來很安全，但是其架構使得使用者通常不太會換 key，會一直重富使用固定的那把 Key 來避免重新處理一切問題</li></ol><p>舉了一些問題後，作者點出能夠真正駕馭 SSH 的應該是採取 SSH Certificate 而非使用 SSH Public Key 來進行身份驗證。
作者團隊開發了些許工具來幫助其他人能夠更輕鬆的使用 SSH Certificate 但是卻發現這類型的工具卻沒有受到歡迎與採用，因此也針對這個現象
進行問卷調查，想瞭解這類型的工具為什麼不受青睞，原因包含</p><ol><li>根本沒聽過 SSH Certificate</li><li>Certificate 以及 PKI 架構對人們來說不容易理解，很難理解其好處</li><li>轉換中間有一些陣痛期，所以與其花時間去學習這些不如就繼續使用本來的 Public Key 機制</li></ol><p>文章後半開始介紹 SSH Public Key 與 SSH Certificate 的差異
Public Key 的概念非常簡單，就是透過一組 Private/Public Key 並且將 Public Key 給寫入到目標節點帳戶上的 ~/.ssh/authorrized_keys.
節點數量爆炸多的情況下要如何有效率的去管理這些檔案則是一個非常麻煩但是又不能不處理的事情，這也是作者為什麼要推廣 SSH Certificate 的原因之一</p><p>SSH Certificate 的方式移除了關於 SSH Public Key 不停重複上傳與設定的情境，相反的則是將自身的 Public Key 給綁到 Certificate 內，同時也包含如過期時間，名稱等其他資料。
目標 Certificate 本身會由一個 CA 簽署，而每台 Server 都需要去修改 /etc/ssh/sshd_config 來指定相關的 CA Key 讓該 SSH 能夠信任。
文章後半部分介紹更多關於 SSH Certificate 的好處以及用法</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「透過 Kubernetes Event-Driver Autoscaler(KEDA) 來根據各種指標動態擴充容器」]]></title>
        <id>https://hwchiu.com/2022/04/13/reading-notes-38</id>
        <link href="https://hwchiu.com/2022/04/13/reading-notes-38"/>
        <updated>2022-04-13T00:05:09.000Z</updated>
        <summary type="html"><![CDATA[「透過 Kubernetes Event-Driver Autoscaler(KEDA) 來根據各種指標動態擴充容器」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「透過 Kubernetes Event-Driver Autoscaler(KEDA) 來根據各種指標動態擴充容器」
類別: kubernetes
連結: <a href="https://medium.com/@casperrubaek/why-keda-is-a-game-changer-for-scaling-in-kubernetes-4ebf34cb4b61" target="_blank" rel="noopener noreferrer">https://medium.com/@casperrubaek/why-keda-is-a-game-changer-for-scaling-in-kubernetes-4ebf34cb4b61</a></p><p>Kubernetes 內已經有 HPA 的物件可以讓 K8s 根據一些基本的指標來動態調整 Pod 的數量，而 KEDA 這款 CNCF 的孵化專案則是完全強化 HPA 的效果
KEDA 的概念很簡單，就是應用程式應該要可以有更多的指標來幫忙動態擴充，除了最基本的 CPU/Memory 等基本指標外， KEDA 來支援了下列各種不同指標，讓 k8s 可以使用更為廣泛的指標，譬如</p><ol><li>Redis 內某個 Queue 的長度</li><li>K8s 內其他 Pod 的數量</li><li>PostgreSQL Query 的結果</li><li>Elasticsearch Query 的結果</li><li>各種雲端服務，如 Azure Event Hubs, AWS CloudWatch, GCP Pub/Sub</li><li>Kafka
... 等各種不同指標</li></ol><p>使用方式很單純，一切的規則都是基於 K8s 的 CRD 來描述與管理，因此團隊可以使用 YAML 的方式來定義這些擴充的規則
文章中有基於 CPU/Memory 的基本介紹使用，同時文章中也有官方的連結來介紹各種不同指標的示範用法</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「升級 Kubernetes 1.22 的注意事項」]]></title>
        <id>https://hwchiu.com/2022/04/11/reading-notes-37</id>
        <link href="https://hwchiu.com/2022/04/11/reading-notes-37"/>
        <updated>2022-04-11T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「升級 Kubernetes 1.22 的注意事項」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「升級 Kubernetes 1.22 的注意事項」
類別: kubernetes
連結: <a href="https://blog.runx.dev/will-that-kubernetes-v1-22-upgrade-break-my-application-cc339dc2e2c7" target="_blank" rel="noopener noreferrer">https://blog.runx.dev/will-that-kubernetes-v1-22-upgrade-break-my-application-cc339dc2e2c7</a></p><p>隨者各大公有雲逐步支援 Kubernetes 1.22，相關使用者可能都會開始進入升級的準備階段，而每次 Kubernetes 升級除了單純
思考 Kubernetes 本身的升級順利與否外，也要確認正在運行的所有 Kubernetes 資源與相關工具是否也能夠順利運行，這使得整個準備工作變得複雜與龐大。</p><p>從 Kubernetes 的角度來看，每次的升級除了基本的穩定性與相關功能修正外，最重要的還有 Kubernetes API 的改變，該改變影響巨大，譬如所有 Manifest 的內容，譬如眾多透過 YAML 所描述的各種資源
API 的改變都會提早通知所有社群，於先前的版本先將該 API 標為 deprecated 接者後續版本才會正式移除，譬如 networking.k8s.io/v1beta1 於 1.19 被標示為 deprecated 然後正式於 1.22 移除。
正式的版本 networking.k8s.io/v1 則從 1.19 正式啟用，讓管理者有大概有三個版本的時間轉移。</p><p>因此升級前一定要先架設一個測試環境，嘗試部署所有現存的資源來確保升級不會出現不預期的錯誤。</p><p>作者整理出關於 1.22 升級要注意的版本變化，如下(幾乎都是從 v1beta 變成 v1)</p><ol><li>Webhook: admissionregistration.k8s.io/v1beta1 → admissionregistration.k8s.io/v1</li><li>CRD: apiextensions.k8s.io/v1beta1 → apiextensions.k8s.io/v1</li><li>APIService: apiregistration.k8s.io/v1beta1 → apiregistration.k8s.io/v1</li><li>TokenReview: authentication.k8s.io/v1beta1 → authentication.k8s.io/v1</li><li>SubjectAccessReview: authorization.k8s.io/v1beta1 → authorization.k8s.io/v1</li><li>CertificateSigningRequest: certificates.k8s.io/v1beta1 → certificates.k8s.io/v1</li><li>Lease: coordination.k8s.io/v1beta1 → coordination.k8s.io/v1</li><li>Ingress: extensions/v1beta1, networking.k8s.io/v1beta1 → networking.k8s.io/v1</li><li>IngressClass: networking.k8s.io/v1beta1 → networking.k8s.io/v1</li><li>RBAC resources: rbac.authorization.k8s.io/v1beta1 → rbac.authorization.k8s.io/v1</li><li>PriorityClass: scheduling.k8s.io/v1beta1 → scheduling.k8s.io/v1</li><li>Storage resources: storage.k8s.io/v1beta1 → storage.k8s.io/v1</li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「kubectl delete 的行為跟 docker delete 完全不同」]]></title>
        <id>https://hwchiu.com/2022/04/06/reading-notes-36</id>
        <link href="https://hwchiu.com/2022/04/06/reading-notes-36"/>
        <updated>2022-04-06T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「kubectl delete 的行為跟 docker delete 完全不同」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「kubectl delete 的行為跟 docker delete 完全不同」
類別: kubernetes
連結: <a href="https://www.acritelli.com/blog/kubectl-delete-sigkill/" target="_blank" rel="noopener noreferrer">https://www.acritelli.com/blog/kubectl-delete-sigkill/</a></p><p>熟悉 Linux 系統的人想必都了解 Signal 的概念，特別是幾個常見的如 SIGTERM, SIGKILL 等，</p><p>作者的團隊嘗試透過 SIGKILL 的行為來驗證與測試團隊內部署的 Kubernetes Pod，特別是當遇到 ungraceful shutdown 的情境時這些 Pod 會如何運作。
團隊嘗試透過 kubectl delete 的方式來刪除這些 Pod，但是實驗過程中發現 --grace-period 這個參數的運作行為與團隊的預期行為不同。
kubectl delete 得說明文件中特別指出</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">      --grace-period=-1: Period of time in seconds given to the resource to terminate gracefully.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Ignored if negative. Set to 1 for immediate shutdown. Can only be set to 0 when --force is true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(force deletion).</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>作者看文這段文字說明後滿腦問號，提出兩個問題</p><ol><li>grace-period 設定為 1 的 immediate shutdown 是直接送出 SIGKILL 嗎？ 還是說會有一秒的間隔時間才發送 SIGKILL?</li><li>grace-period 設定為 0 是代表沒有間隔，所以也是馬上送出 SIGKILL 嗎? 還是說其只是單純將資源從 k8s API 中移除而沒有等待而已？</li></ol><p>作者認為文件沒有辦法解決這些問題，所以設計了一些實驗來測試</p><p>--grace-period=1 的實驗結果是</p><ol><li>送出 SIGTERM</li><li>等待一秒</li><li>送出 SIGKILL</li></ol><p>作者對於這個行為感到不解，認為 "immediate shutdown" 應該就是要馬上關閉呀，怎麼可以送 SIGTERM 給 Pod 讓 Pod 有機會可以優雅的結束一切？
因為對於這行為的認知不同導致作者團隊的測試行為沒有辦法順利完成。</p><p>接下來測試 --grace-period=0 &amp; --force=true </p><p>文件中說明這樣設定會立刻將該資源從 API Server 內給刪除並且避開 graceful 的階段。
最後測試的結果是</p><ol><li>發送 SIGTERM</li><li>等待 30 秒</li><li>發送 SIGKILL</li></ol><p>作者表示又糊塗了，沒想到設定 grace-period=0 竟然中間還有 30 秒的時間，這完全與預料的不同，更麻煩的是文件也沒有講得非常清楚到底什麼是正確的行為，
此外還提到 Docker 就支援真正的 immediate shutdown，直接送 SIGKILL。</p><p>另外作者發現 K8s GitHub 中的也有人提出類似的 issue，對於這些 graceful 的行為感到不解同時文件說明不夠精準。</p><p>這件事情很難說誰正確誰不正確，畢竟不同的系統架構下的設計方式與條件都不同，不過的確 K8s 的指令文件有時候是真的不是精準，需要仔細測試才可以理解到底運作行為為何</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubectl" term="Kubectl"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Dockerfile 中透過 COPY --chomd 比透過 RUN chomd 可以省下更多空間」]]></title>
        <id>https://hwchiu.com/2022/04/04/reading-notes-35</id>
        <link href="https://hwchiu.com/2022/04/04/reading-notes-35"/>
        <updated>2022-04-04T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「Dockerfile 中透過 COPY --chomd 比透過 RUN chomd 可以省下更多空間」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「Dockerfile 中透過 COPY --chomd 比透過 RUN chomd 可以省下更多空間」
類別: containers
連結: <a href="https://blog.vamc19.dev/posts/dockerfile-copy-chmod/" target="_blank" rel="noopener noreferrer">https://blog.vamc19.dev/posts/dockerfile-copy-chmod/</a></p><p>本篇文章是作者探討自己建制 Image 中所發現的一些有趣事實。
作者使用一個大概 70MB 的 image，並且安裝與運行大概 90MB 左右的額外空間，結果最後整個 image 高達 267 70MB
因此作者就花了一些時間來研究整體原因並且嘗試理解到底發生什麼事情</p><p>作者首先檢視自己的 Dockerfile，其內容簡單不複雜，包含如
COPY 一個 Binary (該 Binary 80 MB 左右)
RUN xxxxx
等常見用法。</p><p>詳細檢視所有的 layer 資訊後，作者發現 RUN 這個指令竟然產生了 94.4MB 的全新 layer，而就是這個 layer 導致整體空間變成 267 MB.
作者的 RUN 指令執行</p><ol><li>透過 apt-get 安裝四個套件</li><li>透過 chmod 將前述 COPY 來的檔案給予執行的權限</li><li>創建資料夾</li></ol><p>作者檢查過安裝的套件，大概只有 6MB 左右，但是整個 layer 很明確就是多了 94.4 MB 出來，因此經過測試與研究後，作者觀察到
當移除第二步(修給檔案給予執行的權限)後整個空間瞬間變得很小，整體 image 最後的大小就符合預期的 174MB。</p><p>所以整個問題就出來了，為什麼單純執行一個 RUN chmod 就會使得整個 image layer 變大?
簡單來說 image 的底層是基於 OverlayFS，而 OverlayFS 的一大特色就是 CoW, Copy on Write，作者起初覺得
我只是透過 chmod 去修改該 Binary 一個屬性而以，本身並沒有寫入檔案到檔案系統中，怎麼會產生這麼大的檔案變化？</p><p>仔細研究 OverlayFS 的文件後終於水落石出，原來除了寫入檔案外，修改檔案的某些 metadata 也會觸發 CoW 的機制</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">When a file in the lower filesystem is accessed in a way the requires write-access, such as opening for write access, changing some metadata etc., the file is first copied from the lower filesystem to the upper filesystem (copy_up).</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>至於為什麼修改個 metadata 也要觸發 CoW 主要是跟安全性有關，文章中有關於這部分的額外連結，有興趣的可以參考</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Docker" term="Docker"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「軟體工程師你真的工作的很開心嗎??」]]></title>
        <id>https://hwchiu.com/2022/03/30/reading-notes-34</id>
        <link href="https://hwchiu.com/2022/03/30/reading-notes-34"/>
        <updated>2022-03-30T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「軟體工程師你真的工作的很開心嗎??」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「軟體工程師你真的工作的很開心嗎??」
類別: others
連結: <a href="https://stackoverflow.blog/2022/03/17/new-data-what-makes-developers-happy-at-work/" target="_blank" rel="noopener noreferrer">https://stackoverflow.blog/2022/03/17/new-data-what-makes-developers-happy-at-work/</a></p><p>疫情這兩年影響全球，其中對於勞動力來說更有甚巨的變化，而科技業更是其中的佼佼者，是所有行業中離職率最高的行業。
2021 的離職率相對於 2020 來說提升了 4.5%。</p><p>StackOverflow 基於想要理解科技領域的這個趨勢及原因，所以發起了一個調查想研究工程師工作是否開心，並且將
基於 350 位來自全球開發者的回應統整為報告於三月份釋出。</p><p>結果來看</p><ol><li>70.3% 的工程師覺得工作開心</li><li>14.4% 表示不開心</li><li>15.3% 沒感覺</li></ol><p>以最令人感到開心的地區排名來看，前五名分別為</p><ol><li>西班牙 (90%)</li><li>印度 (79%)</li><li>德國 (70%)</li><li>美國 (69%)</li><li>英國 (68%)</li></ol><p>那到底哪些因素會影響開心與否？ 報告中列舉了相關的指標
前五個最令人感到開心的因素有</p><ol><li>薪資(60%感到開心)</li><li>work-life 平衡</li><li>工作彈性</li><li>是否有足夠生產力</li><li>職涯發展機會</li></ol><p>而令人感到不開心的五個最重要指標其實就是上述指標的反轉，依序為</p><ol><li>工作覺得毫無效率與生產力</li><li>工作生活不平衡</li><li>沒有職涯發展與機會</li><li>薪水太低</li><li>工作無彈性</li></ol><p>調查的全部指標除了上述五個之外還有</p><ol><li>工作是否能夠帶來影響力</li><li>是否能夠獨力解決問題</li><li>有一個瞭解我工作的主管
... 等</li></ol><p>其實面試找工作也就是針對這些條件進行排序，與其跟風看大家去什麼公司就想去什麼公司，不如好好跟自己對話，瞭解自己對於工作的目的以及追求是什麼，才有辦法找到一個自己喜歡且舒適的工作環境</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「如何於 Docker 環境中運行 rootless 模式」]]></title>
        <id>https://hwchiu.com/2022/03/28/reading-notes-33</id>
        <link href="https://hwchiu.com/2022/03/28/reading-notes-33"/>
        <updated>2022-03-28T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「如何於 Docker 環境中運行 rootless 模式」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「如何於 Docker 環境中運行 rootless 模式」
類別: container
連結: <a href="https://thenewstack.io/how-to-run-docker-in-rootless-mode/" target="_blank" rel="noopener noreferrer">https://thenewstack.io/how-to-run-docker-in-rootless-mode/</a></p><p>雖然可以使用非 root 的方式去安裝 Docker 服務，但是 Docker 本身服務中還有其他各種元件需要透過 root 身份去運行，譬如 dockerd, containerd, runc 等元件，
而本篇文章則是探討要如何以真正 rootless 的方式來運行一個 docker container 。</p><p>使用 rootless container 有一些要注意的事情，譬如 port number 沒有辦法使用 1024 以下，所以如果你的服務有需要被外界存取時要使用大於 1024 的 port number。
此外 AppArmor, host network mode 這些都不支援，因此使用上會有一些情境要注意。</p><p>安裝其實滿簡單的， Docker 官網有提供 rootless 的安裝檔案，安裝後需要針對一個使用者 ID 進行處理，這個處理主要是因為要將 container 內的 root 使用者給轉換到系統上的非 root 使用者，所以才會有相關的 userID 要設定。
當然如果真的要完全追求 rootless 的容器解決方案可以考慮使用 Podman 來使用，其本身的設定就是針對 rootless 去開發的，使用上會相對於 docker 來說更為簡單。</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Security" term="Security"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「一個用來管理 Kubernetes 開源工具的開源工具」]]></title>
        <id>https://hwchiu.com/2022/03/25/reading-notes-32</id>
        <link href="https://hwchiu.com/2022/03/25/reading-notes-32"/>
        <updated>2022-03-25T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「一個用來管理 Kubernetes 開源工具的開源工具」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「一個用來管理 Kubernetes 開源工具的開源工具」
類別: tools
連結: <a href="https://github.com/alexellis/arkade" target="_blank" rel="noopener noreferrer">https://github.com/alexellis/arkade</a></p><p>作者因應過去於 Kubernetes 的教學與開源過程中，必須要一直不停地去安裝各式各樣必備的工具而感到厭煩，譬如每次都要安裝 kubectl, kind, kubectx 等各種常見工具
而每個工具又會有不同的版本，每次都要專寫相關的安裝流程都很麻煩，因此作者萌生出開發一個能夠安裝這些工具的開源工具, arakde.</p><p>該工具用起來非常簡單，同時也支援不同版本的工具，除了基本 CLI 工具外也支援 Helm App 的安裝，我個人認為光工具本身就非常好用了，譬如可以透過該指令輕鬆的安裝不同版本的下列工具</p><ol><li>dive</li><li>helm</li><li>gh</li><li>jq</li><li>k3d</li><li>kind</li><li>kubectl</li><li>k9s</li><li>kail</li><li>opa</li><li>terraform
...</li></ol><p>如果你常常需要撰寫文件去分享安裝各種文件的需求，也許可以考慮使用看看此工具來簡化流程</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「為什麼 3A 大作的遊戲室都不愛喜歡使用 STL」]]></title>
        <id>https://hwchiu.com/2022/03/23/reading-notes-31</id>
        <link href="https://hwchiu.com/2022/03/23/reading-notes-31"/>
        <updated>2022-03-23T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「為什麼 3A 大作的遊戲室都不愛喜歡使用 STL」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「為什麼 3A 大作的遊戲室都不愛喜歡使用 STL」
類別: usecase
連結: <a href="https://mobile.twitter.com/m_ninepoints/status/1497768472184430600" target="_blank" rel="noopener noreferrer">https://mobile.twitter.com/m_ninepoints/status/1497768472184430600</a></p><p>熟悉 C++ 語言的讀者必定聽過 STL，而本篇推特系列文則是用來解釋為什麼 3A 大作的遊戲室都不愛使用 STL，這邊節錄一些概念與想法</p><ol><li>STL 的實作通常會因為不同平台與編譯器而會有不同變化，但是對於遊戲業者來說很多時候會希望能夠針對所有平台能夠有一個統一一致的實作</li><li>跨平台的統一實作對於開發者來說可以帶來很多好處，譬如除錯可以更有效率，不需要針對每個平台獨立研究問題</li><li>STL 由於不同平台的實作方式都不同，所以發生問題或是要客製化都會變得稍嫌麻煩，變成還要根據平台去研究與處理，整體來說就是煩</li><li>某些情況下 STL 的實作是犧牲效能來完成的，但是效能反而是業者所需要的</li></ol><p>覺得本篇推文非常有興趣，對這系列有興趣的可以看看大家的討論</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Terraform 生態下的五個相關輔助工具」]]></title>
        <id>https://hwchiu.com/2022/03/21/reading-notes-30</id>
        <link href="https://hwchiu.com/2022/03/21/reading-notes-30"/>
        <updated>2022-03-21T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「Terraform 生態下的五個相關輔助工具」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「Terraform 生態下的五個相關輔助工具」
類別: terraform
連結: <a href="https://betterprogramming.pub/5-essential-terraform-tools-to-use-everyday-e910a96e70d9https://medium.com/geekculture/my-jq-cheatsheet-34054df5b650" target="_blank" rel="noopener noreferrer">https://betterprogramming.pub/5-essential-terraform-tools-to-use-everyday-e910a96e70d9https://medium.com/geekculture/my-jq-cheatsheet-34054df5b650</a></p><p>隨者 IaC 的概念落地開花，愈來愈多團隊嘗試使用 Terraform 來管理各式各樣的 infrastructure，作者本篇文章分享五個自己每天使用的 Terraform 輔佐工具，分別是</p><ol><li>TFSwitch</li><li>TFLint</li><li>Terraform-docs</li><li>Checkov</li><li>Infracost</li></ol><p>TFSwitch: 如果環境中目前因為歷史因素沒有辦法統一轉移到相同版本的 Terraform 使得你必須要用不同版本的 Terraform 來處理不同的專案的話，可以透過 TFSwitch 來幫助你快速地切換版本</p><p>TFLint: 就如同大部分的 Lint 工具一樣， TFLint 針對 Terraform 的工具，特別是跟特定 CloudProvider 整時候會有更多的錯誤偵錯，將該工具整合到 CI/CD pipeline 中更可以幫助團隊避免合併一個有問題的 Terraform code.</p><p>Terraform-docs: 這是一套能夠將你的 Terraform module 直接產生對應 Markdown 格式文件的工具，如果本身有撰寫 Terraform Module 的團隊都可以使用這工具試試看，看看產生的文件是否可以滿足基本需求</p><p>Checkov: 這是一套支援 Terraform 的靜態程式碼掃描工具，可以用來檢查是否有可能的安全性漏洞與不良好的設定，目前預設大概有 750+ 以上的預設規則，</p><p>Infracost: 這工具會的目的就如同專案名稱一樣，根據創造的雲端資源幫你估計這些資源的實際花費，對於要控管成本的團隊來說，可以提供一個粗略的金額概念，畢竟如網路流量等相關付費還是要實際上線才知道，但是可以快速地針對不同的 infra 直接列出大概的金額差異，搭配得宜對於整體工作流程還是有幫助的。</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Terraform" term="Terraform"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Facebook 內的文化特別之處」]]></title>
        <id>https://hwchiu.com/2022/03/18/reading-notes-29</id>
        <link href="https://hwchiu.com/2022/03/18/reading-notes-29"/>
        <updated>2022-03-18T00:05:07.000Z</updated>
        <summary type="html"><![CDATA[「Facebook 內的文化特別之處」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「Facebook 內的文化特別之處」
類別: usecase
連結: <a href="https://chinese.catchen.me/2022/02/unique-engineering-culture-of-facebook.html" target="_blank" rel="noopener noreferrer">https://chinese.catchen.me/2022/02/unique-engineering-culture-of-facebook.html</a></p><p>作者作為一個 Meta 工作七年的員工，分享了一些認為 Facebook 頗有特色的文化，這些特色文化並沒有辦法直接斷言是好是壞，一切都是看用什麼角度去看待。</p><h1>工程師對產品結果負責</h1><p>年度績效評估時要如何去評估一個工程師的績效一直都是個不簡單的問題，作者提到對於 Meta 內部的高級工程師(不確定正確級別代號是什麼)來說，其績效並不是單單的只去看技術用的好不好，程式寫的好不好
更多的反而是這個產品是否有真正的商業成長結果。</p><p>作者認為這種鼓勵從下而上解決問題的思路能夠讓產品的發展更佳有效率與有意義，舉例來說
假如今天工程師的績效是完全基於技術方面的呈現，而專案負責人(PM)的績效可能是該專案對於使用者的黏著度，兩者績效不一致的情況下很容易發展出不同的開發與演進策略
工程師為了達到自己的績效其發展的路線就不一定可以為產品帶來更好的使用者黏著度，反之亦然，為產品帶來更好使用者黏著度的改善並不一定可以讓工程師看到很好的表現績效。</p><p>但是一旦當工程師與 PM 的目標一致，整體的合作就會更加融洽也目標，這也是為什麼 Meta 的工程師非常了解自己產品的指標跟數據，還會花時間去分析產品數據與使用者分析報告，透過自己的理解來思考到底要怎麼去改善產品的方向，而不是完全等待 PM 發號司令。</p><h1>基礎架構被視為一個產品販售</h1><p>Meta 內部的基礎架構某程度也被視為是一個產品，公司內的其他工程團隊則是該產品的潛在用戶，所以開發該產品的團隊本身也要努力的去推銷這個產品，去說服為什麼要使用這個架構，使用這個架構能夠帶來什麼樣的好處。
作者以早期的 Reat, React Native 為範例，早期該產品於公司內推廣也是四處碰壁，並非外部所想像的一推廣就廣受歡迎與嘗試。</p><p>由於基礎架構被視作是產品，所以如果其「商業」表現不如預期的話，該專案也是會被砍掉的，這類型的模式搭配上述的概念其實非常有趣</p><p>所有的專案都想要長期存活都必須要證明其有價值，就算是內部架構也要證明其對內部其他工程團隊有價值
這種方式也降低了「只專注技術而不考慮使用者需求的」的開發方式，這讓我想到大家最愛講的「Service Mesh」.... 帶來什麼效應不確定，但是很潮就是享用...，</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Package Maintainers 應該要具備的資安概念」]]></title>
        <id>https://hwchiu.com/2022/03/16/reading-notes-28</id>
        <link href="https://hwchiu.com/2022/03/16/reading-notes-28"/>
        <updated>2022-03-16T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「Package Maintainers 應該要具備的資安概念」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「Package Maintainers 應該要具備的資安概念」
類別: other
連結: <a href="https://sethmlarson.dev/blog/security-for-package-maintainers" target="_blank" rel="noopener noreferrer">https://sethmlarson.dev/blog/security-for-package-maintainers</a></p><p>本篇文章的作者是 python3 urllib3 套件的主要維護者，由於近年來軟體供應鏈的資安議題逐漸受到重視，特別是這些已經被廣泛使用的套件，一套受到入侵與修改，其影響危害程度難以想像
作者撰寫本篇文章分享自己的想法希望能夠讓所有套件維護者有一些基本的資安觀念，同時也讓所有使用 OSS 的使用者一起學習</p><h1>捐贈給開源貢獻者</h1><p>作者提到本文提到的所有資安意識都需要花時間精力去實作與維護，如果你的組織使用了大量的開源專案但是本身在意資安卻又不想要花時間研究資安，那就花點小錢捐贈給這些開源貢獻者，讓這些貢獻者有更多的動力去幫你維護這些套件。
如果該開源專案對於你公司來說有非常舉足輕重的角色，那甚至可以考慮雇用一兩個該專案的主要維護者讓他們定期分配時間來維護，對公司來說只是花一些小錢但是卻能夠有更有信心的使用這些開源專案，以免哪天這些專案一炸整個公司產品全炸</p><p>文章主要分成兩大類，分別是</p><ol><li>如何保護好你的個人帳戶</li><li>如何保護好你的套件倉庫</li></ol><h1>Securing Your Accounts</h1><p>對於一個套件維護者來說，你的個人帳號由於有超級大的權力，所以該帳號的資安管理必須是最高層級的注意，一但這個帳號被攻破，攻擊者就可以很輕鬆的去發布新版本，加入惡意程式碼等各種行徑，而通常使用者如果本身使用時沒有很好的限制版本，譬如採用大於1.1.0 這種比較寬鬆的用法就會不自覺升級而使用到危險版本
作者強調就算你本身不是套件維護者，這些帳戶保護方式對你來說也是非常實用的，良好的資安保護永遠不吃虧</p><p>接下來作者列出幾個大項，分別是</p><ol><li><p>Email Securiy Is Your Top Priority
Email 地址很重要，很多情況下這些地址都會是重設密碼的一個途徑，所以妥善保存 Email 地址是非常重要的，所以作者推薦使用那些大公司服務如 Gmail 與 Outlook。 如果你真的想要使用私人域名作為你的聯絡信箱，你就要保證你不會有忘記付費的那天，不會剛好有人買走你的域名然後順利的取走你的 Email 地址。</p></li><li><p>2FA
2FA 要求提供一個除了密碼以外的認證方式，常見的有手機或是一些硬體裝置，使用妥當的話基本上攻擊者很難登入你的帳號。
作者認為所有跟程式碼有關的帳號密碼最終都需要有一個不使用 SMS(簡訊) 的 2FA 機制保護，譬如 NPM 最近才宣布其 Top 500 的套件管理都需要強迫使用 2FA，作者希望 Python 有天也可以跟上這種趨勢。</p></li><li><p>Password Managers</p></li><li><p>Hardware Keys</p></li><li><p>Why Not SMS 2FA</p></li><li><p>Where Do I Put My Recovery Codes</p></li><li><p>What to do if your account is compromised?</p></li></ol><p>上述範例我就不列出來了，每個項目都沒有很長，非常推薦大家閱讀，甚至可以讓團隊的所有工程師都有這些基本概念</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「如何判別到底要不要使用 Service Mesh」]]></title>
        <id>https://hwchiu.com/2022/03/13/reading-notes-27</id>
        <link href="https://hwchiu.com/2022/03/13/reading-notes-27"/>
        <updated>2022-03-13T23:05:08.000Z</updated>
        <summary type="html"><![CDATA[「如何判別到底要不要使用 Service Mesh」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「如何判別到底要不要使用 Service Mesh」
類別: Network
連結: <a href="https://medium.com/google-cloud/when-not-to-use-service-mesh-1a44abdeea31" target="_blank" rel="noopener noreferrer">https://medium.com/google-cloud/when-not-to-use-service-mesh-1a44abdeea31</a></p><p>本篇文章是一個經驗探討文，想要探討近年來非常熱門的網路網格(Service Mesh) 到底導入時要怎麼抉擇與判斷。
Service Mesh 如果用得正確與適當，能夠為團隊帶來很多優勢，可以讓團隊更專注於軟體的服務上，讓 Service Mesh 幫忙提供各種方便的功能。
但是如果使用錯誤則可能只會造成整體架構更加複雜，同時也沒有解決什麼真的重點問題，一切只是疊床架屋的空殼而已。</p><ol><li><p>採用 Service Mesh 要儘早
作者認為到底要不要導入 Service Mesh 是一個專案初期就要決定的事情，即使 Istio 網站有特別教學如何將專案從 non-MTLS 給轉移到基於 Istio MTLS 的過程
但是作者說真的跑過這些流程就知道絕對不是官網寫的三言兩語這麼簡單，有太多額外的事情要考慮，譬如上層安裝的服務，網路分層設計等，這些會因為有沒有 Service Mesh
而有不同的決定</p></li><li><p>不要當 Yes Man
作者體驗過最多的案例就是每個團隊看到下列問題都是不停的說 YES，然後最後就直接無腦導入 Service Mesh</p></li><li><p>我們需不需要強化資安</p></li><li><p>使用 mTLS 能不能強化資安</p></li><li><p>mTLS 是不是很難管理</p></li><li><p>Service Mesh 是不是可以讓 mTLS 便於管理</p></li></ol><p>連續四個 YES 下來就直接無懸念的導入 Service Mesh，殊不知</p><p>因此作者接下來就列出幾個要導入 Service Mesh 前需要仔細思考過的問題</p><ol><li><p>是否有計畫於當下或是未來使用到 Serivce Mesh 的所有功能
Service Mesh 的功能除了 mTLS 外還有各式各樣跟流量有關的管理，譬如 A/B Testing, 金絲雀部署等。
透過 Service Mesh 能夠讓應用程式不需要實作這些功能而依然可以享有這些功能的好處。
所以作者認為團隊中的所有人都要仔細的注意，到底你們即將採用的 Service Mesh 有哪些功能可以用，這樣可以避免應用程式重複開發相同功能。
作者也提到不需要第一天就決定好要採用什麼功能，但是至少要仔細理解自己採用的解決方案到底有什麼功能，然後未來改善架構的時候可以即時的想起來這功能有提供</p></li><li><p>團隊中是否有人對於 Service Mesh 有足夠的理論或是實戰理解？
作者看到的非常多團隊很多人根本不理解 Kubernetes 以及 Service Mesh 但是就想要導入 Service Mesh。
由於對 Service Mesh 完全不理解，連其實作的概念都不同，所以當問題發生的時候就什麼都不能做，因為根本不懂也不知道該從何下手
請花時間學習與理解你要使用的專案，以確保你有足夠的背景知識去使用與除錯</p></li></ol><p>除了問題之外，作者也認為要導入 Service Mesh 到生產環境並不是單純的建構一個 Hello World 這麼簡單，還有很多事情要考慮，譬如</p><ol><li>自動化</li><li>監控與追蹤</li><li>除錯與已難雜症排除</li></ol><p>整篇文章非常的棒，有興趣的可以詳細閱讀</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="ServiceMesh" term="ServiceMesh"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「透過 Helm 與 Terraform 來自動 Re-new Cloudflare origin CA」]]></title>
        <id>https://hwchiu.com/2022/03/11/reading-notes-26</id>
        <link href="https://hwchiu.com/2022/03/11/reading-notes-26"/>
        <updated>2022-03-11T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「透過 Helm 與 Terraform 來自動 Re-new Cloudflare origin CA」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「透過 Helm 與 Terraform 來自動 Re-new Cloudflare origin CA」
類別: usecase
連結: <a href="https://awstip.com/auto-renew-cloudflare-origin-ca-with-terraform-and-helm-d28be3f5d8fa?source=linkShare-91a396987951-1645539866&amp;gi=a18b2bbd9604" target="_blank" rel="noopener noreferrer">https://awstip.com/auto-renew-cloudflare-origin-ca-with-terraform-and-helm-d28be3f5d8fa?source=linkShare-91a396987951-1645539866&amp;gi=a18b2bbd9604</a></p><p>本篇文章是過工具介紹文，探討如何基於 Helm 與 Terraform 這兩個不同層級的工具來處理 Cloudflare 的憑證。</p><h1>Why Cloudflare</h1><p>根據 W3Techs 的調查顯示， 81.2% 的網站都使用 Cloudflare 來提升讀取速度或安全防護。
透過 CDN 的概念與機制，網站可以讓全球使用者有更快的讀取速度，此外也愈來愈多的網站會透過 Cloudflare 來處理如機器人, DDOS 之類的流量攻擊，畢竟要自己架設網站處理這些攻擊非常困難
因此讓 Cloudflare 這類型的網站來幫忙過濾與處理能夠讓團隊更專注於本身的業務開發與維運</p><h1>Kubernetes</h1><p>想要在 Kubernetes 內妥善管理所有使用的憑證其實也是一個麻煩事情，除了要能夠設置正確來創立憑證外，能夠於到期前自動 re-new 也是一個不可或區的功能。
Kubernetes 內跟憑證有關的最知名專案我想就是 Cert-Manager，而 Cloudflare 也基於此專案撰寫了相關的 Kubernetes Controller，如 Origin CA 等
因此本文使用的功能與示範都會基於 cert-manager 與 Cloudflare 的架構。</p><h1>目的</h1><p>本文的目的是希望能夠將過往手動的繁瑣步驟給自動化，讓 Kubernetes 可以獲得 Cloudflare 提供的好處，如憑證與相關域名等。
內文是基於 Terraform 作為出發點，然後透過 Kubernetes Provider 的方式來與之互動，一步一步的安裝各種資源最後成功於叢集內獲得相關域名的 SSL 憑證以及其他資源</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
        <category label="Helm" term="Helm"/>
        <category label="Terraform" term="Terraform"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「20年工程師生涯教會我的 20 件事情」]]></title>
        <id>https://hwchiu.com/2022/03/07/reading-notes-25</id>
        <link href="https://hwchiu.com/2022/03/07/reading-notes-25"/>
        <updated>2022-03-07T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「20年工程師生涯教會我的 20 件事情」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「20年工程師生涯教會我的 20 件事情」
類別: others
連結: <a href="https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/" target="_blank" rel="noopener noreferrer">https://www.simplethread.com/20-things-ive-learned-in-my-20-years-as-a-software-engineer/</a></p><p>本篇文章是作者談談自己工程生涯近 20 年的經驗，聊聊 20 個作者覺得很值得跟大家分享的一些想法與經驗。
開頭作者就說，所有的建議與經驗分享最重要的就是脈絡，沒有了脈絡所有的建議可能都沒有任何用處，甚至可能會對你有害
所以作者先表明自己的一些經驗，包含</p><ol><li>前半職業生涯作為一個小型公司與新創的軟體工程師。</li><li>顧問人生同時加入規模非常大的公司</li><li>創立 Simple Thread 這間公司從兩人團隊一路成長至今</li></ol><p>這邊節錄幾個經驗，整體來說我認為全部都滿不錯的，都推薦當作心法去看待，甚至也可以作為一些討論的主題。</p><ol><li><p>I still don’t know very much:
不知道你有沒有很常聽到別人說「你怎麼會不知道 BGP 怎麼運作？」「你怎麼沒有聽過 RUST ?」，軟體世界的有趣點不論你怎麼學習，每天都有會展新的技術被發展出來
你於你專精的領域努力了十年，對於其他人的領域你會發現還是有很大一片空白需要學習。
所以請認知這一點，軟體世界龐大本來就很容易有不知道的事情，然後保持謙虛的去面對這一切，不要用一種別人都是白癡的態度來質疑別人</p></li><li><p>The best software engineers think like designers
最好的軟體工程師其思路不單純只是滿足功能，而是如同一個設計師一樣，會去思考設計的這個軟體各種使用，包含外部 API的設計，使用者介面，甚至要去考慮
使用者會怎麼使用，使用者為什麼會想要用等，將使用需求放到開發的第一順位才能夠打造一款真的是很適合使用者使用的軟體。</p></li><li><p>Look for technological sharks
那些發展許久至今仍活躍的技術能夠於現在這個迭代快速的世代存活下來必定有其價值與原因，如果今天想要替換掉這些技術一定要有很好的理由與評估，不要單純冒然基於
新技術好像比較好就去替換。這些舊有的技術與工具也許用起來沒有現在這麼潮，但是其穩定性與良好的表現絕對能夠讓你晚上好好睡覺</p></li><li><p>Every system eventually sucks, get over it
軟體開發中沒有一個正確的架構，所有的人無時無刻都在處理相關的技術債，所有開發的介面過一段時間都會因為情境不同而需要改動與重寫，你撰寫的測試永遠都不足夠。
但是這些概念並不能當作一個不往前邁進的理由，相反的就是因為知道沒有一個完美的架構，所以才要更有系統地去持續精進整個架構，永遠都有值得改善與變好的地方
透過不停的循環這個開發流程才能夠讓整個軟體愈來愈好。</p></li></ol><p>文章中還有其他 16 個非常實用的建議，非常推薦大家閱讀閱讀</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Kubernetes 紀錄片 」]]></title>
        <id>https://hwchiu.com/2022/03/04/reading-notes-24</id>
        <link href="https://hwchiu.com/2022/03/04/reading-notes-24"/>
        <updated>2022-03-04T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「Kubernetes 紀錄片 」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「Kubernetes 紀錄片 」
類別: others
連結: <a href="https://thenewstack.io/a-kubernetes-documentary-shares-googles-open-source-story/" target="_blank" rel="noopener noreferrer">https://thenewstack.io/a-kubernetes-documentary-shares-googles-open-source-story/</a></p><p>來自歐洲的 Honeypot.io 與 RedHat, Google 以及 CNCF 合作完成一個長達一小時的 Kubernetes 紀錄片，該紀錄片分成上下兩集，探討 Kubernetes 的發展及過程
被戲稱就像是給開發人員的 Netflix 影片
如果英聽還行的話，非常推薦當個小品影片去聽聽看 Kubernetes 的今生前後</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Golang 原始碼的的版本控制歷史」]]></title>
        <id>https://hwchiu.com/2022/03/02/reading-notes-23</id>
        <link href="https://hwchiu.com/2022/03/02/reading-notes-23"/>
        <updated>2022-03-02T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「Golang 原始碼的的版本控制歷史」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「Golang 原始碼的的版本控制歷史」
類別: others
連結: <a href="https://research.swtch.com/govcs" target="_blank" rel="noopener noreferrer">https://research.swtch.com/govcs</a></p><p>本篇文章是 rsc 來仔細介紹 golang 的發展歷史，主要是針對整個開發過程的版本控制轉移以及一些有趣的 Commmit
舉例來說，如果你去看 golang 的 commit 會發現第一筆 commit 是 1972 年的內容，並且該 commit 增加了一個  src/pkg/debug/macho/testdata/hello.b 的檔案</p><p>而以實際狀況來說，前面四筆都是假的 commit，第五筆 commit 才是 golang 開發的第一筆 commit，這之間的緣由牽扯到版本控制的轉變。
以 Golang 來說，其經歷了四次轉變化，從最初的 Subversion 到 Perforce 到 Mercurial 到 Gerrit</p><p>其中 golang 正式對外公開是發生於 Mercurial 的過程中，而這些假的 commit 也是這個時間點由 rsc 自己產生的，當作一個復活節彩蛋的概念
有興趣的可以閱讀全文</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Golang" term="Golang"/>
        <category label="Git" term="Git"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「大家總是喜歡誇大自己的工作時數」]]></title>
        <id>https://hwchiu.com/2022/02/28/reading-notes-22</id>
        <link href="https://hwchiu.com/2022/02/28/reading-notes-22"/>
        <updated>2022-02-28T00:05:07.000Z</updated>
        <summary type="html"><![CDATA[「大家總是喜歡誇大自己的工作時數」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「大家總是喜歡誇大自己的工作時數」
類別: other
連結: <a href="https://drmaciver.substack.com/p/people-dont-work-as-much-as-you-think" target="_blank" rel="noopener noreferrer">https://drmaciver.substack.com/p/people-dont-work-as-much-as-you-think</a></p><p>本篇是一個心態探討文，作者探討了到底一天的有效工作時間有多少，並且認為人們宣稱的工作時間通常都不准，很多時候只是一種想要讓人看到自己工作很久的心態而已。
從作者的經驗來說，作者認為軟體開發，作家，顧問等行業都會有這類型的特性，一個有效率的工作者其實根本不可能一整天連續工作八小時。
一開始作者先列舉自己一天可以達到的事情有哪些(可達到不代表全部都會做)</p><ol><li>1-2 小時的重度耗腦力工作，如果事情沒有太複雜有時候可以到三小時左右。</li><li>不太動腦 code review 或是閱讀不會花費太多精力，整體來說算可以輕鬆進行</li><li>4 小時的面對面教學與指導</li><li>4-6 小時左右的常規工作，譬如重構程式碼</li><li>4-6 小時左右的沈浸式工作，譬如研究一個困難的 Bug。這類型的工作通常需要當天身心狀況良好同時也沒有人會一直打斷你，通常一年中發生的次數不太高。</li></ol><p>總體來說，作者一天認真工作的時間大概就是四小時左右，當然有需求時當然可以提升整體的工作量，不過作者認為這會影響身心健康，所以不是很喜歡。作者也認為「愈需要創作的工作其實真正工作的時間愈少」
很多工程師看起來工時很長其實有時候上班也都在滑 Twitter, Reddit 等各種網站，真正的工作時長其實都不如自己宣稱的。因為每個人的精力有限，不可能長時間執行高度專心的工作，很多時候花一堆時間去拼工作量結果得到的是每件事情都辦不好，
與其如此不如找到一個適合自己的工作方式，讓自己能夠有效率地去做好每件事情。</p><p>這邊要特別注意的是</p><ol><li>請評估自己每天到底可以工作多少小時，然後不要嘗試工作超時</li><li>不要因為自己的精力與工作時數多寡而感到羞愧，好好面對自己</li><li>不要為了那些會打破你上述規則的工作而加班</li></ol><p>如果今天有人要丟工作給你，請友善禮貌地回答「我很願意幫忙你，不過我目前手頭上正在忙 XYZ，你想要做的事情優先度有比較高嗎？」</p><p>最後作者針對工程師列出一個不同類型工作的適合工作時數</p><ol><li>1-2 小時的專注工作，如 coding, debugging</li><li>1-2 小時的無腦工作，如參加會議， code review</li><li>1-2 小時的"可被找到"的時間，譬如 Slack 上可以被找到，可以回答各種問題</li><li>結論來說一天工作不會超過四小時</li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「ClickHouse 與 Elasticsearch 的比較」]]></title>
        <id>https://hwchiu.com/2022/02/25/reading-notes-21</id>
        <link href="https://hwchiu.com/2022/02/25/reading-notes-21"/>
        <updated>2022-02-25T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「ClickHouse 與 Elasticsearch 的比較」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「ClickHouse 與 Elasticsearch 的比較」
類別: other
連結: <a href="https://developer.aliyun.com/article/783804" target="_blank" rel="noopener noreferrer">https://developer.aliyun.com/article/783804</a></p><p>這篇文章內容非常精彩，從不同層面去探討 Elasticsearch 與 ClickHouse 這兩套解決方案的差異，探討了包含</p><ol><li>分散式架構</li><li>儲存架構，包含寫入資料的設計，底層 Segment 與 DataPart 的差異以及 Schemaless 特性帶來的影響</li><li>查詢架構，包含底層引擎是如何計算使用者的輸入</li><li>效能測試，針對不同的場景來比較效能</li></ol><p>文章很長且滿多技術坑，適合對於 Elasticsearch 有維運與管理有經驗的使用者</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Paypal 如何調整 Kubernetes 讓其規模達到四千節點，20萬個 Pod」]]></title>
        <id>https://hwchiu.com/2022/02/23/reading-notes-20</id>
        <link href="https://hwchiu.com/2022/02/23/reading-notes-20"/>
        <updated>2022-02-23T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「Paypal 如何調整 Kubernetes 讓其規模達到四千節點，20萬個 Pod」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「Paypal 如何調整 Kubernetes 讓其規模達到四千節點，20萬個 Pod」
類別: usecase
連結: <a href="https://medium.com/paypal-tech/scaling-kubernetes-to-over-4k-nodes-and-200k-pods-29988fad6ed" target="_blank" rel="noopener noreferrer">https://medium.com/paypal-tech/scaling-kubernetes-to-over-4k-nodes-and-200k-pods-29988fad6ed</a></p><p>摘要:
Paypal 過去一直都使用 Apache Mesos 來運行其大部分的服務，而其最近正在針對 Kubernetes 進行一個評估與測試，想瞭解如果需要轉移到 Kubernetes 會有哪些問題需要挑戰與克服。
本篇文章著重的是效能問題，原先的 Apache Mesos 可以同時支持一萬個節點，因此 Kubernetes 是否可以拿到相同的效能
而本文節錄的就是擴充 Kubernetes 節點中遇到的各種問題以及 Paypal 是如何修正與調整讓 Kubernetes 可能容納盡可能更多的節點。</p><h1>Cluster Topology</h1><ol><li>三個 Master 節點與三個獨立的 ETCD 叢集，所有服務都運行於 GCP 上。</li><li>工作節點與控制平面的服務都運行於相同的 GCP Zone 上。</li></ol><h1>Workload</h1><p>效能測試方面是基於 k-bench 去開發的測試工具，基於平行與依序等不同方式來創建 Pod/Deployment 兩種資源。</p><h1>Scale</h1><ol><li>測試初期先以少量的節點與少量的 Pod 開始，接者發現還有提升的空間就會開始擴充 Pod 與節點的數量。</li><li>測試的應用程式是一個要求 0.1m CPU 的無狀態應用程式。</li><li>最初的工作節有點 4 個 CPU，根據測試可以容納大概 40 Pod 左右。
接者就是不停地擴充數量，先從一千個節點開始，接者調整Pod 的數量直到 32,000 個 Pod。最後擴充到 4,100 個節點並且配上 200,000 個 Pod.
過程後期有調整節點的 CPU 數量讓其能夠容納更多的 Pod 數量</li></ol><p>文章接下來開始針對 API Server, Controller Manager, Scheduler, ETCD 元件遇到的問題並且如何解決，中間提到了不少參數，這部分應該是大部分使用者都比較不會去研究與使用的參數
因此我認為本篇文章非常值得閱讀。
ETCD 的部分遇到很嚴重的效能問題，作者團隊觀察到大量的 Raft 溝通失敗個訊息，觀測到跟硬碟寫入速度有關，然而 GCP 沒有辦法單純增加效能，必須要同時提升硬碟空間，所以使用上彈性不變。
不過就算採用 1TB 的 PD-SSD ，當 4 千個節點同時加入到 Kubernetes 時依然會遇到效能上的問題，團隊最後決定使用本地端的 SSD 來想辦法改善寫入速度，結果又遇到 ext4 的一些設定
過程很多問題也很多解決方式。</p><p>結論來說: k8s 複雜</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「macOS 的 fsync 實作其實跟大家想像的完全不同 」]]></title>
        <id>https://hwchiu.com/2022/02/21/reading-notes-19</id>
        <link href="https://hwchiu.com/2022/02/21/reading-notes-19"/>
        <updated>2022-02-21T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「macOS 的 fsync 實作其實跟大家想像的完全不同 」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「macOS 的 fsync 實作其實跟大家想像的完全不同 」
類別: others
連結: <a href="https://mobile.twitter.com/marcan42/status/1494213855387734019?t=TyXUEg-2LcbNiKkv0JVOsg&amp;s=09" target="_blank" rel="noopener noreferrer">https://mobile.twitter.com/marcan42/status/1494213855387734019?t=TyXUEg-2LcbNiKkv0JVOsg&amp;s=09</a></p><p>以下節錄自該留言串
「As it turns out, macOS cheats. On Linux, fsync() will both flush writes to the drive, and ask it to flush its write cache to stable storage.</p><p>But on macOS, fsync() only flushes writes to the drive. Instead, they provide an F_FULLSYNC operation to do what fsync() does on Linux.」</p><p>簡單來說就是 Linux 的 fsync 會執行兩次動作，最終讓當次修改給寫回到底層儲存設備，而 macOS 的版本卻不會真的確認寫回硬碟，所以這個導致很多仰賴 fsync 的應用程式就會有一些不預期的行為，這也是為什麼首篇發文的內容
「Well, this is unfortunate. It turns out Apple's custom NVMe drives are amazingly fast - if you don't care about data integrity.</p><p>If you do, they drop down to HDD performance. Thread.」</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「 取代 Docker Desktop 的高效率開發環境」]]></title>
        <id>https://hwchiu.com/2022/02/18/reading-notes-18</id>
        <link href="https://hwchiu.com/2022/02/18/reading-notes-18"/>
        <updated>2022-02-18T00:05:09.000Z</updated>
        <summary type="html"><![CDATA[「 取代 Docker Desktop 的高效率開發環境」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「 取代 Docker Desktop 的高效率開發環境」
類別: Container
連結: <a href="https://medium.com/partoo/replacing-docker-desktop-with-a-more-efficient-development-environment-582c61c50984" target="_blank" rel="noopener noreferrer">https://medium.com/partoo/replacing-docker-desktop-with-a-more-efficient-development-environment-582c61c50984</a></p><p>作者認為 Docker Desktop 是一個非常好的開發環境工具，能夠簡化很多設定讓開發者更容易的開發應用程式，但是對於 Windows/Mac 的使用者來說
Docekr Desktop 實際上也是先運行一個基於 Linux 的 VM 並且於其中運行 Docker Container。這種架構實際上帶來了一些使用上的缺陷，包含</p><ol><li>FileSystem 的處理效能非常不好，不論是使用 cahced 或是 gRPC-fuse 檔案系統還是沒有辦法得到很好的效能。</li><li>資源使用有問題不如預期，作者設定希望最多使用 6GB 結果最後卻使用到了 15GB，幾乎吃光系統所有記憶體</li><li>官方幾乎沒有文件去探討該 VM 的存取方式(雖然滿多人會用 nsenter 進入)，所以很難把一些本地檔案給直接放到 VM 內來提昇儲存相關的問題，變成所有的儲存都只能用 docker volume 來處理。</li></ol><p>作者的公司 Partoo 採取了 VM + Vagrant + Ansible 的方式來創建開發者環境，讓每個加入團隊的開發者都可以輕鬆簡單的建設期開發環境
並且文章中也探討如何於本地端使用 Vistual Studio Code, PyCharm 來編輯 VM 的檔案並且順利的進行應用程式開發。</p><p>從效率來看，相對於直接使用 Dodcker Desktop 來看，作者團隊的測試程式基於自己的 VM 提升了將近 30% 的效能，主要的問題就是儲存系統與 Docker Container 之間的掛載關係差異。</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="DevOps" term="DevOps"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「 Kubernetes 四種不同開發環境的比較」]]></title>
        <id>https://hwchiu.com/2022/02/16/reading-notes-17</id>
        <link href="https://hwchiu.com/2022/02/16/reading-notes-17"/>
        <updated>2022-02-16T00:05:07.000Z</updated>
        <summary type="html"><![CDATA[「 Kubernetes 四種不同開發環境的比較」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「 Kubernetes 四種不同開發環境的比較」
類別: Kubernetes
連結: <a href="https://loft-sh.medium.com/kubernetes-development-environments-a-comparison-f4fa0b3d3d8b" target="_blank" rel="noopener noreferrer">https://loft-sh.medium.com/kubernetes-development-environments-a-comparison-f4fa0b3d3d8b</a></p><p>根據 VMware 2020 的一個研究報告指出，如何存取 Kubernetes 叢集是影響開發者生產效率的最大要素，所以本篇文章就是就會針對如何去評估與挑選一個適合開發者的
Kubernetes 叢集與存取方式。</p><p>作者將 Kubernetes 叢集分成四大類，分別是</p><ol><li>Local Cluster: 開發者會基於自己本地的電腦來創造一個本地的 Kubernetes 叢集</li><li>Individual Cloud-Based Cluster: 開發者基於雲端環境來創建一個專屬於該開發者的 Kubernetes 叢集</li><li>Self-Service Namespace: 使用基於 namespace 的方式來讓多位開發者共享一個 Kubernetes 叢集</li><li>Self-Service Virtual Cluster: 讓 Kubernetes 來創建更多小 Kubernetes 叢集並且讓每個使用者有獨立專屬的 Kubernetes 叢集</li></ol><p>為了比較這四種不同的叢集，作者定義了幾個不同的面向，針對這幾個面向來評比，分別是</p><ol><li>Developer Experience: 對於開發者來說要如何開始使用叢集，包含架設的複雜度，使用的難易度以及需要的相關背景多寡</li><li>Admin Experience: 對於公司的管理人員來說需要花多少心力來管理該從開發者環境，除了基本的管理還要考慮增加新使用者帶來的負擔</li><li>Flexibility/Realism: 該開發環境與正式生產環境的架構相似度如何，此外開發者是否有足夠的彈性去客製化該叢集的所有設定</li><li>Scalability: 該環境是否能夠根據開發需求來擴充？ 特別是針對部分需要大量使用資源的應用程式開發是否有辦法處理。</li><li>Isolation/Stability: 開發者彼此之間的隔離程度如何，彼此之間的工作是否會影響彼此？ 有資安問題的時候是否會連環爆？</li><li>Cost: 該解決方案的成本多寡，成本就是真正的金錢考量。</li></ol><p>文章一開始就有列出一個結論表，對於這個議題有興趣的歡迎閱讀</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「 談談遷移應用程式到 Kubernetes 內的失敗經驗談」]]></title>
        <id>https://hwchiu.com/2022/02/14/reading-notes-16</id>
        <link href="https://hwchiu.com/2022/02/14/reading-notes-16"/>
        <updated>2022-02-14T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「 談談遷移應用程式到  Kubernetes 內的失敗經驗談」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「 談談遷移應用程式到  Kubernetes 內的失敗經驗談」
類別: Kubernetes
連結: <a href="https://medium.com/@marcong_54227/unsuccessful-experience-of-migrating-applications-to-kubernetes-a896823d9b95" target="_blank" rel="noopener noreferrer">https://medium.com/@marcong_54227/unsuccessful-experience-of-migrating-applications-to-kubernetes-a896823d9b95</a></p><p>作者團隊於 2019 年要開發一個全新的 API 應用程式，當時部門的 IT 團隊計畫要將既有的 VM-Based 應用程式給轉換到 Container-Based，最後團隊使用了 RedHat 的系統，並且使用
OpenShift 做為容器管理平台。</p><p>從結果來看，該專案從 2020/05 一路到 2021/05 花了整整一年也沒有順利的將應用程式轉移到 OpenShift 中，其中的一些重點有</p><ol><li>初期建設時 RedHat 有展示過如何使用 Java 基於 Fuse 開發應用程式，但是作者團隊全部都是 .Net 的經驗，因此團隊花了很多時間來學習如何使用 Fuse</li><li>2020/06 時因為團隊的進度緩慢，所以 IT 團隊尋找外部的軟體顧問，尋求如何將 .Net 從 VM 轉移到 OpenShift</li><li>團隊內的開發者都不擅長學習新技術，對於學習新技術這一塊非常不行。</li><li>外部團隊幫忙建置了 CI/CD 系統，然後團隊內從 2020/09 開始進行程式開發與轉移，可惜直到 2021/05 依然沒有半個產品成功的用 OpenShift 作為正式生產環境</li><li>與此同時，外部團隊也撰寫了幾個 .NET 示範應用程式來展示容器化的注意事項，然而團隊本身對 Container 的知識非常薄落，所以團隊人員沒有辦法參考這些範例程式來改善自己開發過程</li></ol><p>最後團隊內又針對不同團隊給予不同的想法</p><ol><li>Application Team</li><li>Server Team</li><li>Network Team</li><li>IT Management Team</li></ol><p>譬如 Application Team 的開發人員都只滿足自身的技能，而且拒絕學習新技能，誇張的是一年過後團隊內的人也沒有辦法撰寫 dockerfile 或是使用 docker build.</p><p>後續還有一些針對不同團隊的想法與總體建議，整體來說非常真實，一個血淋淋的轉換案例。</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「GitHub 上常常看到的奇妙 commit 到底是什麼？」]]></title>
        <id>https://hwchiu.com/2022/02/11/reading-notes-15</id>
        <link href="https://hwchiu.com/2022/02/11/reading-notes-15"/>
        <updated>2022-02-11T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「GitHub 上常常看到的奇妙  commit 到底是什麼？」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「GitHub 上常常看到的奇妙  commit 到底是什麼？」
類別: others
連結: <a href="https://people.kernel.org/monsieuricon/cross-fork-object-sharing-in-git-is-not-a-bug" target="_blank" rel="noopener noreferrer">https://people.kernel.org/monsieuricon/cross-fork-object-sharing-in-git-is-not-a-bug</a></p><p>每過一段時間都可以於 GitHub 上面看到一些看起來很嚇人的 Commit，最經典莫過於 Linux Kernel 中的各種內容，譬如檔案被砍光，README 加入一些驚嚇言論
不知道情的使用者可能會想說這個內容是真正的 Github Repo 上的東西，鐵定是真正被認可而合併進去的，所以相信不疑。
殊不知這一切其實都只是 Git 的底層設計使得一些有心人可以打造出一些以假亂真的內容，文章中就有列出兩個關於 Linux Kernel 的有趣 Commit.</p><p>文章內詳細的去解釋整個來龍去賣以及底層 Git 的設計，包含 blob, tree, commit 之間的關係，並且說明為什麼有心人可以輕鬆的產生這些以假亂真的 Commit。
舉個範例來說，Linux Kernel 的整個 Git 專案大概有 3GB 的大小，然後被 Fork 的次數高達 40000 次，請問從實作方面來考量，你會希望</p><ol><li>每個 Fork 有一份屬於自己的 Git 專案?</li><li>仰賴 Git 的底層設計，針對差異性去記錄每個 Fork 專案？</li></ol><p>如果是選項(1)的話，那這樣至少要準備 120TB 的資料，從儲存方面來說完全不是一個可接受的實作方式，因此自然而然的都會是基於(2)的方式去實作
因此該 Linux Kernel 的 Git 專案實際上裡面記錄了所有的 Fork 資料，而每個人針對自己的 Fork 去進行更新等行為也都會記錄到 Linux Kernel 本身的專案上。
換句話說， 那 40000 個 Fork 出來的專案實際上還是共用同一份 Git 專案，因此每個人的 Commit 都只要該 Hash 被知道，其他人都有機會去檢視與瀏覽。</p><p>而 GitHub 的 UI 又允許使用者以 Commit Hash 的方式去瀏覽每一個 Commit 的內容，因此就可以跑到主要專案去輸入自己 Fork 產生的 Commit 來產生以假亂真的 Commit 內容。</p><p>對於整體有興趣的可以觀看全文</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Git" term="Git"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「透過一點小技巧讓你的 Makefile 有一個更好的 Help說明」]]></title>
        <id>https://hwchiu.com/2022/02/09/reading-notes-14</id>
        <link href="https://hwchiu.com/2022/02/09/reading-notes-14"/>
        <updated>2022-02-09T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「透過一點小技巧讓你的 Makefile 有一個更好的 Help說明」]]></summary>
        <content type="html"><![CDATA[<p><a href="https://daniel.feldroy.com/posts/autodocumenting-makefiles" target="_blank" rel="noopener noreferrer">https://daniel.feldroy.com/posts/autodocumenting-makefiles</a></p><p>標題: 「透過一點小技巧讓你的 Makefile 有一個更好的 Help說明」
類別: tools
連結: <a href="https://daniel.feldroy.com/posts/autodocumenting-makefiles" target="_blank" rel="noopener noreferrer">https://daniel.feldroy.com/posts/autodocumenting-makefiles</a></p><p>本篇文章使用 python 搭配 Makefile 的內建語法來輕鬆幫你的 Makefile 加上各種 Help 訊息，整個概念滿簡單的</p><ol><li>每個 Target 後面都補上一個基於 ## 的註解說明</li><li>使用 define/endef 來定義一個 python3 的內容，該 python3 會從 stdin 中去判別該 target 是否含有 ## 的字串，有的話就組合起來，並且輸出</li><li>加入一個 help 的 target，將內建變數 MAKEFILE_LIST 給丟到上述的 python3 去執行</li></ol><p>有興趣的可以看看，整個寫法非常簡單有趣。</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Linux" term="Linux"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「視覺化系統內 iptables 規則」]]></title>
        <id>https://hwchiu.com/2022/02/07/reading-notes-13</id>
        <link href="https://hwchiu.com/2022/02/07/reading-notes-13"/>
        <updated>2022-02-07T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「視覺化系統內 iptables 規則」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「視覺化系統內 iptables 規則」
類別: tools
連結: <a href="https://github.com/Nudin/iptable_vis" target="_blank" rel="noopener noreferrer">https://github.com/Nudin/iptable_vis</a></p><p>這是一個非常有趣的小工具，目標就是視覺化系統中的 iptables 規則，把 chain 之間的關聯給視覺化呈現出來
整個專案非常小，該專案主要會透過 awk 來解析系統中的規則並且產生特定輸出，接者使用別的軟體將該輸出給轉換成圖檔</p><p>有興趣的都可以使用看看</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Linux" term="Linux"/>
        <category label="Network" term="Network"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[]]></title>
        <id>https://hwchiu.com/2022/02/04/reading-notes-12</id>
        <link href="https://hwchiu.com/2022/02/04/reading-notes-12"/>
        <updated>2022-02-04T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「如何用 2297 個 Linux Kernel Patches 來重新整理所有的 header file 並提升整個 Kernel 建置時間高達 78%」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「如何用 2297 個 Linux Kernel Patches 來重新整理所有的 header file 並提升整個 Kernel 建置時間高達 78%」
類別: 其他
連結: <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Linux-Fast-Kernel-Headers" target="_blank" rel="noopener noreferrer">https://www.phoronix.com/scan.php?page=news_item&amp;px=Linux-Fast-Kernel-Headers</a></p><p>摘要:
Linux Kernel 的長期貢獻者 Ingo Molnar 花了一年多的時間整理 Kernel 內的 Header 架構，一口氣提交了 2297 個 patches，其中影響
的檔案數量有 25,288 個，並且加入了 178,024 行數，移除了 74,720 行。
這一系列的改動直接重新整理 Linux Kernel 內將近 10,000 個不同的 header 檔案，這次的整理將過去 30 年累積的各種你呼叫我，我呼叫你這
種「Dependency Hell」問題給一起處理掉，結果論來說提升了整體建置時間 50% ~ 80 %</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Linux" term="Linux"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「如何使用 jq 讓你的 kubectl更為強大」]]></title>
        <id>https://hwchiu.com/2022/02/02/reading-notes-11</id>
        <link href="https://hwchiu.com/2022/02/02/reading-notes-11"/>
        <updated>2022-02-02T18:05:07.000Z</updated>
        <summary type="html"><![CDATA[「如何使用 jq 讓你的 kubectl更為強大」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「如何使用 jq 讓你的 kubectl更為強大」
類別: tools
連結: <a href="https://medium.com/geekculture/my-jq-cheatsheet-34054df5b650" target="_blank" rel="noopener noreferrer">https://medium.com/geekculture/my-jq-cheatsheet-34054df5b650</a></p><p>作者認為 kubectl 本身提供的 label-selector, go-templates, jsonpath, custom-colume 等各式各樣功能使這個工具變得強大，能夠找到符合自己需求的各式各樣資源
然而上述的這些指令使用起來還是會覺得卡卡的，並沒有辦法滿足所有條件，而且不同選項的語法也完全不同，所以對於操作者來說其實不太便利。</p><p>順利的是 kubectl 可以透過 -o json 以 json 的格式輸出結果，這時候就可以搭配 jq 這個指令來使用，相對於前述的各種用法，作者更加推薦使用 jq 來處理，因為 jq 是一個更為廣泛的工具，
除了 kubectl 可以搭配外，很多時候都可以搭配 jq 來處理其他情況，因此掌握 jq 的語法實務上會有更多用途。</p><p>文章幾乎都是以 kubectl 為範例來介紹 jq 內的各種用法，除了基本的 read/write/filter 之外，還有各式各樣 jq 的內建函式，
有興趣的都可以使用看看</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「PwnKit, 長達 12 年可以讓一般使用者輕鬆變成 Root 的 CVE」]]></title>
        <id>https://hwchiu.com/2022/01/27/reading-notes-10</id>
        <link href="https://hwchiu.com/2022/01/27/reading-notes-10"/>
        <updated>2022-01-27T01:59:03.000Z</updated>
        <summary type="html"><![CDATA[「PwnKit, 長達 12 年可以讓一般使用者輕鬆變成 Root 的 CVE」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「PwnKit, 長達 12 年可以讓一般使用者輕鬆變成 Root 的 CVE」
類別: others
連結: <a href="https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034" target="_blank" rel="noopener noreferrer">https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034</a></p><p>CVE-2021-4034 講述的是 pkexec 此工具的 vulnerability，其影響範圍非常廣大，主要原因有</p><ol><li>滿多系統預設都有安裝這個工具，而該工具預設有 SUID 的權限</li><li>2009 後的版本就內建此安全性問題，所以請趕緊更新系統上的 pkexec</li><li>任何使用者可以輕鬆地直接透過此漏洞變成 root 的身份，譬如你今天取得一個 nobody 的角色，你也是有辦法變成 root 的。</li></ol><p>漏洞細節文章中有解釋非常多，主要是記憶體位置的處理沒有處理，當運行參數為空的時候，程式會意外地去讀取到後面的 envp 這塊用來存放環境變數的區塊，搭配
pkexec 後續的程式邏輯就有機會觸發本次 CVE 的安全性問題。
所以請趕緊更新系統上的 pkexec，確保該版本已經更新，否則任何一個使用者都可以輕鬆變成 root。</p><p>Ubuntu 使用者可參考 <a href="https://ubuntu.com/security/CVE-2021-4034" target="_blank" rel="noopener noreferrer">https://ubuntu.com/security/CVE-2021-4034</a></p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Security" term="Security"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Linux 5.17 將使用 BLAKE2s 來替代 SAH1 來達到更安全更快速的隨機亂數產生器」]]></title>
        <id>https://hwchiu.com/2022/01/24/reading-notes-9</id>
        <link href="https://hwchiu.com/2022/01/24/reading-notes-9"/>
        <updated>2022-01-24T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「Linux 5.17 將使用 BLAKE2s 來替代 SAH1 來達到更安全更快速的隨機亂數產生器」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「Linux 5.17 將使用 BLAKE2s 來替代 SAH1 來達到更安全更快速的隨機亂數產生器」
類別: other
連結: <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Linux-5.17-RNG" target="_blank" rel="noopener noreferrer">https://www.phoronix.com/scan.php?page=news_item&amp;px=Linux-5.17-RNG</a></p><p>Linux Kernel 內亂數子系統的維護者近期遞交了一個將 SAH1 給全面替換為 BLAKE2s 的相關 Patch</p><p>相對於 SHA1 來說， BLAKE2s 本身更為安全，同時計算速度也更快，這邊也可以參考下列這篇 2017 的文章
<a href="https://valerieaurora.org/hash.html" target="_blank" rel="noopener noreferrer">https://valerieaurora.org/hash.html</a> 來探討不同 HASH 演算法的一些狀態，雖然沒有及時更新到 2022 的狀態，但是如果 2017 都
不安全的東西現在就更不應該使用，譬如文章中提到 SAH1 於 2017 就被 Google 用(6500 CPU或是110 GPU)的實驗來證實有衝突，建議停止使用。</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Linux" term="Linux"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Kubernetes 內透過 DNS-01 處理 wildcard TLS 的兩三事」]]></title>
        <id>https://hwchiu.com/2022/01/21/reading-notes-8</id>
        <link href="https://hwchiu.com/2022/01/21/reading-notes-8"/>
        <updated>2022-01-21T00:05:07.000Z</updated>
        <summary type="html"><![CDATA[「Kubernetes 內透過 DNS-01 處理 wildcard TLS 的兩三事」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「Kubernetes 內透過 DNS-01 處理 wildcard TLS 的兩三事」
類別: introduction
連結: <a href="https://medium.com/linkbynet/dns-01-challenge-wildcard-tls-certificates-on-kubernetes-d2e7e3367328" target="_blank" rel="noopener noreferrer">https://medium.com/linkbynet/dns-01-challenge-wildcard-tls-certificates-on-kubernetes-d2e7e3367328</a></p><p>很多人都會使用 Kubernetes 的 Ingress 讓外部可以存取的部署的應用程式，同時會透過 Ingress 搭配 Cert Manager 來處理 TLS 的憑證
大部分情況下都會使用 HTTP-01 的方式來進行域名擁有性的認證，而某些情況可能不方便透過 HTTP 來驗證的話就會採取 DNS-01 的方式透過 DNS 創建一個
TXT 的資訊來驗證域名的擁有權，本篇文章則是作者分享 DNS-01 的一些心得分享</p><ol><li>文章開頭有介紹使用的 Stack，包含透過 Terraform 來架設模擬環境，並且使用 Scaleway DNS 作為 DNS Provider</li><li>Cert-Manager 部分的 DNS Provider 要採用 webhook 的方式來動態處理請求，當 cert-manager 偵測到有新的 TLS 憑證
需求時就會透過 webhook 的方式去創建遠方的 DNS TXT 紀錄，接者 Let's Encrypt 就會透過 TXT 來判斷你是否真的擁有個域名</li></ol><p>對 DNS-01 使用有興趣的可以看看本篇文章</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「透過 Crossplane 與 ArgoCD 來達成應用程式與基礎建設的 GitOps 部署方式」]]></title>
        <id>https://hwchiu.com/2022/01/19/reading-notes-7</id>
        <link href="https://hwchiu.com/2022/01/19/reading-notes-7"/>
        <updated>2022-01-19T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「透過 Crossplane 與 ArgoCD 來達成應用程式與基礎建設的 GitOps 部署方式」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「透過 Crossplane 與 ArgoCD 來達成應用程式與基礎建設的 GitOps 部署方式」
類別: cicd
連結: <a href="https://medium.com/containers-101/using-gitops-for-infrastructure-and-applications-with-crossplane-and-argo-cd-944b32dfb27e" target="_blank" rel="noopener noreferrer">https://medium.com/containers-101/using-gitops-for-infrastructure-and-applications-with-crossplane-and-argo-cd-944b32dfb27e</a></p><p>作者表示過往很多教學文章當探討到 Kubernetes 部署議題的時候，通常都不會去探討如何部署 Kubernetes 而是專注於應用程式的部署，
理由非常直觀，文章就是要專注於 Deployment 的議題，能夠讓讀者更容易地去閱讀與參考，另外一個背後的原因其實是因為 Kubernetes 部署的方式
太多種，常見的方式使用 Terraform 透過 IaC 的概念來管理，而應用程式都使用 Helm/Kustomize 完全不同的方式來管理</p><p>而作者今天想要探討的是如何透過 ArgoCD 來建設一個 GitOps 的環境，並且於上面使用 Crossplan 這個解決方案來處理各種底層基礎建設的需求，如此一來
就可以統一透過 Helm/Kustomize 的方式來描述這些基礎建設</p><p>Crossplan 很類似 Terraform 但是有者一些些微的差異</p><ol><li>Crossplan 本身是 Kubernetes 的應用程式，所以本身的描述方式就是 Kubernetes 的 YAML 方式</li><li>可以使用 kubectl, Helm/Kustomize 等方式來部署這些描述並且讓 Crossplan 來幫忙創建描述的基礎建設</li></ol><p>由於整個 Crossplan 可以視為一個 Kubernetes 應用程式，所以直接使用 ArgoCD 的方式來部署
有興趣的可以閱讀全問</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="GitOps" term="GitOps"/>
        <category label="DevOps" term="DevOps"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「The pains of GitOps 1.0」]]></title>
        <id>https://hwchiu.com/2022/01/17/reading-notes-6</id>
        <link href="https://hwchiu.com/2022/01/17/reading-notes-6"/>
        <updated>2022-01-17T00:05:07.000Z</updated>
        <summary type="html"><![CDATA[「The pains of GitOps 1.0」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「The pains of GitOps 1.0」
類別: cicd
連結: <a href="https://codefresh.io/about-gitops/pains-gitops-1-0/" target="_blank" rel="noopener noreferrer">https://codefresh.io/about-gitops/pains-gitops-1-0/</a></p><p>作者認為很多文章都闡述 GitOps 對於部署帶來的好處，但是軟體世界沒有十全十美的東西，所以作者就探討了 12 個其認為 GitOps 的缺點</p><p>註:</p><ol><li>本篇文章是 2020 年底的文章，所以文章探討的內容也許當年沒有很好的解決方式，但是現在已經有了比較好的處理方式。</li><li>我個人覺得文章的某些部分有點太牽強，已經假設 GitOps 是個萬能解法，什麼問題都要靠這個。就這個問題是不管有沒有 GitOps 都會存在的問題，有點為了反對而反對，與其說 GitOps 的缺點不如說沒有解決的問題。</li></ol><p>這邊就節錄幾個文章中探討的議題，剩下有興趣的可以閱讀全文</p><h1>GitOps covers only a subset of the software lifecycle</h1><p>作者認為 GitOps 的精神「我想要將 Git 專案內的所描述的狀態給同步到叢集中」這點只能處理應用程式部署的問題，但是其他的流程
譬如編譯程式碼，運行單元測試，安全性檢查，靜態掃描等過程都沒有辦法被 GitOps 給處理。</p><p>作者不滿的點主要是很多 GitOps 的工具好像都會宣傳自己是個全能的解決方案，能夠處理所有事情，但是實際上卻沒有辦法。
實際上其專注的點就是應用程式部署策略為主的部分，其餘部分還是團隊要有自己的方式去處理</p><h1>Splitting CI and CD with GitOps is not straightforward</h1><p>過往很多團隊都會將 CI/CD 給整合到相同的 pipeline 中去處理，通常是最後一個階段就會將應用程式給部署到目標叢集，然而有外部 Controller 實作的 GitOps
解決方案會使得 CI/CD 兩者脫鉤，好處來說就是 pipeline 不需要去處理部署，只需要專心維護 Git 內的資訊，後續都讓 Controller 來處理。</p><p>然後某些團隊本來的 CI/CD 流程會於部署完畢後還會進行一些測試或是相關操作，這部分會因為 GitOps 將部署給弄走導致整個流程不太好處理，畢竟要如何讓
GitOps 部署完畢後又要可以觸發其他的工作也是額外要處理的事情</p><h1>There is no standard practice for GitOps rollbacks</h1><p>雖然 GitOps 的核心是透過 Git Commit 去控制當前部署的版本，那發生問題時到底該怎麼處理，如何去 rollback?
作者舉兩種範例</p><ol><li>讓 GitOps 去指向之前的 Git Commit</li><li>針對 Git 使用 Git revert 等相關操作來更新最新的內容
作者認為沒有一個標準來告訴使用者該怎麼使用以及處理</li></ol><h1>Observability for GitOps (and Git) is immature</h1><p>作者認為目前現有的 GitOps 工具都沒有辦法提供下列答案</p><ol><li>目前生產環境是否有包含 Feature X</li><li>Bug X,Y 是否只有存在於 Staging 環境？ 還是生產環境也有？</li></ol><p>註: 有什麼概念是天生就可以有這些東西的..? GitOps 有點無妄之災</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="GitOps" term="GitOps"/>
        <category label="DevOps" term="DevOps"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「NPM 的 colors modules 打亂一堆人...」]]></title>
        <id>https://hwchiu.com/2022/01/11/reading-notes-5</id>
        <link href="https://hwchiu.com/2022/01/11/reading-notes-5"/>
        <updated>2022-01-11T08:05:08.000Z</updated>
        <summary type="html"><![CDATA[「NPM 的 colors modules 打亂一堆人...」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「NPM 的 colors modules 打亂一堆人...」
類別: other
連結: <a href="https://research.swtch.com/npm-colors" target="_blank" rel="noopener noreferrer">https://research.swtch.com/npm-colors</a></p><p>NPM 上一個著名的 Module Color 以及 Faker 的作者這幾天生氣氣的修改這兩個 module，於 Color 內塞入了無限循環並且印出各種亂碼
然後所有使用這兩個 module 的工具一旦更新就會發現自己的 Terminal 輸出整個爆炸，完全看不懂了。</p><p>這篇文章是 Golang 的作者 Russ Cox 分享關於這件事情的一些看法，簡單來說每個開放原始碼的授權都有提到並沒有保固這種事情，所以任何現代化的模組管理者
設計時都必須要考量到這種版本更新的可能性，並且盡可能地去減少。</p><p>文章中以 aws-cdk 作為範例， aws-cdk 最初描述時是使用 ^1.4.0 的方式來參考各種 ^1.4.0 版本的 color，結果 color 的作者就直接爆氣來一個炸彈，aws-cdk 直接更新然後建置，最後
產生出一個令人崩潰的版本。</p><p>作者認為任何一個系統要更新的時候應該都需要緩慢與穩健的去逐步更新，並且這些更新都要經過一段時間的觀察與測試來降低各種可能放到生產系統出包的可能性。</p><p>以下節錄自文章中的重點
「High-fidelity builds solve both the testing problem and the gradual rollout problem. A new version of colors wouldn’t get picked up by an aws-cdk install until the aws-cdk authors had gotten a chance to test it and push a new version configuration in a new version of aws-cdk. At that point, all new aws-cdk installs would get the new colors, but all the other tools would still be unaffected, until they too tested and officially adopted the new version of colors.」</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「2021年回顧，因為 DB 的效能的爭論所以我女友跟我分手了....」]]></title>
        <id>https://hwchiu.com/2022/01/10/reading-notes-4</id>
        <link href="https://hwchiu.com/2022/01/10/reading-notes-4"/>
        <updated>2022-01-10T00:05:07.000Z</updated>
        <summary type="html"><![CDATA[「2021年回顧，因為 DB 的效能的爭論所以我女友跟我分手了....」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「2021年回顧，因為 DB 的效能的爭論所以我女友跟我分手了....」
類別: usecase
連結: <a href="https://ottertune.com/blog/2021-databases-retrospective/" target="_blank" rel="noopener noreferrer">https://ottertune.com/blog/2021-databases-retrospective/</a></p><p>摘要:</p><p>2021 對於 DB 行業來說發生了許多風風雨雨，作者列出幾個觀察到的現象並且給予一些評論</p><p>「Dominance of PostgreSQL」
愈多愈多的人開發一個新的應用程式時首選都是 PostgreSQL 這個穩定可信賴且一直不停加入新功能的資料庫。
2010 年時 PostgreSQL 的開發團隊決定採取更為激進的方式來每年都要釋出一個主要版本的演進，其相容性的能力使得 PostgreSQL 能夠跟很多系統整合。
譬如前端介面如 Amazon Aurora, YugaByte, Yellowbrick 甚至 Google 都於 2021/10 宣布要讓 Cloud Spanner 支援 PostgreSQL</p><p>作者也嘗試從 Database Subreddit 上去爬文搜尋，基於過去一年所有發文去統計每個資料庫的出現次數，以結論來看 PostgreSQL -&gt; MySQL -&gt; MongoDB -&gt; Oracle -&gt; SQLite 等
這個過程不是非常嚴謹的統計分析，只是一個簡單的方式去觀察該論壇上大家都喜歡討論什麼資料庫而已。</p><p>「Benchmark Violence」
Benchmark 一直以來都是各個廠商展示軍火的地方，想辦法利用這些數據去說服大眾自己才是最棒的，作者列出去年三個激烈的 benchmark 討論</p><ol><li>Databricks vs. Snowflake</li><li>Rockset vs. Apache Druid vs. ClickHouse</li><li>ClickHouse vs. TimescaleDB</li></ol><p>作者也有參與上述血流成河的 Benchmark 的戰場，但是這些爭論的過程中作者失去了不少朋友，甚至連女朋友也一起離開了，作者回過頭來看這一切都
不值得，此外由於現在雲端的 DBMS 也有許多可最佳化的參數，要直接去比較彼此的優劣其實沒有這麼簡單。</p><p>後面還有「Big Data, Big Money」以及「In Memoriam」 兩個不同的議題，有興趣的可以點選全文閱讀</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「使用 OpenKruise v1.0 提供更進階的 workload 部署與升級」]]></title>
        <id>https://hwchiu.com/2022/01/09/reading-notes-3</id>
        <link href="https://hwchiu.com/2022/01/09/reading-notes-3"/>
        <updated>2022-01-09T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「使用 OpenKruise v1.0 提供更進階的 workload 部署與升級」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「使用 OpenKruise v1.0 提供更進階的 workload 部署與升級」
類別: tool
連結: <a href="https://www.cncf.io/blog/2021/12/23/openkruise-v1-0-reaching-new-peaks-of-application-automation/" target="_blank" rel="noopener noreferrer">https://www.cncf.io/blog/2021/12/23/openkruise-v1-0-reaching-new-peaks-of-application-automation/</a></p><p>Openkruise 1.0 版本釋出，該專案是 CNCF 沙盒層級的專案，主要是由阿里巴巴開發與維護，不久前的 Kubeconf 中阿里巴巴的議題也有
分享到有將此專案部署到期內部的 Kubernetes 管理平台</p><p>該專案主要是強化 Kubernetes 內應用程式的自動化，包含部署，升級，維運等面向，此外其架構是基於 Operator 去設計的，因此任何的 Kubernetes 叢集都可以安裝這個功能。
相對於原生的 Deployment 等部署方式， Openkruise 提供了</p><ol><li>強化 workloads 的部署方式，包含支援原地更新，金絲雀等不同的升級策略。</li><li>Sidecar 容器的管理，可以更方便地去定義想要自動掛到不同 workloads 上的 sidecar 容器。</li><li>提供更多方便維運的功能，譬如可以針對 container 進行重啟，可以針對不同節點進行先行下載 container image，將一個應用程式給部署到多個 namespace 甚至還可以
去定義 Pod 裏面所有 containers 的啟動優先順序，如果 Pod 內的容器彼此之間有依賴性時就可以透過這個功能讓整個啟動過程更加順暢。</li></ol><p>有興趣的可以研究看看此專案</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「透過 Kubefarm 來自動化幫實體機器打造基於 Kubernetes in Kubernetes 的 Kubernetes 環境」]]></title>
        <id>https://hwchiu.com/2022/01/07/reading-notes-2</id>
        <link href="https://hwchiu.com/2022/01/07/reading-notes-2"/>
        <updated>2022-01-07T00:05:08.000Z</updated>
        <summary type="html"><![CDATA[「透過 Kubefarm 來自動化幫實體機器打造基於 Kubernetes in Kubernetes 的 Kubernetes 環境」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「透過 Kubefarm 來自動化幫實體機器打造基於 Kubernetes in Kubernetes 的 Kubernetes 環境」
類別: Kubernetes
連結: <a href="https://kubernetes.io/blog/2021/12/22/kubernetes-in-kubernetes-and-pxe-bootable-server-farm/" target="_blank" rel="noopener noreferrer">https://kubernetes.io/blog/2021/12/22/kubernetes-in-kubernetes-and-pxe-bootable-server-farm/</a></p><p>摘要:
本篇文章要介紹 Kubefarm 這個專案，該專案的目的是希望能夠於大量的實體機器上去創建各式各樣的 Kubernetes 叢集供不同團隊使用
為了讓整體的運作更加自動化，作者先行介紹何謂 Kubernetes in Kubernetes 這個專案，如何透過 Kubeadm 的方式於一個現存的 Kubernetes 專案
去部署 control-plane 並且透過這個 control-plane 去控管其他的 kubernetes 叢集，基本上達到的效果就如同各種 kubernetes service 服務一樣，使用者完全看不到 control-plane 的元件。</p><p>雖然透過這個方式可以很輕鬆地去創建新的 Kubernetes 叢集來使用，但是使用上覺得還是不夠方便，特別是這些實體機器還是會有不少手動的過程要處理，
為了讓整體流程更加自動化，作者團隊又基於 Kubernetes in Kubernetes 這個專案為基礎再開發更上層的專案，稱為 Kubefarm，一個如農場般可以快速於實體機器創建各式各樣 kubernetes 叢集的解決方案</p><p>Kubefarm 由三個專案組成，分別是
Kubernetes in Kubernetes, LTSP (PXE-Server) 以及 Dnsmasq-Controller
透過這三者專案的結合，實體機器會自動取得 DHCP 的 IP 地址並且透過 PXE 系統自動化安裝 OS，待一切都安裝完畢後又會自動地加入到現存的 Kubernetes 叢集中</p><p>整篇文章滿長的，是一過非常有趣的用法與研究，如果團隊是大量實體非虛擬化機器的讀者可以研究看看別人遇到什麼問題以及透過何種思路去解決的。</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
        <category label="DEevOps" term="DEevOps"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Meta 如何打造一個供多團隊使用的 SLI/SLO 設定與觀測平台」]]></title>
        <id>https://hwchiu.com/2022/01/04/reading-notes-1</id>
        <link href="https://hwchiu.com/2022/01/04/reading-notes-1"/>
        <updated>2022-01-04T01:06:28.000Z</updated>
        <summary type="html"><![CDATA[「Meta 如何打造一個供多團隊使用的 SLI/SLO 設定與觀測平台」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「Meta 如何打造一個供多團隊使用的 SLI/SLO 設定與觀測平台」
類別: usecase
連結: <a href="https://engineering.fb.com/2021/12/13/production-engineering/slick/" target="_blank" rel="noopener noreferrer">https://engineering.fb.com/2021/12/13/production-engineering/slick/</a></p><p>本篇文章是 Meta 公司的技術分享文，探討內部如何搭建一個觀測 SLO 的大平台，讓不同的應用程式團隊都可以更方便地去觀察是否有達到其設定的 SLO。</p><p>文章內容有點長，這邊稍微節錄一些重點，非常推薦大家花點時間看完全文</p><ol><li>Meta 的產品多，同時規模又大，背後又有數千的工程師不停地部署新版本，因此維運團隊必須要有一個好的方式來維運這些服務，包含預期狀態，當前狀態以及有能力去分析問題。</li><li>團隊決定從 SLI/SLO 為基準點去設定預期狀態以及量測所有服務的效能。</li><li>團隊決定打造一個名為 SLICK 的系統來視覺化與控管所有服務的 SLI/SLO</li><li>沒有 SLICK 以前，每個服務的團隊都有各自的處理與儲存方式，所以都要花費很多時間去研究每個開發團隊的文件與用法，整體工作效率會下降</li><li>過去的系統也沒有維護超過一週以上的資料，所以後續團隊也沒有辦法針對這些部分去分析。</li></ol><p>透過 SLICK 可以讓整個 Meta 達到</p><ol><li>每個服務都可以用一個統一的方式去定義 SLO</li><li>可以維持資料長達兩年且資料的細度達到每分鐘等級</li><li>有個標準化的視覺方式來呈現 SLI/SLO</li><li>定期地將當前服務狀態發送到內部群組，讓團隊可以用這些報告來檢視服務的穩定度並進行改善</li></ol><p>文章後半部分包含</p><ol><li>SLICK 用法介紹，包含 UI 的呈現樣子，定期的報告內容以及相關的 CLI 介紹</li><li>SLICK 的架構，團隊是如何設計 SLICK 這個服務，用到哪些元件以及這些元件之間個溝通流向</li><li>兩個使用 SLICK 來改善穩定度的案例，這兩個案例都有簡單的去識別化，主要是介紹這些團隊發生什麼問題，如何透過 SLICK 來改善以及改善後的效能。</li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="DevOps" term="DevOps"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「多年工作經驗總是搞砸電話面試， why ?」]]></title>
        <id>https://hwchiu.com/2022/01/03/reading-notes</id>
        <link href="https://hwchiu.com/2022/01/03/reading-notes"/>
        <updated>2022-01-03T04:34:49.000Z</updated>
        <summary type="html"><![CDATA[「多年工作經驗總是搞砸電話面試， why ?」]]></summary>
        <content type="html"><![CDATA[<p>標題: 「多年工作經驗總是搞砸電話面試， why ?」
類別: 其他
連結: <a href="https://kevin.burke.dev/kevin/phone-screens-broken/" target="_blank" rel="noopener noreferrer">https://kevin.burke.dev/kevin/phone-screens-broken/</a></p><p>本篇是一個面試經驗探討文，作者闡述自己雖然已經有十年多的工作經驗，但是部分面試工作上還是沒有很辦法的去展現自己的能力
特別是那些用電話面試的經驗，而此文就是關於電話面試的小小抱怨文</p><p>滿多的電話面試都會搭配 Coderpad 這個網站來要求面試者線上進行程式撰寫，而該網站就要求你使用線上編輯器並且將所有的程式碼都統一到一個檔案中
，同時也不一定有辦法去撰寫相關的測試規則，這對於作者來說非常不喜歡。
作者平常習慣開啟多個視窗進行開發，一邊撰寫程式一邊透過測試來驗證當前撰寫的程式是否往正確的方向前進，同時也花費大量時間去調整自己喜歡的工具來輔助所有
程式碼的撰寫。而上述所有習慣都沒有辦法於 Coderpad 的單一編輯器上去完成。
此外面試過程中還會被問各種問題，譬如為什麼這個變數這樣命名，為什麼blablabla... 對於作者來說，有些概念要到快完成時才會最佳化，就很明顯不符合電話面試這種要一次完美的特色。</p><p>最後作者也分享了一下關於電話面試的問題想法，相較於問一些實際上工作根本用不到的演算法問題，不如問一些更貼切真正工作會用到的經驗與概念，譬如</p><ol><li>給面試者看一段 opensource 專案產生的 stack trace, 問問面試者能不能從這個 trace 看得出來大概可能是什麼問題</li><li>如果你開啟一個 database transaction 過久，有可能會發生什麼問題?</li><li>寫檔案到硬碟如果每次都只有寫一個 byte, 這可能會帶什麼樣的壞處?</li><li>給定一個函數，請面試者描述會如何針對這個函式去寫測試案例</li></ol><p>這讓我想到多年前也有接過電話面試直接問我 Linux 用幾個bit實作權限，但是面試官本身也非這個專頁，是哪個權限也沒辦法回答，也不能給清楚的 context，就如同教科書一樣一個問題一個答案，沒辦法針對面試者的疑問去解惑...</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[系統設計文，探討交友app背後的設計理念]]></title>
        <id>https://hwchiu.com/2021/12/29/system-dating-app</id>
        <link href="https://hwchiu.com/2021/12/29/system-dating-app"/>
        <updated>2021-12-29T18:29:14.000Z</updated>
        <summary type="html"><![CDATA[以 Tinder 為範例去探討交友軟體背後的設計原理]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://medium.com/.../dating-application-system-design" target="_blank" rel="noopener noreferrer">https://medium.com/.../dating-application-system-design</a>...
本篇是一個系統設計文，探討設計一個如 Tinder 的應用程式該如何去思考整體架構</p><p>Tinder 這種交友應用程式有幾個特點</p><ol><li>透過 FB 走 OAuth 登入</li><li>左滑右滑</li><li>配對機制</li><li>聊天對話</li><li>通知功能
其中 (3) 這個特色是說當使用者開啟 app 之後系統要根據一系列的條件們去推薦可能的對象，條件包含很多</li><li>從 FB 中抓到的個人資料，喜好等</li><li>地理位置，通常這類型的交友軟體都可以設定希望對象與自己的距離，譬如 10km 內， 50 km 內。
同時這類型的交友軟體支援多語言，支援多語言基本上就是意味多地區，簡單的說法可以說支援全世界不同地區的使用者共同使用，
因此基於效能考量上，通常不會使用單獨使用一個地區的伺服器來提供全球的服務，取而代之的則劃分地區讓每個地方都有一個稍微近的伺服器可以使用。
所以整體架構上還需要考量這類型的分散式架構設計，特別是有一些交友軟體還支援切換地點的功能，使用者可以切換到不同地區去匹配
不同地區的使用者，這意味該使用者的資料也會需要同步到不同地區的伺服器之間，因此資料部分也需要特別注意處理。
接下來就是當使用者希望配對範圍 100km 的使用者，該功能到底該如何實作，要如何將實體的地理位置劃分出來並且有辦法根據該敘述， 100km 內的使用者進行配對。
文章內有針對這部分進行詳細解釋，如何拆分不同的小區塊然後如何後續處理，有興趣的可以參閱全文</li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="SystemDesign" term="SystemDesign"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021-年度回顧]]></title>
        <id>https://hwchiu.com/2021/12/29/2021-review</id>
        <link href="https://hwchiu.com/2021/12/29/2021-review"/>
        <updated>2021-12-29T10:10:00.000Z</updated>
        <summary type="html"><![CDATA[2021 Review]]></summary>
        <content type="html"><![CDATA[<p>疫情肆虐下的 2021 年即將結束，按照慣例來個年度回顧紀錄。
這一整年完全遠端工作，算是人生經驗中非常不同的一年，台灣副業今年的發展也稍微多一點，不過整體演講數量就有明顯下降</p><h1>2021 回顧</h1><ul><li><a href="https://www.facebook.com/technologynoteniu" target="_blank" rel="noopener noreferrer">粉絲頁 - 矽谷牛的耕田筆記</a>發文: 199 篇，發文數量比預估(183)篇還要多，整體來說學到很多東西不過也花了很多時間在閱讀與分享。</li><li><a href="https://ithelp.ithome.com.tw/users/20120317/ironman/4034" target="_blank" rel="noopener noreferrer">Ithome 鐵人賽</a>發文: 30 篇，這次的主題圍繞於 Rancher &amp; GitOps 的介紹，最後也很榮幸的獲得了佳作。</li><li><a href="https://www.hwchiu.com/about/" target="_blank" rel="noopener noreferrer">演講</a>紀錄: 3 篇。整年度的演講數量下降，跨時區的限制實在不方便每次半夜四點起來參與台灣社群，比較特別是的參與 <a href="https://blog.hiskio.com/hiexpert-2021-devops/" target="_blank" rel="noopener noreferrer">HiEXPERT 2021 DevOps 領航者論壇</a> 的討論分享。</li><li>部落格原創文章: 6 篇，想寫的很多，時間不夠多...</li><li><a href="https://course.hwchiu.com/#price" target="_blank" rel="noopener noreferrer">線上課程</a>: 2 門課程，今年本來想要把 Networking 系列一口氣弄完的，沒有預期的順利，時間忙碌。<ul><li>線上課程包的線上演講: 2 次，這是個一整年的計畫，每個月給課程內的學生有一次分享，還有十次才結束。</li></ul></li><li><a href="https://course.hwchiu.com/#books" target="_blank" rel="noopener noreferrer">書籍出版</a>: 1 本，人生第一本實體書籍，因應鐵人賽的結果很順利的就體驗了出書的過程。</li><li>運動回歸: 因應疫情荒廢一年多的運動習慣直到有兩劑疫苗後才重新復活，直至年底整個運動表現有整體回溫，不過年底膝蓋有點小傷所以又要好好休養一下<ul><li>硬舉: 210 kg</li><li>臥推: 125 kg</li><li>深蹲: 170 kg</li><li>肩推: 75 kg</li></ul></li><li>新技能學習: 今年開始認真學習並且繼續鑽研的技術是舉重，先從抓舉開始練習並且養成瑜伽的習慣來加強活動度與柔軟度</li><li>企業教育訓練: 1 次，年尾很驚訝的收到一個企業教育訓練的機會，看看有沒有機會讓這個也變成常態服務</li><li>長時間出遊: 3 次，下半年去了芝加哥, Reno 以及西雅圖度假放鬆，體驗不同生活。</li></ul><h1>2022 展望</h1><ul><li>保持運動習慣，想把體重給降回到 7 字頭了</li><li>書籍，課程: 量力而為</li><li>原創文章: 花更多時間到這一塊</li><li>粉絲頁: 繼續多閱讀多分享，藉由閱讀逼迫自己學習一些平常碰不到的東西</li><li>生活順遂: 工作之餘還是要定期放鬆旅遊</li></ul>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="AnnualReview" term="AnnualReview"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Cloud Design Pattern] - Ambassador 模式]]></title>
        <id>https://hwchiu.com/2021/12/27/cloud-pattern-ambassador</id>
        <link href="https://hwchiu.com/2021/12/27/cloud-pattern-ambassador"/>
        <updated>2021-12-27T22:52:08.000Z</updated>
        <summary type="html"><![CDATA[Cloud Design Pattern]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://docs.microsoft.com/.../archit.../patterns/ambassador" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/.../archit.../patterns/ambassador</a></p><p>微軟文件中的系列好文，探討雲端方面的各種設計模式，而本篇探討的是 Ambassador 模式
想法:</p><ol><li>想要提供更多進階的網路功能到應用程式上，譬如 TLS、circuit、breaking、routing 或 metering。</li><li>應用程式不太方便修改來符合上述功能。</li><li>部署一個跟原應用程式相鄰的應用程式來處理這些網路功能。
應用程式過於古老，團隊沒有辦法進行深度修改或是團隊中的應用程式使用過多的語言與框架完成，很難簡易的將這些功能給導入到既有的應用程式中
這時候部署一個全新的應用程式就可以再不修改既有應用程式的前提下來提供這些進階的網路功能。
這個模式普遍被稱為 ambassador 模式，而本篇文章就是針對該模式進行一個科普概念。
文章最後還要探討使用這種模式的一些注意事項，譬如網路的延遲會因為多一個應用程式而提升，所以使用上也要評估看看是否合適。
也有簡單的列出什麼情況適合使用 ambassador 什麼情況不適合。</li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="CloudNative" term="CloudNative"/>
        <category label="DesignPattern" term="DesignPattern"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[是時候停止使用 python 3.6]]></title>
        <id>https://hwchiu.com/2021/12/25/stop-python-36</id>
        <link href="https://hwchiu.com/2021/12/25/stop-python-36"/>
        <updated>2021-12-25T18:55:55.000Z</updated>
        <summary type="html"><![CDATA[3.6即將停止支援，相關應用記得升級]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://pythonspeed.com/articles/stop-using-python-3.6/" target="_blank" rel="noopener noreferrer">https://pythonspeed.com/articles/stop-using-python-3.6/</a></p><p>本部落格是一個基於 Python &amp; Container 的系列介紹文，而本篇文章是其中一篇探討容器化 Python 要注意的事項。
標題非常簡單：「是時候停止使用 python 3.6了」
Python 3.6 的 EOL 時間就剛好是 2021/12，這也意味到 2022 年後 python 3.6 就不再享受官方的任何維護與更新。
文章中提到建議趕快升級，同時也要注意不要每次都拖到最後一刻才升級相關軟體，應該要把升級軟體的流程給整合到日常流程中，定期掃描定期更新，
否則只會不停的被不同版本的 EOL 追趕而已。</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Python" term="Python"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[工作20 餘年的軟體架構經驗談]]></title>
        <id>https://hwchiu.com/2021/12/22/software-experience</id>
        <link href="https://hwchiu.com/2021/12/22/software-experience"/>
        <updated>2021-12-22T21:23:11.000Z</updated>
        <summary type="html"><![CDATA[他人經驗談，非常強大]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://coolshell.cn/articles/21672.html" target="_blank" rel="noopener noreferrer">https://coolshell.cn/articles/21672.html</a>
本篇文章是作者工作 20 年來的經驗分享文，內容非常好，提出了很多不同的觀點，由於是篇中文文章，所以就不幫忙節錄重點，直接列
文章中的十一個原則標題。
每個原則都非常精彩，文章底下的討論也滿有趣的。
原则一：关注于真正的收益而不是技术本身
原则二：以应用服务和 API 为视角，而不是以资源和技术为视角
原则三：选择最主流和成熟的技术
原则四：完备性会比性能更重要
原则五：制定并遵循服从标准、规范和最佳实践
原则六：重视架构扩展性和可运维性
原则七：对控制逻辑进行全面收口
原则八：不要迁就老旧系统的技术债务
原则九：不要依赖自己的经验，要依赖于数据和学习
原则十：千万要小心 X – Y 问题，要追问原始需求
原则十一：激进胜于保守，创新与实用并不冲突</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Linux" term="Linux"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dockerfile 內 Shell/Exec 的用法差異]]></title>
        <id>https://hwchiu.com/2021/12/21/docker-shell-exec</id>
        <link href="https://hwchiu.com/2021/12/21/docker-shell-exec"/>
        <updated>2021-12-21T17:18:28.000Z</updated>
        <summary type="html"><![CDATA[Docker 基本介紹文，不知道常寫 Dockerfile 的讀者能不能分清楚 Dockerfile 內 Shell 與 Exec 兩種格式的差異]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://emmer.dev/blog/docker-shell-vs.-exec-form/" target="_blank" rel="noopener noreferrer">https://emmer.dev/blog/docker-shell-vs.-exec-form/</a></p><p>Docker 基本介紹文，不知道常寫 Dockerfile 的讀者能不能分清楚 Dockerfile 內 Shell 與 Exec 兩種格式的差異
RUN, CMD, ENTRYPOINT 等指令都同時支援這兩種格式
Shell 格式就是 RUN command arg1 arg2 arg3 這種直接描述的格式，而 Exec 則是用 [] 包起來，每個參數單獨敘述，譬如
RUN <!-- -->["command", "arg1", "arg2", "arg3"]<!-- --> 等。
本篇文章推薦 RUN 指令採取 Shell 格式而 CMD/ENTRYPOINT 都應該採用 EXEC 格式。
如果自己不清楚差異以及沒有想法為什麼平常自己這麽寫的話可以參考全文</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Docker" term="Docker"/>
        <category label="Linux" term="Linux"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bash 下要如何處理 Signal]]></title>
        <id>https://hwchiu.com/2021/12/19/bash-trap</id>
        <link href="https://hwchiu.com/2021/12/19/bash-trap"/>
        <updated>2021-12-19T23:03:36.000Z</updated>
        <summary type="html"><![CDATA[Bash 下 Signal 的各種介紹]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://linuxconfig.org/how-to-propagate-a-signal-to-child-processes-from-a-bash-script" target="_blank" rel="noopener noreferrer">https://linuxconfig.org/how-to-propagate-a-signal-to-child-processes-from-a-bash-script</a></p><p>基本 Bash 介紹文，探討 trap 的用法，如何於不同的情況下正確攔截 SIGNAL，同時如果 script 中運行的程式有無背景執行
會有什麼差異，推薦給對 Bash 不熟的讀者閱讀重新複習</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Linux" term="Linux"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Infrastructure 各種踩雷經驗]]></title>
        <id>https://hwchiu.com/2021/12/13/infra-mistakes</id>
        <link href="https://hwchiu.com/2021/12/13/infra-mistakes"/>
        <updated>2021-12-13T21:29:39.000Z</updated>
        <summary type="html"><![CDATA[連結//matduggan.com/mistakes/]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://matduggan.com/mistakes/" target="_blank" rel="noopener noreferrer">https://matduggan.com/mistakes/</a></p><p>本文是作者踩過的各種 Infrastructure 雷，希望讀者能夠避免這些雷。</p><p>總共有幾大類，分別</p><ol><li>Don't migrate an application from the datacenter to the cloud</li><li>Don't write your own secrets system</li><li>Don't run your own Kubernetes cluster</li><li>Don't Design for Multiple Cloud Providers</li><li>Don't let alerts grow unbounded</li><li>Don't write internal cli tools in python</li></ol><p>其中第六點簡短扼要，大概就是「沒有人知道如何正確地去安裝與打包你的 python apps, 你真的要寫一個內部的 python 工具就給我讓他完全跨平台不然就給我改用 go/rust, 不要浪費生命去思考到底該如何安裝那些東西」</p><p>這讓我想到你的 Python 跟我的 Python 每次都不一樣，有已經不支援的 python 2.x, 還有各種可能會互相衝突的 python 3.x....</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Kubernetes" term="Kubernetes"/>
        <category label="Ubuntu" term="Ubuntu"/>
        <category label="Linux" term="Linux"/>
        <category label="Network" term="Network"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[建置 Container Image 中的 Anti-Patterns]]></title>
        <id>https://hwchiu.com/2021/12/12/docker-build-anti-pattern</id>
        <link href="https://hwchiu.com/2021/12/12/docker-build-anti-pattern"/>
        <updated>2021-12-12T00:25:23.000Z</updated>
        <summary type="html"><![CDATA[建置 Container Image 的錯誤方式。]]></summary>
        <content type="html"><![CDATA[<p>ref: <a href="https://jpetazzo.github.io/2021/11/30/docker-build-container-images-antipatterns/" target="_blank" rel="noopener noreferrer">https://jpetazzo.github.io/2021/11/30/docker-build-container-images-antipatterns/</a></p><p>本篇文章分享的是建置 Container 中的 Anti-Patterns，不講哪些好反而探討哪些不好。</p><p>文內列舉了不同的主題，包含</p><ol><li>Big images<ul><li>All-in-one mega images</li><li>Data sets</li></ul></li><li>Small images</li><li>Rebuilding common bases</li><li>Building from the root of a giant monorepo</li><li>Not using BuildKit</li><li>Requiring rebuilds for every single change</li><li>Using custom scripts instead of existing tools</li><li>Forcing things to run in containers</li><li>Using overly complex tools</li><li>Conflicting names for scripts and images</li></ol><p>以下針對內文幾個部分摘錄一下為什麼作者認為是個不好的模式</p><h1>Small Images</h1><p>Image 小本身不是什麼問題，但是有時候過度追求容量會使得一些常用有幫助的工具沒有辦法於容器內執行，這可能會導致未來要除錯時要花費更多的時間去處理，可能要研究如何重新安裝該工具等。</p><p>作者有強調這個議題是非常看環境與需求的，有些情況可能團隊根本不需要進入到容器內去執行 shell 來處理，有些可能會需要到容器內執行 ps, netstat, ss 等指令來觀察不同狀態。
作者推薦可以使用 gcr.io/distroless/static-debian11 這個 image 做為基礎然後將其之間的 busybox 給複製環境中，至少確保有基本工具可以使用</p><h1>Not using BuildKit</h1><p>BuildKit 是 docker build 的新版建置方式，相對於舊版方式來說 Buildkit 提供了更多功能，譬如平行建置，跨平台建置甚至效能上也會比過往的更好。
為了讓舊有使用者可以無痛轉移，所以 BuildKit 完全相容既有的 Dockerfile 的語法，所以切換方面是完全無腦的。
目前新版的 Docker Desktop 基本上已經預設採用 BuildKit 來進行建置，不過某些系統譬如 Linux 的環境下，還是需要透過設定環境變數來啟用這個功能，譬如 DOCKER_BUILDKIT=1 docker build . 等方式來建置。</p><p>此外透過 BuildKit 建置的產生結果跟過往不同，所以只要看建置結果的輸出就可以判別自己是否使用 BuildKit。</p><p>剩下的8個項目就留給有興趣的讀者自行閱讀</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Container" term="Container"/>
        <category label="Docker" term="Docker"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[又一個 0-day...]]></title>
        <id>https://hwchiu.com/2021/12/11/log4j-cve</id>
        <link href="https://hwchiu.com/2021/12/11/log4j-cve"/>
        <updated>2021-12-11T21:14:29.000Z</updated>
        <summary type="html"><![CDATA[Java 常見套件 log4j CVE]]></summary>
        <content type="html"><![CDATA[<p>相關介紹: <a href="https://www.lunasec.io/docs/blog/log4j-zero-day/" target="_blank" rel="noopener noreferrer">https://www.lunasec.io/docs/blog/log4j-zero-day/</a></p><p>歷史講古: <a href="https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/" target="_blank" rel="noopener noreferrer">https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/</a></p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="CVE" term="CVE"/>
        <category label="Java" term="Java"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「三個加強 Kubernetes 服務穩定性的經驗」]]></title>
        <id>https://hwchiu.com/2021/12/10/reading-note-21</id>
        <link href="https://hwchiu.com/2021/12/10/reading-note-21"/>
        <updated>2021-12-10T22:29:51.000Z</updated>
        <summary type="html"><![CDATA[三個加強 Kubernetes 服務穩定性的經驗]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://medium.com/kudos-engineering/increasing-resilience-in-kubernetes-b6ddc9fecf80" target="_blank" rel="noopener noreferrer">https://medium.com/kudos-engineering/increasing-resilience-in-kubernetes-b6ddc9fecf80</a></p><p>今天這篇文章作者跟大家分享一些如何加強 Kubernetes 服務穩定的方式，這篇文章這邊做個簡單摘要一下
發生問題:
作者的 k8s 是基於 Google Kubernetes Service (GKE)的叢集，運作過程中有時候會發現部分節點當掉，最後導致部分的服務不能正確使用。這邊作者團隊從兩個角度出發去改善</p><ol><li>研究為什麼節點會一直當掉，與 Google Supporte Team 來回信件最後有找到問題點</li><li>強化 Kubernetes 服務的韌性，就算有部分節點壞掉也要讓服務能夠繼續運行
，本文主要的一些觀點也都是基於這邊發展
強化方式</li><li>修正 Deployment 的數量，並且加上 Anti-Affinity，讓這些 Deployment 的副本能夠散落到不同的節點上，避免所有 Pod 都塞到同個節點，最後該節點出問題導致 Pod 全部出問題。</li><li>所有需要被 Service 存取的服務都加上 Readess Probe 來確保這些服務都準備好後才會收到服務，避免一些請求被送過來確又不能正確處理</li><li>加入 Pre-Stop 的使用，再裡面透過 sleep 10的方式，讓 Pod 要被刪除能夠將手上的封包請求給處理完畢
(請看註解補充)
註: 我個人認為第三點其實不太需要，比較漂亮的作法應該是實作 Singal Handler 去處理 SIGTERM 的訊號，收到此訊號後就不要再接受任何 Request 並且把剩下的工作處理完畢，當然如果這部份處理的時間過長，超過預設的 GracePeriod (30sec)，就會被 SIGKILL 給強制刪除。
要解決這個問題可能就要從應用程式下手去看如何改善，或是透過修改 Pod Spec 來提昇 GracePeriodTemination 的長短</li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「DNS 5 秒 Dealy 的緣由」]]></title>
        <id>https://hwchiu.com/2021/12/08/reading-note-20</id>
        <link href="https://hwchiu.com/2021/12/08/reading-note-20"/>
        <updated>2021-12-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「DNS 5 秒 Dealy 的緣由」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://www.weave.works/blog/racy-conntrack-and-dns-lookup-timeouts" target="_blank" rel="noopener noreferrer">https://www.weave.works/blog/racy-conntrack-and-dns-lookup-timeouts</a></p><p>今天跟大家分享一個 UDP 於 Linux Kernel 內的 Race Condition 問題。這問題我以前於 Linux Kernel 3.14 也有採過一樣的雷，但是到今日都還沒有一個很漂亮的解決方案，這邊就快速的跟大家介紹一下這個問題&gt;
是什麼，以及跟 k8s 有什麼關係</p><h1>發生前提</h1><ol><li>使用 UDP 這種沒有重送機制的協定</li><li>Kernel 有開啟 conntrack 此功能</li></ol><h1>發生條件</h1><p>相同的 Client 短時間內透過 UDP (也許是不同 thread) 送出兩個 UDP 封包到外面，對於 Linux Kernel 來說，會希望透過 conntrack 來追蹤每一條連線，但是底層建立的時候會有一些會有一些機制，因此當兩個封
包同時進入的時候，有可能就會因為先後順序導致第二個封包被丟棄</p><h1>可能發生問題</h1><p>DNS 的請求封包預設情況下會同時透過 UDP 送出 A &amp; AAAA 兩個封包，而這兩個封包如果很巧的採到這個情況，然後你的 A 封包就沒有辦法順利解出 DNS，最後就要等五秒的 timeout 來重新發送
下偏這篇文章就是 weave works 遇到 DNS 5秒 timeout 的問題，然後仔細的將我上面所寫的總結給解釋清楚，每一個步驟發生什麼事情，什麼是 conntrack 以及暫時的 workaround 是什麼
之後會在跟大家分享目前一些解決方法怎麼做</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Network" term="Network"/>
        <category label="Linux" term="Linux"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Kubernetes Resource Limit/Request 誤用造成的錯誤」]]></title>
        <id>https://hwchiu.com/2021/12/06/reading-note-19</id>
        <link href="https://hwchiu.com/2021/12/06/reading-note-19"/>
        <updated>2021-12-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「Kubernetes Resource Limit/Request 誤用造成的錯誤」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://itnext.io/how-to-set-kubernetes-resource-requests-and-limits-a-saga-to-improve-cluster-stability-and-a7b1800ecff1" target="_blank" rel="noopener noreferrer">https://itnext.io/how-to-set-kubernetes-resource-requests-and-limits-a-saga-to-improve-cluster-stability-and-a7b1800ecff1</a></p><p>今天這篇文章探討的則是 resources 底下的 request/limit 問題。
本文作者之前遇到一個非常規律的服務警告問題，花了非常多時間與步驟去查詢，最後才發現是 Pod 裡面 Resource 的設定不夠嚴謹與完善。
舉例來說，
resources:
limit: cpu: 1000m
request: cpu: 100m
今天假設有一個服務描述，我對 cpu 的最低要求是 0.1顆，但是極限是 1顆
且有一個節點本身有 3 顆 CPU，這種情況下，我們對該服務設定多副本運行(10個). 那根據 request 的要求，10個副本頂多只需要 1 顆 cpu，所以非常輕鬆的可以將 10 個服務運行起來，但是如何今天遇到尖峰流量
，每個 pod 都瘋狂使用 CPU會發生什麼事情？
每個副本的極限都是 1 顆，因此 10 個副本就可以衝到 10 顆 CPU..而系統上只有 3顆，這就會造成 CPU 完全不夠使用，最後導致每個應用程式都在搶 CPU 使用，如果沒有特別設定相關的 nice 值來處理，可能會造
成關鍵 process 無法回應(案例中就是kubelet)。
這案例中 limit/request = 10x，作者認為這數字太大，它覺得合理的大概是 2x ~ 5x，並且最重要的是要定期去檢視系統上資源的用量， limit 要設定的合理，如果本身有很大量需求，建議還要搭配 node select,
affinity/anti-affinity 讓每個 pod 最好找到適合的配置方式，然後也要避免尖峰流量到來時，系統資源被吃光甚至影響到 kubelet/kube-proxy 等底層服務的運作。</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
        <category label="ResourceManagement" term="ResourceManagement"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Container Image 的儲存挑戰」]]></title>
        <id>https://hwchiu.com/2021/12/03/reading-note-18</id>
        <link href="https://hwchiu.com/2021/12/03/reading-note-18"/>
        <updated>2021-12-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「Container Image 的儲存挑戰」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://medium.com/flant-com/cleaning-up-container-images-with-werf-ec35b5d46569" target="_blank" rel="noopener noreferrer">https://medium.com/flant-com/cleaning-up-container-images-with-werf-ec35b5d46569</a></p><p>不知道大家有沒有遇過本地儲存空間滿了，再也抓不了 docker image 的慘痛經驗呢？ 本文就想要探討的是遠方 Container Image 上的管理問題，隨者時間演進，愈來愈多的版本產生，那作為管理者，我們要怎麼去&gt;
看待這些 image，放任他們無限擴張嘛？ 這些資源背後都代表一個儲存空間，也就意味額外的成本開銷。
作者想要解決的問題是，如何設計一套自動機制去刪除用不到的 image tag，保留會用到的，為了解決這個問題，要先定義什麼叫做 "用得到的 image tag".
本文列舉了四種需要保留 image tag的情況
1) Production 環境正在使用的 image tag, 如果刪除了，遇到 ImagePullPolicy:Always 的情況那可真的麻煩了
2) 遇到緊急情況，應用程式需要退版，因此保留的 image tag 可不能只有當前版本，過往穩定版本也都要保留
3) 從開發角度來看需要的 image tag, 譬如我們開了一個 PR，這個 PR 有一個對應的 image tag, 再這個 PR 還沒有結束前，這個 image tag 應該都要保留讓開發者去驗證與使用
4) 最後則是特定版本號或是code name等專屬名稱
作者使用 werf 這套 k8s 建置佈署工具來幫忙，這工具除了常見的 build/deploy 外，還可以刪除遠方的 container image。 因此作者整合一套演算法，將其與 werf 整合，讓整個 CI/CD 的過程中能夠自動去產生新
的 image，並且根據需求去移除用不到的 image.
有興趣的記得點選下列原文來學習更多</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Container" term="Container"/>
        <category label="Storage" term="Storage"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「使用 Open Policy Agent 來保護 Ingress 的誤用」]]></title>
        <id>https://hwchiu.com/2021/12/01/reading-note-17</id>
        <link href="https://hwchiu.com/2021/12/01/reading-note-17"/>
        <updated>2021-12-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「使用 Open Policy Agent 來保護 Ingress 的誤用」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://www.cncf.io/blog/2020/09/29/enforce-ingress-best-practices-using-opa/" target="_blank" rel="noopener noreferrer">https://www.cncf.io/blog/2020/09/29/enforce-ingress-best-practices-using-opa/</a></p><p>不知道大家有沒有聽過 Open Policy Agent (OPA) 這個 CNCF 專案?
有滿多專案的背後都使用基於 OPA 的語言 Rego 來描述各式各樣的 Policy，譬如可以使用 conftest 來幫你的 kubernetes yaml 檢查語意是否有符合事先設定的 Policy。
本篇文章則是跟大家分享如何使用 OPA 來針對 Ingress 資源進行相關防呆與除錯，一個最基本的範例就是如何避免有多個 Ingress 使用相同的 hostname 卻指向不同的 backend service. 過往可能都是靠人工去維護
，確保沒有一致的名稱，但是透過 OPA 的概念我們可以再佈署 Ingress 到 Kubernetes 前先進行一次動態的比對，確保當前設定符合所有 Policy，得到所謂的 Approved 後才能夠佈署進去。
有興趣的人可以看看這篇文章，甚至學習一下 OPA 的使用方式</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
        <category label="OPA" term="OPA"/>
        <category label="Network" term="Network"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「SCP 工具的注意事項」]]></title>
        <id>https://hwchiu.com/2021/11/30/reading-note-16</id>
        <link href="https://hwchiu.com/2021/11/30/reading-note-16"/>
        <updated>2021-11-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「SCP 工具的注意事項」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://lwn.net/Articles/835962/" target="_blank" rel="noopener noreferrer">https://lwn.net/Articles/835962/</a></p><p>LWN.net 這幾天有一個文章是關於基於安全性考量下，改用其他工具取代 scp, 譬如使用 sftp 以及 rsync.
有常常使用 scp 這個工具的人可以看一下這篇文章討論的原因，以及如果要改成使用 rsync, 可以有什麼樣的參數使用</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Linux" term="Linux"/>
        <category label="Security" term="Security"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「使用 k3s Rancher Vault and ArgoCD 來實作 GitOps」]]></title>
        <id>https://hwchiu.com/2021/11/28/reading-note-15</id>
        <link href="https://hwchiu.com/2021/11/28/reading-note-15"/>
        <updated>2021-11-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「使用 k3s Rancher Vault and ArgoCD 來實作 GitOps」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://adam-toy.medium.com/implementing-gitops-on-kubernetes-using-k3s-rancher-vault-and-argocd-f8e770297d3a" target="_blank" rel="noopener noreferrer">https://adam-toy.medium.com/implementing-gitops-on-kubernetes-using-k3s-rancher-vault-and-argocd-f8e770297d3a</a></p><p>這邊跟大家分享一篇 GitOps 實作心路歷程，這篇文章中總共使用下列工具</p><ol><li>AWS, 所有環境都基於 AWS 此 cloud provider</li><li>K3S, 一套由 Rancher 開發的輕量級 Kubernetes 發行版本</li><li>Rancher, 管理 K3S 介面</li><li>Cert-Manager, 與 Let's Encrypt 連動，管理相關憑證</li><li>Vault, Secret 管理工具</li><li>ArgoCD GitOps 使用工具，連動 Git Repo 與 K8s</li><li>Terraform, IaaC 的一種工具
這篇文章從頭開始介紹如何整合上述工具，並且完成一個簡易的範例，透過這些範例也讓你理解每個元件對應的功能，如何使用，共重要的是從一個大範圍的視角來看，這些元件的地位，更可以幫助你瞭解整體架構
有興趣的可以閱讀全文</li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="GitOps" term="GitOps"/>
        <category label="Rancher" term="Rancher"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「本地開發 Kubernetes 的各種選擇」]]></title>
        <id>https://hwchiu.com/2021/11/26/reading-note-14</id>
        <link href="https://hwchiu.com/2021/11/26/reading-note-14"/>
        <updated>2021-11-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「本地開發 Kubernetes 的各種選擇」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://www.dex.dev/dex-videos/development-clusters" target="_blank" rel="noopener noreferrer">https://www.dex.dev/dex-videos/development-clusters</a></p><p>不知道大家第一次接觸 kubernetes 的時候都是使用哪套解決方案來打造你的 K8s 叢集？ 亦或是作為一個開發者，你平常都怎麼架設 K8s 來本地測試?
這篇文章提到了作為一個 Local Kubernetes Cluster 幾個選擇，並且點出了三個需要解決的問題</p><ol><li>Container Registry, 作為一個開發環境，應該不會想要每次測試都要將 Container Image 給推到遠方，譬如 dockerHub, Quay，這樣整體效率低落</li><li>Builder, 如何有效率的幫忙建置你的應用程式，並且與 Kubernete 整合，讓開發者可以更專心於本地開發，而不要擔心太多 k8s 之間的設定
<a href="https://www.dex.dev/dex-videos/development-clusters" target="_blank" rel="noopener noreferrer">https://www.dex.dev/dex-videos/development-clusters</a></li><li>Runtime, 底層使用哪套 Container Runtime, 譬如 docker/containerd/cri-o
註: 我個人對第三點其實沒太多感覺，不覺得本地測試這個會影響太多
後面列舉了當前知名的相關專案，譬如 KIND, K3D, MicroK8S, Minikube 以及 Docker for desktop. 並且簡單的比較了一下這些本地開發的差異。
不知道大家平常本地開發時，都會用哪一套?
我個人是比較常使用 KIND 來測試，畢竟輕量化且同時支援多節點，環境也乾淨，測試起來也方便。</li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
        <category label="DevX" term="DevX"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「SO_REUSEPORT 提昇 Nginx 效能」]]></title>
        <id>https://hwchiu.com/2021/11/25/reading-note-13</id>
        <link href="https://hwchiu.com/2021/11/25/reading-note-13"/>
        <updated>2021-11-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「SO_REUSEPORT 提昇 Nginx 效能」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://blog.cloudflare.com/the-sad-state-of-linux-socket-balancing/" target="_blank" rel="noopener noreferrer">https://blog.cloudflare.com/the-sad-state-of-linux-socket-balancing/</a></p><p>今天要來跟大家分享一個單一節點如何提高應用程式吞吐量與服務能力的方式
這個方式主要探討的是應用程式對於網路連線的 I/O 模型，試想一個常見的使用範例。
一個主要的 Process 會去聽取一個固定的 port number (ex port 80)，並且通知後面眾多的 worker 來幫忙處理這些封包連線，而這些 worker 的工作就是處理連線。
整個架構中是一個 1 v.s N 的狀況， 一個負責 Listen ，N個負責處理連線內容
而今天要分享的則是想要讓架構變成 N v.s N 的狀況， 會有 N 個 Process, 每個 Process 配上一個 Worker。
而這 N個 process 同時共享一樣的 Port (ex, port 80)
這種情況下可以減少多個 worker 共享一個 listen socket 時的各種保護機制，取而代之的則是每個 listen socket 配上一個專屬的 worker 來處理。
要達成這樣的架構非常簡單，只要透過 SO_REUSEPORT 這個 socket option 告
訴 Kernel 當前這個 PORT 可以重複使用。
當封包送到 kernel 後則是由 kernel 幫你分配封包到所有使用相同地址的 Listen Socket (Process)
根據 nginx 官方文章的測試，這種架構下對於 RPS (Request per second) 有顯著的提升，有興趣的可以看看下列兩篇文章</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Network" term="Network"/>
        <category label="Performance" term="Performance"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Kubernetes 多租戶實作的挑戰」]]></title>
        <id>https://hwchiu.com/2021/11/24/reading-note-12</id>
        <link href="https://hwchiu.com/2021/11/24/reading-note-12"/>
        <updated>2021-11-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「Kubernetes 多租戶實作的挑戰」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://faun.pub/kubernetes-multi-tenancy-a-best-practices-guide-88e37ef2b709?gi=6e43dc5ed7a" target="_blank" rel="noopener noreferrer">https://faun.pub/kubernetes-multi-tenancy-a-best-practices-guide-88e37ef2b709?gi=6e43dc5ed7a</a></p><p>這邊跟大家分享一篇關於 Kubernetes 多租戶的相關文章，該文章中探討到底多租戶的定義，以及實現上的難易程度</p><ol><li>多租戶可分成軟性與硬性兩種隔離， Kubernetes namespace 可以視為軟性隔離，而硬性隔離則是希望能夠更強力的隔離所有資源，文章中提到了 vClusters 的概念，連結放在最後</li><li>作者認為多租戶的 Kubernetes Cluster 實際上也會帶來一些限制，讓某些功能變得不方便使用。
a. 基於 namespace 的租戶隔離方式就只能大家都同樣一個 k8s 版本，同時有一些支援 RBAC 設定的 Helm Chart 可能就不方便使用。</li><li>作者這邊反思提出一個問題，為什麼真的需要多租戶的 Kubernetes 叢集，不能夠用多個單一租戶的 Kubernetes 叢集來取代?
a. 真的有這樣的實例，但是其實成本過高且沒效率。
b. 如果公司內每個開發人員都需要一個自已的 k8s來操作測試，規模一大的話你每個月的成本非常可觀，因此如果可以有一個多租戶的 k8s，就可以解決這些問題</li><li>多租戶實作上的挑戰，作者這邊列出幾個問題，包含使用者管理，資源分配以及如何隔離
a.基本上每個組織本身都已經有管理使用者的解決方案，譬如 AD/LDAP 等，如果要將這些使用者的認證授權與 kubernetes 整合，推薦使用 dex 這個支持 OpneID/OAtuth2 的解決方案，幫你將 Kubernetes 與外&gt;
部資料系統整合
b. 底層資源的共享，避免單一租戶過度使用導致其他租戶不能使用。資源包含了運算資源，網路頻寬等。作者列出透過 Resource Quotas 等可以幫忙限制運算資源，但是並沒有說出網路頻寬這部份該怎麼處理。&gt;
這部份我認為需要導入更多的network qos解決方案來限制，應該會需要cni以及外部交換機路由器等來幫忙
c. 最後則是互動上的隔離，要如何確保這些多租戶不會互相影響彼此，甚至攻擊彼此。這部份可能要從 NetworkPolicy 來處理網路流量，同時透過 vCluster的方式來提供相對於 namespace層級更強烈的隔離，確
保彼此不會互相影響。</li><li>最後，作者列出了一些關於多租戶的可能解決方案，包含了 kiosk, loft等
結論來說就是，今天你如果有多租戶的需求，請先問自己，你需要什麼等級的多租戶管理，再來則是三個重點問題要先想清楚，你要怎麼處理
1) 如何管理使用者/租戶
2) 系統資源要如何分配與限制
3) 如何真正有效的隔離這些租戶
如果有這方面的需求，可以先看看別的開源軟體怎麼實作，再來思考是否滿足需求，如果要自己實現，有哪些好的設計值得參考!</li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Kubernetes manageFields 討論」]]></title>
        <id>https://hwchiu.com/2021/11/22/reading-note-11</id>
        <link href="https://hwchiu.com/2021/11/22/reading-note-11"/>
        <updated>2021-11-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「Kubernetes manageFields 討論」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://github.com/kubernetes/kubernetes/issues/90066?fbclid=IwAR3d3oXBtTz2ChxmqXQmLGIrghUxN3Tz67EYWZiuzNfltqVedAlFheg3qLA" target="_blank" rel="noopener noreferrer">https://github.com/kubernetes/kubernetes/issues/90066?fbclid=IwAR3d3oXBtTz2ChxmqXQmLGIrghUxN3Tz67EYWZiuzNfltqVedAlFheg3qLA</a></p><p>如果你機會跑過 kubernetes 1.18 版本，一定要試試看最基本的 kubectl get pods -o yaml，看看是不是內容裡面多出了非常多 f:{} 系列的檔案，導致整個 Yaml 變得非常冗長，閱讀不易，甚至想要抓取到最原始&gt;
的內容都非常麻煩。
Kubernetes 官方 Github 上還有相關的 issue 再討論這個欄位，詢問是否有辦法能夠清除。不少人都提出了一些希望的用法來處理
Issue: <a href="https://github.com/kubernetes/kubernetes/issues/90066" target="_blank" rel="noopener noreferrer">https://github.com/kubernetes/kubernetes/issues/90066</a>
目前看下來最簡單的做法還是透過 kubectl plugin, kubectl-neat 來幫忙完成，可以透過 krew 這個 kubectl 管理工具來安裝管理
<a href="https://github.com/itaysk/kubectl-neat" target="_blank" rel="noopener noreferrer">https://github.com/itaysk/kubectl-neat</a>
此工具可以將 Server 上得到 Yaml 的內容給整理最後得到最初的檔案
至於到底什麼是 managedFiles? 這個由欄位的出現是因為 1.18 以後，已經將 Server Side Apply 更新策略預設啟用而導致的，而 Server Side Apply 則是一種用來管理 Declarative 設定檔案的方式，對使用者來&gt;
說基本上完全無感，因為一切都還是透過 kubectl apply 來使用，只是到底如何判斷  當前檔案內容與系統上內容誰先誰後，誰對誰錯，甚至當有人透過 kubectl edit 去編輯內容的時候，到底該怎麼更新。</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Rancher v2.5 Release」]]></title>
        <id>https://hwchiu.com/2021/11/20/reading-note-10</id>
        <link href="https://hwchiu.com/2021/11/20/reading-note-10"/>
        <updated>2021-11-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「Rancher v2.5 Release」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://www.suse.com/c/rancher_blog/rancher-2-5-delivers-on-computing-everywhere-strategy/" target="_blank" rel="noopener noreferrer">https://www.suse.com/c/rancher_blog/rancher-2-5-delivers-on-computing-everywhere-strategy/</a></p><p>Rancher v2.5 版本與過往的差異，這邊就來重點節錄一些改變</p><ol><li>強化與雲端環境 EKS 與 輕量級 K3s 環境的整合，此外宣稱所有 Kubernetes 服務上面都可以安裝 Ranche 用其來幫忙管理
Rancher v2.5 釋出!
這幾天 Rancher 正式釋出 v2.5 版本，這邊就來重點節錄一些改變</li><li>強化與雲端環境 EKS 與 輕量級 K3s 環境的整合，此外宣稱所有 Kubernetes 服務上面都可以安裝 Ranche 用其來幫忙管理</li><li>針對美國環境要求而開發更具安全性的發行版，符合 FIPS(Federal Information Processing Standars)</li><li>整合 GitOps 部署，針對大規模 Edge 叢集的自動部署解決方案 fleet</li><li>Monitoring 強化，減少與 Rancher 本身的連接性，反而更加使用 Prometheus operator 來提供服務。管理人員可以直接創建相關的 CRD 提供服務，而這些資訊也都會被 Rancher UI 給一併呈現
其中 (4) 裡面還提供的 cluster-level 的客製化設定，就不需要向過往一樣要開很多個 project-level 的 prometheus 來處理，這方面輕鬆不少
資料來源：</li></ol><ul><li><a href="https://rancher.com/.../rancher-2-5-delivers-computing" target="_blank" rel="noopener noreferrer">https://rancher.com/.../rancher-2-5-delivers-computing</a>...</li><li><a href="https://github.com/rancher/fleet" target="_blank" rel="noopener noreferrer">https://github.com/rancher/fleet</a></li><li><a href="https://fleet.rancher.io/" target="_blank" rel="noopener noreferrer">https://fleet.rancher.io/</a></li><li><a href="https://github.com/rancher/rancher/issues/23239" target="_blank" rel="noopener noreferrer">https://github.com/rancher/rancher/issues/23239</a></li></ul><ol start="2"><li>針對美國環境要求而開發更具安全性的發行版，符合 FIPS(Federal Information Processing Standars)</li><li>整合 GitOps 部署，針對大規模 Edge 叢集的自動部署解決方案 fleet</li><li>Monitoring 強化，減少與 Rancher 本身的連接性，反而更加使用 Prometheus operator 來提供服務。管理人員可以直接創建相關的 CRD 提供服務，而這些資訊也都會被 Rancher UI 給一併呈現
其中 (4) 裡面還提供的 cluster-level 的客製化設定，就不需要向過往一樣要開很多個 project-level 的 prometheus 來處理，這方面輕鬆不</li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Rancher" term="Rancher"/>
        <category label="RKE" term="RKE"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Java 應用程式於容器內的效能問題」]]></title>
        <id>https://hwchiu.com/2021/11/18/reading-note-9</id>
        <link href="https://hwchiu.com/2021/11/18/reading-note-9"/>
        <updated>2021-11-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「Java 應用程式於容器內的效能問題」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://mucahit.io/2020/01/27/finding-ideal-jvm-thread-pool-size-with-kubernetes-and-docker/" target="_blank" rel="noopener noreferrer">https://mucahit.io/2020/01/27/finding-ideal-jvm-thread-pool-size-with-kubernetes-and-docker/</a></p><p>如果有在 Kubernetes 內部署 Java 應用程式的人，千萬不要錯過這篇文章，此文章中分享 Java 應用程式關於 Thread Pool Size 的問題，同時當 Java 應用程式容器化並且部署到 Kubernettes 內之後，該怎麼設定
JVM 來讓其能夠更高效率的於容器化環境下工作</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Container" term="Container"/>
        <category label="Jave" term="Jave"/>
        <category label="Performance" term="Performance"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「CRD 與 Operator 的探討」]]></title>
        <id>https://hwchiu.com/2021/11/16/reading-note-8</id>
        <link href="https://hwchiu.com/2021/11/16/reading-note-8"/>
        <updated>2021-11-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「CRD 與 Operator 的探討」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://twitter.com/ibuildthecloud/status/1295810776179961856?fbclid=IwAR3zVNFSodC-PK7JBUDA63vNONwrovxJP7qBvaTtq735dWonROlD5xWN13s" target="_blank" rel="noopener noreferrer">https://twitter.com/ibuildthecloud/status/1295810776179961856?fbclid=IwAR3zVNFSodC-PK7JBUDA63vNONwrovxJP7qBvaTtq735dWonROlD5xWN13s</a></p><p>想必大家應該都聽過 Operator 的概念，透過 CRD 自定義資源格式並且配上程式化的運作邏輯來控管相關資源的操作。甚至有廠商針對 Operator 的概念來設計一個 Framework 讓大家能夠更輕鬆或是有效率的撰寫屬&gt;
於自己的 Operator。
然而 Operator 真的一定好嗎? 底下這則推文則是來自於 Darren Shepherd(CTO/Co-founder Rancher Lab ) 對於一篇由 RedHat 所發表關於 Operator 好處文章的反面看法。
其推文最後表示:「Right now invest your IT teams time in GitOps, not operators.」
快來看看 Darren 與其他網友針對這些議題的討論，並且分享看看你的想法</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
        <category label="Operator" term="Operator"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「terraform,Terraform Module 依賴性討論」]]></title>
        <id>https://hwchiu.com/2021/11/14/reading-note-7</id>
        <link href="https://hwchiu.com/2021/11/14/reading-note-7"/>
        <updated>2021-11-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「terraform,Terraform Module 依賴性討論」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://medium.com/hashicorp-engineering/creating-module-dependencies-in-terraform-0-13-4322702dac4a" target="_blank" rel="noopener noreferrer">https://medium.com/hashicorp-engineering/creating-module-dependencies-in-terraform-0-13-4322702dac4a</a></p><p>Terraform 這個工具想必大家都玩過也聽過，這邊非常推薦大家升級到 0.13 版本，這個版本中解決了關於 Module 之間依賴性的問題，能夠使用原先就有的 depends_on 的語法來直接描述，而不需要按照過往以前用&gt;
各種 fake resource 等機制來完成，整個 Terraform 程式碼會更佳清晰與簡單!</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Terraform" term="Terraform"/>
        <category label="IaC" term="IaC"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「CPU Limit 造成的效能低落」]]></title>
        <id>https://hwchiu.com/2021/11/12/reading-note-6</id>
        <link href="https://hwchiu.com/2021/11/12/reading-note-6"/>
        <updated>2021-11-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「CPU Limit 造成的效能低落」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://erickhun.com/posts/kubernetes-faster-services-no-cpu-limits/" target="_blank" rel="noopener noreferrer">https://erickhun.com/posts/kubernetes-faster-services-no-cpu-limits/</a></p><p>想必大家一定都有使用過 CPU Limit 的經驗，透過這個機制能夠確保每個 Container 使用的 CPU 資源量，也可以保證每個節點上面會有足夠 CPU 供 Kubernetes 原生服務 (kubelet) 使用。
然而本篇文章就要來跟大家分享一個設定 CPU Limit 反而造成效能更差的故事，故事中當 CPU 設定為 800ms 的時候，卻發現實際運行的 Container 最高大概就只有 200ms 左右，這一切的一切都是因為 Liniux Kernel 的臭蟲導致!
一個直接的做法就是針對那些本來就沒有過高 CPU 使用量服務取消其 CPU Limit，作者於文章中也探討了一些機制要如何保護與應對這些被移除 CPU 限制的服務。
這個臭蟲於 Linux Kernel 4.19 後已經修復，但是要注意你使用的發行版本是否有有包含這個修復，作者列出一些已知的發行版本修復狀況
Debian: The latest version buster has the fix, it looks quite recent (august 2020). Some previous version might have get patched.
Ubuntu: The latest version Ubuntu Focal Fosa 20.04 has the fix.
EKS has the fix since December 2019, Upgrade your AMI if necessary.
kops: Since June 2020, kops 1.18+ will start using Ubuntu 20.04 as the default host image.
GKE: THe kernel fix was merged in January 2020. But it does looks like throttling are still happening.</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Linux" term="Linux"/>
        <category label="Kernel" term="Kernel"/>
        <category label="ResourceManagement" term="ResourceManagement"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Kubernetes CNI 效能比較」]]></title>
        <id>https://hwchiu.com/2021/11/10/reading-note-5</id>
        <link href="https://hwchiu.com/2021/11/10/reading-note-5"/>
        <updated>2021-11-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「Kubernetes CNI 效能比較」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://www.hwchiu.com/cni-performance-2020.html" target="_blank" rel="noopener noreferrer">https://www.hwchiu.com/cni-performance-2020.html</a></p><ol><li>Kube-OVN 不但資源吃很多，效能還很不好</li><li>Canal/Calico/Flannel 三者的運算資源使用量都不多，且效能都很好</li><li>Kube-Router 的效能都很差，資源使用方便也不是特別出色</li><li>WeaveNet 與 Cilium 效能都不差，但是 Cilium 吃的效能很高，可說跟 Kube-OVN 同等級，而 WeaveNet 用到的資源少</li><li>這次的實驗評比我認為其實能看到的東西有限，主要是不同的 CNI 所搭配的解決方案不同，目標要配合的情境也不同，雖然從圖表中可以看到 Kube-OVN 的綜合評比最差，但是其要用的場景本&gt;身就不太一樣，單純用最原始的流量互打來判別優劣其實不太對</li><li>如果今天要選擇網路 CNI 的時候，可以看到效能跟資源方面， Flannel/Calico/Canal 幾乎等級都差不多，而且 Calico 還支援加密與 Network Policy 等功能。</li><li>此外，目前 Flannel 也從 Kubeadm 的官方教學頁面中移除，因為太多問題且維護者沒有要修復。所以我認為如果沒有特別使用情境需求的話，可以考慮使用 Calico.</li><li>Cilium 對於安全性以及 load-balancing 方面也有別的功能，就如同(5)點所提到，不同的場景有不同的需求，有些功能是獨占的。</li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Network" term="Network"/>
        <category label="Kubernetes" term="Kubernetes"/>
        <category label="CNI" term="CNI"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Contaienr 底層實作與 CVE 介紹」]]></title>
        <id>https://hwchiu.com/2021/11/08/reading-note-4</id>
        <link href="https://hwchiu.com/2021/11/08/reading-note-4"/>
        <updated>2021-11-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「Contaienr 底層實作與 CVE 介紹」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://teamt5.org/tw/posts/container-escape-101/" target="_blank" rel="noopener noreferrer">https://teamt5.org/tw/posts/container-escape-101/</a></p><p>這篇分享一篇非常有趣的問題，從 Container 的實作開始介紹，最後介紹幾個與 Container 相關的 CVE
對於資安有興趣的可以研究看看</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Container" term="Container"/>
        <category label="Security" term="Security"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「七個邁向 Cloud Native 的挑戰!!」]]></title>
        <id>https://hwchiu.com/2021/11/06/reading-note-3</id>
        <link href="https://hwchiu.com/2021/11/06/reading-note-3"/>
        <updated>2021-11-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「七個邁向 Cloud Native 的挑戰!!」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://www.facebook.com/technologynoteniu/posts/125741595926648" target="_blank" rel="noopener noreferrer">https://www.facebook.com/technologynoteniu/posts/125741595926648</a></p><p>本篇文章列出了七個企業想要踏入 Cloud Native 之路上最常遇到的問題
以下幫大家總結並節錄一點小內文</p><ol><li>過於緩慢的發布週期
創新需要有能力很快速地針對每次的修改去快速發布。</li><li>使用過時的技術
作者認為時時關注當前這個迅速發展的世界是非常重要的，特別是的相關開源專案。</li><li>綁定特定服務供應商且成長方面缺乏彈性
當服務與特定廠商的解決方案綁定太深時，很容易遇到所有功能都由該廠商綁定，想要做什麼都會綁手綁腳。</li><li>缺乏專業性人才
根據 2019 一篇調查，只有 7% 的 IT 主管再招聘與慰留人才方面沒有遇到困難</li><li>安全性
人們總是當問題發生的時候才會開始注意安全性的問題，但是往往這些問題的代價都很高。儘管安全防護是一個複雜且困難的領域，但是擁有一個資安的實踐守則還是非常重要。</li><li>過高的運營與技術成本
滿多企業都會使用雲端服務來減少自行維護伺服器所需的成本，然而 Cloud Native 的環境常常會用到各式各樣的元件，這些元件所消耗的成本都會隨者規模放大而有所影響，如何去最佳化你的雲端資源使用量來盡可能的減少你的花費也是一大挑戰</li><li>Cloud Native 的概念難以溝通
Cloud Native 的觀念難以溝通與理解，對於任何想要導入 Cloud Native 到團隊中的企業來說，領導團隊必須要先理解到底這些解決方案的重要性與複雜性。
甚至可能還會因為微服務，容器等其他概念的認知不同而花時間理解。</li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="CloudNative" term="CloudNative"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「淺談 Service Mesh」]]></title>
        <id>https://hwchiu.com/2021/11/04/reading-note-2</id>
        <link href="https://hwchiu.com/2021/11/04/reading-note-2"/>
        <updated>2021-11-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「淺談 ServiceMesh」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://buoyant.io/service-mesh-manifesto/" target="_blank" rel="noopener noreferrer">https://buoyant.io/service-mesh-manifesto/</a></p><p>一篇關於 Service Mesh 的好文，發布已經有段時間了不過還是值得一讀， 文章作者是非常早期 Service Mesh 項目: Linkerd 的核心開發成員之一也是新創公司 Buoyant 公司的 CEO
相信大家應該對於 Service Mesh 一詞已經不陌生，可能對於這個名詞比較熟悉的朋友大多是從另一個 Service Mesh 項目:  Istio 去了解 Service Mesh 的面貌，從這篇文章你可以從不同觀點認識 Service Mesh ，
全文非常長內容涵蓋：</p><ul><li>Service Mesh 詳盡介紹</li><li>為什麼 Service Mesh 可以被施行？</li><li>為什麼 Service Mesh 是個好的 idea (比起其他方法)？</li><li>Service Mesh 幫助了什麼？</li><li>Service Mesh 有解決掉所有問題嗎？</li><li>為什麼在現今 Service Mesh 可以被施行？</li><li>為什麼人們那麼愛談論 Service Mesh？</li><li>身為一個謙虛的開發者需要關注 Service Mesh 嗎?</li><li>一系列F&amp;Q
這裡對 Service Mesh 的需求做個小結，Service Mesh 帶來了三大好處：</li></ul><ol><li>Reliability: 包含提供請求重試、超時、金絲雀部署(Traffic shifting/splitting) 等功能</li><li>Observability: 包含提供請求成功率、延時、粒度到個別服</li><li>Security: ACL 及 Mutual TLS (客戶端及服務端互信）
值得一提的是，本篇作者 William Morgan 對於 istio 持負面的態度，並不是因為 istio 與 linkerd 處於競爭關係的兩個產品，而是對於 istio 在 service mesh 做了太多的商業性 marketing 操作（大部分來自Go
ogle的操作)
有興趣的朋友也可以在 Podcast 上聽到作者在 Podcast 上的訪談: <a href="https://reurl.cc/N6GbW9" target="_blank" rel="noopener noreferrer">https://reurl.cc/N6GbW9</a></li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="ServiceMesh" term="ServiceMesh"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「How to enforce Kubernetes network security policies using OPA」]]></title>
        <id>https://hwchiu.com/2021/11/02/reading-note-1</id>
        <link href="https://hwchiu.com/2021/11/02/reading-note-1"/>
        <updated>2021-11-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「How to enforce Kubernetes network security policies using OPA」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://www.cncf.io/blog/2020/09/09/how-to-enforce-kubernetes-network-security-policies-using-opa" target="_blank" rel="noopener noreferrer">https://www.cncf.io/blog/2020/09/09/how-to-enforce-kubernetes-network-security-policies-using-opa</a></p><p>不知道大家是否都有使用 Network Policy 來設定 Kubernetes 內部的 ACL?
這邊有個叫做 OPA 的工具可以用幫你驗證你的 Network Policy 是否運作良好，甚至當有新的應用服務要部署的時候，也會確定是否有跟 Network Policy 衝突
有興趣的人可以研究看看</p>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="Kubernetes" term="Kubernetes"/>
        <category label="Security" term="Security"/>
        <category label="OPA" term="OPA"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[閱讀筆記: 「Amazon EKS Upgrade Journey From 1.17 to 1.18」]]></title>
        <id>https://hwchiu.com/2021/10/31/reading-note-0</id>
        <link href="https://hwchiu.com/2021/10/31/reading-note-0"/>
        <updated>2021-10-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[「Amazon EKS Upgrade Journey From 1.17 to 1.18」]]></summary>
        <content type="html"><![CDATA[<p>連結: <a href="https://medium.com/swlh/amazon-eks-upgrade-journey-from-1-17-to-1-18-e35e134ca898" target="_blank" rel="noopener noreferrer">https://medium.com/swlh/amazon-eks-upgrade-journey-from-1-17-to-1-18-e35e134ca898</a></p><p>這邊跟大家分享一篇 EKS 升級的心得文章，該文章記錄了 EKS 從 k8s 1.17 到 1.18 的過程，並且先分享了幾個 1.18 主要新功能，包含了</p><ol><li>Topology Manager (Beta)</li><li>Service Side Apply (Beta)</li><li>Pod Topology Spread (Beta)
... 等
詳細升級過程看起來無痛輕鬆，有興趣的可以參考全文
當然升級 K8S 最重要的還是要注意 Resource 的 API 版本是否有變，譬如 1.16 就讓很多人採到 Deployment 使用  extensions/v1beta1 的錯誤，所以每次升級請先檢查有沒有哪些過舊的 API 版本被丟棄，以免升&gt;
級後現有的服務部屬不上去
題外話： ingress 如果還是使用 extensions/v1beta1 的話，建議都換成 networking.k8s.io/v1beta1 (k8s 1.14+), 到了 1.22 後本來的 extensions/v1beta1 就不能用囉</li></ol>]]></content>
        <author>
            <name>HungWei Chiu</name>
            <uri>https://github.com/hwchiu</uri>
        </author>
        <category label="Reading" term="Reading"/>
        <category label="AWS" term="AWS"/>
        <category label="EKS" term="EKS"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020-年度回顧]]></title>
        <id>https://hwchiu.com/2020/12/31/2020-review</id>
        <link href="https://hwchiu.com/2020/12/31/2020-review"/>
        <updated>2020-12-31T02:45:08.000Z</updated>
        <summary type="html"><![CDATA[2020 Review]]></summary>
        <content type="html"><![CDATA[<p>2020 年度個人回顧</p><ol><li>美國工作順利活下來，已達一年六個月</li><li>美國總共搬家四次，其中只有一次跟我有關</li><li>洗衣機卡門事件讓我領悟到世事難料</li><li>年度公開演講 8 場，其中六場是個人自給自足的線上演講。而且有五場是美國時間早上六點起來準時分享。必須說真的滿累的，一大早又要講底層的東西常常會恍神</li><li>年度公開文章 58 篇，其中 30 篇是 2020 參加鐵人賽完賽的文章。今年度有增加更多 devops 相關的文章，也還是有保持幾篇研究 kernel 等底層的文章</li><li>參加 2020 鐵人賽，今年運氣不錯得到佳作，同時團體賽也順利完賽！</li><li>續約微軟 MVP</li><li>開設三門線上課程，講述 kubernetes 各類資訊，課程總長度將近33小時</li><li>參加兩次 podcast 閒聊</li><li>一整年剪頭髮次數: 2 次</li><li>美國遠端工作八個月，回台的14天隔離根本小case</li><li>八個月沒有進入健身房，覺得人生少了一點什麼，實測發現硬舉最大重量少了70公斤 :(</li><li>脫魯</li><li>感謝前國手們的閒聊，最後開設個人粉絲頁分享各類資訊，累積人樹目前 2k</li></ol><p>2021 展望</p><ol><li>美國工作繼續順利</li><li>繼續保持線上演講的衝勁與動力，希望至少一年六次</li><li>文章希望內容可以廣度與深度兼具</li><li>今年我要成為 ebpf 王</li><li>繼續參加鐵人賽</li><li>剪頭髮次數: 3 次</li><li>繼續開設三門線上課程</li><li>撰寫第一本書籍</li><li>粉絲頁固定每兩天一篇文章分享長達一年</li><li>街頭健身完成前水平</li><li>保持脫魯</li></ol><p>結語</p><p>2020 受到疫情影響，導致有八個月的時間都長期遠端工作，整體工作生活習慣改變，包含工作，煮飯，運動等彼此的時間調整。</p><p>也因為如此有更多的彈性時間去思考自己要的東西，同時準備課程與鐵人賽文章。整體的時間管理能力目前還算滿意</p>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="AnnualReview" term="AnnualReview"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 疫情下的矽谷 - 遠端工作的探討]]></title>
        <id>https://hwchiu.com/2020/09/05/coivd-wfh</id>
        <link href="https://hwchiu.com/2020/09/05/coivd-wfh"/>
        <updated>2020-09-25T08:56:55.000Z</updated>
        <summary type="html"><![CDATA[本篇用來分享2020疫情肆虐下的遠端工作心得]]></summary>
        <content type="html"><![CDATA[<p>2020 年是個多事之秋的一年， COVID-19 於全球肆虐，根據 <a href="https://www.worldometers.info/coronavirus/" target="_blank" rel="noopener noreferrer">worldometer</a> 的統計，到 2020/09/25 已經造成全球三千兩百萬人感染，將近一百萬人死亡。其造成的經濟影響更是空球絕後，美國股市一波三折，一年多次熔斷已經是歷史紀錄。企業則是面臨各種收入減少的困境，申請破產與力拼轉型的新聞則是沒有停止過。</p><p>今天就來跟大家分享一下，這六個多月以來遠端工作 (Work From Home, WFH) 的一些想法與心得</p><h1>個人經驗</h1><p>個人目前對於遠端工作是秉持利大於弊的心得，接下來從不同點來探討利弊</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="交通">交通<a href="#交通" class="hash-link" aria-label="Direct link to 交通" title="Direct link to 交通">​</a></h2><p>矽谷灣區最著名的一個特色就是塞車，上班塞車，下班塞車，永遠都在塞車，所以過往很多人都會採取彈性上班的方式來避免車流，或是採取大眾運輸工具的方式來通勤。</p><p>以我個人為例，過往每天上班的通勤時間大概平均兩個小時，主要分成開車與大眾運輸</p><ol><li>大眾運輸: 腳踏車配上火車通勤，由於火車時刻表固定，所以上下班時間比較沒有彈性</li><li>開車: 開車的話大概可以將時間縮短到單趟 40 分鐘左右，但是整個高速公路都是一片紅，其實開起來很悶</li></ol><p>遠端工作後，每天可以省下大約兩個小時的時間，這部分可以拿來上班工作，也可以拿來處理私人事情，時間上更加彈性</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="工作">工作<a href="#工作" class="hash-link" aria-label="Direct link to 工作" title="Direct link to 工作">​</a></h2><p>遠端在家工作後，最大的幾個變化就是</p><ol><li><p>工作自律
基本上一整天就是在電腦前面，所以沒有開會的時候，其實都是自己去控制自己的工作節奏，這部分好壞的意見都有聽過，大家也會彼此分享如何讓自己工作更加專心，而不會被家裡的舒適環境給影響。</p></li><li><p>會議全面遠端化且數量上升
過往一些小事情要討論時，可能就直接現場約一約，到小會議室直接討論。然而目前則是因為遠端會議，所以全部都要事先預約時間來確保對方目前在電腦前。有時候一個小事情卻要花更多的時間來定案，我個人認為效率是不如過往的。
此外之前也出現如 Zoom Fatigue 這樣的說法，過多的會議內容導致大家開會疲倦，分心</p></li></ol><p>就我個人的心得來看，自己能夠維持好工作的節奏，該完成的工作事項能完成就好，此外被打擾中斷工作的機會也更少了，整體而言利大於弊，</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="互動">互動<a href="#互動" class="hash-link" aria-label="Direct link to 互動" title="Direct link to 互動">​</a></h2><p>員工之間的會面都是透過線上會議，缺少實體見面的互動，這部分也是見仁見智。有些人不喜歡交流，覺得
「上班當同事，下班不認識」是其工作原則，那應該會滿喜歡這種模式的。但是也有人喜歡實體交流，每天吃個一起吃個午餐，聊聊一些工作以外的事情，分享彼此的事情也都是一種生活。</p><p>這部分我就沒有太大意見，有好有壞，偶而還是會透過 slack 與同事聊聊幹話，分享最近的生活，只是少了聲音的互動。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="福利">福利<a href="#福利" class="hash-link" aria-label="Direct link to 福利" title="Direct link to 福利">​</a></h2><p>遠端工作以後，公司內本來的福利近乎全滅，什麼咖啡，零食，飲料，冰箱內各種飲品，甚至免費午餐等都不再擁有，一切都要依賴自己處理。</p><p>對於一個自住的邊緣人來說，變成每天都要煩惱該怎麼處理今天的飲食，「每餐叫外送，荷包先消瘦」是一個顧慮點，自己煮飯又是一個額外的挑戰，買菜/備料/烹飪/善後四個步驟往往也花費不少時間在處理，如果將這個時間與通勤時間組合起來，未必可以省下時間。</p><p>我個人平常就習慣煮飯，已經練就如何快速料理與一次準備多日便當，所以這個情況比較不會有太大問題。
倒是我有聽過朋友因為沒有公司零食的迫害，遠端工作期間被迫減肥，也算是一個附加好處</p><p>一個美好的夢想就是辦公室可以縮編，「公司省租金，員工可加薪」</p><h1>美國現況</h1><p>疫情以來，各大公司陸陸續續宣布相關的遠端工作政策，而規範的工作日期也隨者疫情的擴散而延後，下面就整理目前我知道部分公司的工作內容，此外政策不一定適用於所有員工，必要性的情況下，部分員工還是要定期前往辦公室。</p><p>Apple: 員工可以遠端工作直到 2021 初期
Google: 員工至少可以遠端工作到 2021/07
Facebook: 員工至少可以遠端工作到 2021/07
Twitter: 員工可以選擇永遠遠端工作
Fujitsu: 員工可以選擇永遠遠端工作
Microsoft: 可以遠端工作直到 2021/02
Amazon: 員工至少可以遠端工作到 2021/01
Netflix: 員工遠端工作直到全面接受疫苗</p><p>此外，也有人對於遠端工作提出了一些負面說詞，譬如 Netflix 董事長則認為遠端工作沒有帶來正面效果，反而使得討論工作更加困難。</p><p>這部分真的就是沒有定案，完全見仁見智，而 Google 最近的<a href="https://twitter.com/lifeatgoogle/status/1308529123984203778/photo/1" target="_blank" rel="noopener noreferrer">調查</a>則顯示只有 10% 不到的員工想要回到過往天天進辦公室的日子，</p><p>以下節錄自 Google 官方推特
<img loading="lazy" src="https://i.imgur.com/6up8mq8.png" class="img_ev3q"></p><p>除了公司本身政策的變動外，居住地遷移最近也是活動頻繁，譬如 Oklahoma 洲則有 <a href="https://tulsaremote.com/" target="_blank" rel="noopener noreferrer">Tulsa Remote</a> 計畫，向所有遠端工作者提供一萬美元的獎勵，只要你願意搬來這邊即可。 根據報導指出，舊金山的兩房公寓每個月可能略低於四千美金，而 Tusla 則不到一千美金，再租金花費方面可以說是節省不少開銷。</p><h1>心得</h1><p>就我過去五年的台灣工作經驗，我認為台灣公司要跟進遠端工作政策實屬不易，幾個原因如下</p><ol><li>勞基法規定下，公司都要提出員工上下班出勤時間的紀錄，這部分會用來評估是否有加班超時
對於遠端工作者來說，要如何打卡來滿足這些紀錄是一個行政上的問題，而不是技術上的問題
更多時候是公司行政團隊願不願意嘗試探討可能性，並嘗試看看</li><li>沒人監督，老闆放不下
這種情況下，我認為信任是最基本的基礎，老闆信任員工可以遠端工作依然保持良好效率，員工也真的能夠滿足一定的效率來證明制度可行。過往就有聽過台灣發生過老闆接受遠端工作，結果員工私下兼差來賺錢，最後兩邊信任破壞，一切回歸辦公室制度。</li></ol><h1>Reference</h1><ul><li><a href="https://www.cnbc.com/2019/01/10/vermont-will-pay-you-10000-to-move-there-and-work-remotely---.html" target="_blank" rel="noopener noreferrer">https://www.cnbc.com/2019/01/10/vermont-will-pay-you-10000-to-move-there-and-work-remotely---.html</a></li><li><a href="https://www.wsj.com/articles/facebook-to-shift-permanently-toward-more-remote-work-after-coronavirus-11590081300" target="_blank" rel="noopener noreferrer">https://www.wsj.com/articles/facebook-to-shift-permanently-toward-more-remote-work-after-coronavirus-11590081300</a></li><li><a href="https://www.wsj.com/articles/google-to-keep-employees-home-until-summer-2021-amid-coronavirus-pandemic-11595854201" target="_blank" rel="noopener noreferrer">https://www.wsj.com/articles/google-to-keep-employees-home-until-summer-2021-amid-coronavirus-pandemic-11595854201</a></li><li><a href="https://www.cnn.com/2020/07/27/tech/google-work-from-home-extension/index.html" target="_blank" rel="noopener noreferrer">https://www.cnn.com/2020/07/27/tech/google-work-from-home-extension/index.html</a></li><li><a href="https://www.bbc.com/news/business-53303364" target="_blank" rel="noopener noreferrer">https://www.bbc.com/news/business-53303364</a></li><li><a href="https://www.cnbc.com/2020/09/23/google-ceo-sundar-pichai-considering-hybrid-work-from-home-models.html" target="_blank" rel="noopener noreferrer">https://www.cnbc.com/2020/09/23/google-ceo-sundar-pichai-considering-hybrid-work-from-home-models.html</a></li></ul>]]></content>
        <category label="life" term="life"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[costco 冷凍鮭魚排紀錄]]></title>
        <id>https://hwchiu.com/2018/10/28/costco-salmon</id>
        <link href="https://hwchiu.com/2018/10/28/costco-salmon"/>
        <updated>2018-10-28T01:32:39.000Z</updated>
        <summary type="html"><![CDATA[本文用來記錄 Costco 冷凍鮭魚排的營養組成，對於有需要進行飲食追蹤的人能夠提供一個基本的概念到底每一餐吃進去的營養成分分別多少]]></summary>
        <content type="html"><![CDATA[<p>本身算是 <code>Costco</code> 愛好者，每個禮拜的蛋白質基本上都是從 <code>Costco</code> 取得</p><p>常買的有</p><ol><li>雞胸肉</li><li><a href="https://hwchiu.com/costco-chicken.html" target="_blank" rel="noopener noreferrer">雞腿排</a></li><li>牛奶</li><li>蛋白丁</li><li>蝦仁</li><li>鮭魚</li></ol><p>這篇文章主要用來記錄冷凍鮭魚排的資訊，每一份的大小以及熱量等資訊</p><h1>來源</h1><p><code>Costco</code> 基本上有滿多的鮭魚可以購買，有在冷藏處比較新鮮的挪威鮭魚，也有在冷凍庫的冷凍鮭魚。
由於我大部分都是製作便當，因此任何的食材在烹飪完畢後都會冷藏並且隔天透過微波爐來加熱飲食
因此在選擇上我都還是以冷凍鮭魚為主，只有特別想要當天吃才會選擇冷藏鮭魚</p><p>本篇主要以冷凍鮭魚為主,其包裝如下
<img loading="lazy" src="https://i.imgur.com/uxhu09H.jpg" alt="Imgur" class="img_ev3q"></p><h1>大小</h1><p>根據 <img loading="lazy" src="https://i.imgur.com/nH69ZxP.jpg" alt="Imgur" class="img_ev3q"> 包裝背後的標示，本包裝大概含有 2KG 的鮭魚，然而實際上裡面的包裝物並不是真的如其所說有 20 份這麼多，其實每片鮭魚大小都頗大的。</p><p>實際上拿出一片使用電子秤來進行實測，測出來的重量大概是 300g 左右
<img loading="lazy" src="https://i.imgur.com/HtZaLIs.jpg" alt="Imgur" class="img_ev3q"></p><p>因此一整包的份量大概會落在7片左右，畢竟每片鮭魚的大小都會有點差距，不過大概可以記住一片300g就好</p><h1>營養</h1><p>本篇就直接使用該包裝背後所提供的成份表來計算每片鮭魚排的營養素
<img loading="lazy" src="https://i.imgur.com/nH69ZxP.jpg" alt="Imgur" class="img_ev3q"></p><p>將常見的營養素基於 <code>100</code> 以及 <code>300</code> 公克列舉出來</p><table><thead><tr><th></th><th>100公克</th><th>300公克</th></tr></thead><tbody><tr><td>熱量</td><td>149  KCal</td><td>447 KCal</td></tr><tr><td>蛋白質</td><td>17.9 g</td><td>53.7 g</td></tr><tr><td>粗脂肪</td><td>8.5   g</td><td>25.5 g</td></tr><tr><td>飽和脂肪</td><td>2.2  g</td><td>6.6 g</td></tr><tr><td>碳水化合物</td><td>0.1 g</td><td>0.3  g</td></tr><tr><td>鈉</td><td>59 mg</td><td>177 mg</td></tr></tbody></table><p>這樣來看如果今天一餐吃一片冷凍鮭魚排的話，，攝取的蛋白質大概是 54 g 左右，熱量450卡，如果單純考慮價錢與蛋白質的比例的話，還是雞胸/雞腿的比例比較好，不過換換口味吃個鮭魚也不錯</p><h1>烹調</h1><p>基本上好好的煎就沒有什麼問題了，唯一要注意的是要確認內部比較厚的部分需要比較長的時間才會熟透，可以切半去料理會比較快。</p>]]></content>
        <category label="Food" term="Food"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Costco 去骨雞腿排紀錄]]></title>
        <id>https://hwchiu.com/2018/08/08/costco-chicken</id>
        <link href="https://hwchiu.com/2018/08/08/costco-chicken"/>
        <updated>2018-08-08T10:34:15.000Z</updated>
        <summary type="html"><![CDATA[本文用來記錄 Costco 去骨雞腿排的營養組成，對於有需要進行飲食追蹤的人能夠提供一個基本的概念到底每一餐吃進去的營養成分分別多少]]></summary>
        <content type="html"><![CDATA[<p>本身算是 <code>Costco</code> 愛好者，每個禮拜的蛋白質基本上都是從 <code>Costco</code> 取得</p><p>常買的有</p><ol><li>雞胸肉</li><li><a href="https://hwchiu.com/costco-chicken.html" target="_blank" rel="noopener noreferrer">雞腿排</a></li><li>牛奶</li><li>蛋白丁</li><li>蝦仁</li><li><a href="https://hwchiu.com/costco-salmon.html" target="_blank" rel="noopener noreferrer">鮭魚</a></li></ol><p>這篇文章主要用來記錄雞腿排的資訊，包含來源，熱量等資訊</p><h1>來源</h1><p>基本上 <code>Costco</code> 雞腿肉的來源有兩家，分別<code>大成</code> 以及 <code>卜蜂</code> 這兩家供應商。</p><p>購買時包裝上面都會顯示這兩家的名稱與Logo，除了供應商名稱不同外，其價格與大小大致上並沒有差異。</p><h1>大小</h1><p>根據 <a href="https://www.costco.com.tw/Food/Prepared-Canned-Food/Frozen-Food/CP-Frozen-Boneless-Chicken-Thigh-25KG-X-6Packs/p/146146" target="_blank" rel="noopener noreferrer">Costco 線上官網</a> 的圖示說明，每包 <code>Costco</code> 去骨雞腿都是一次六包為一個單位</p><p>如下圖
<img loading="lazy" src="https://www.costco.com.tw/medias/sys_master/products/hca/h5c/8839260799006.jpg" class="img_ev3q"></p><p>六包的重量大概都是落在 2.5kg 上下左右，平均下來每包平均 400多克左右。</p><p>但是實際上在食用時，每一包內的去骨雞腿牌數量則是 2-3 片，這部份就是隨機的。</p><p>為了能夠簡單的估算每一包雞腿排的營養素，我們必須要先知道每一塊的重量</p><p>這邊實際拿電子秤來實測看看這兩片雞腿排的重量</p><p><img loading="lazy" src="https://i.imgur.com/CNH6tXB.jpg" alt="Imgur" class="img_ev3q">
<img loading="lazy" src="https://i.imgur.com/t9CIvyM.jpg" alt="Imgur" class="img_ev3q"></p><p>根據上述的結果，每片雞腿排的重量大概落在 170 公克左右</p><h1>營養</h1><p>根據<a href="https://consumer.fda.gov.tw/Food/TFND.aspx?nodeID=178" target="_blank" rel="noopener noreferrer">食品藥物消費者知識服務網</a> 提供的食品營養素估算表</p><p>我們使用<code>肉類</code>-&gt;<code>雞類</code> -&gt;<code>清腿</code> 這個<a href="https://consumer.fda.gov.tw/Food/detail/TFNDD.aspx?f=1&amp;pid=103" target="_blank" rel="noopener noreferrer">分類</a>來估算營養成分</p><p>將常見的營養素基於 <code>100</code> 以及 <code>170</code> 公克列舉出來</p><table><thead><tr><th></th><th>100公克</th><th>170公克</th></tr></thead><tbody><tr><td>熱量</td><td>157</td><td>267</td></tr><tr><td>粗蛋白</td><td>18.5</td><td>31.4</td></tr><tr><td>粗脂肪</td><td>8.7</td><td>14.8</td></tr><tr><td>飽和脂肪</td><td>2.5</td><td>4.3</td></tr><tr><td>總碳水化合物</td><td>0</td><td>0</td></tr></tbody></table><p>這樣來看如果今天一餐吃包，攝取的蛋白質則介於 <code>60</code> ~ <code>90</code> 公克之間，取決於你那一包裡面有多少片雞腿排</p><h1>烹調</h1><p>雞腿肉相對於雞胸肉來說料理非常簡單，基本上只要現煮(烤/煎/)等各式料理方法都不會太難吃，所以就邊就不多述相關的料理方式了</p><p>#參考來源</p><ul><li><a href="https://consumer.fda.gov.tw/Food/TFND.aspx?nodeID=178" target="_blank" rel="noopener noreferrer">食品藥物消費者知識服務網</a></li><li><a href="https://www.costco.com.tw/Food/Prepared-Canned-Food/Frozen-Food/CP-Frozen-Boneless-Chicken-Thigh-25KG-X-6Packs/p/146146" target="_blank" rel="noopener noreferrer">Costco 線上官網</a></li></ul>]]></content>
        <category label="Food" term="Food"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Blktrace, Blkparse and Fio example]]></title>
        <id>https://hwchiu.com/2017/06/02/blktrace</id>
        <link href="https://hwchiu.com/2017/06/02/blktrace"/>
        <updated>2017-06-02T03:54:37.000Z</updated>
        <summary type="html"><![CDATA[紀錄 blktrace, blkparse 與 fio 的用法]]></summary>
        <content type="html"><![CDATA[<p><strong>blktrace</strong> is a block layer IO tracing mechanism which provide detailed information about request queue operations up to user space.</p><p><strong>blkparse</strong> will combine streams of events for various devices on various CPUs, and produce a formatted output the the event information.
It take the output of above tool <strong>blktrace</strong> and convert those information into fency readable form.</p><p>In the following, We will use those tools <strong>blktrace</strong> and <strong>blkparse</strong> to help us to observe sector numbers which has been written by fio requests.
We will use the fil to generate two diffenrt IO pattern requests, sequence write and random write.</p><h1>Environment</h1><p>OS: Ubuntu 14.04
Storage: NVME
FIO: <strong>fio-2.19-12-gb94d</strong>
blktrace: <strong>2.0.0</strong>
blkparse: <strong>1.1.0</strong></p><p>you can use following commands to install <strong>blktrace</strong> and <strong>blkparse</strong></p><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">apt-get</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">install</span><span class="token plain"> -y blktrace</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>Experiment</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="step1">Step1<a href="#step1" class="hash-link" aria-label="Direct link to Step1" title="Direct link to Step1">​</a></h2><p>In order to make the output of <strong>blkparse</strong> more easily to read, we set the <strong>numjobs</strong> to <strong>1</strong>.
Following is my fio config</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[global]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">iodepth=256</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">numjobs=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">direct=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">time_based</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">runtime=120</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">group_reporting</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">size=5G</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ioengine=libaio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">filename=/dev/nvme1n1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[rw]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bs=4k</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rw=randwrite</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[sw]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bs=64k</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rw=write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>After we setup the fio config, use the fio to generate the IO request. In this example, we ask the fio to generate the IO via <strong>sequence write</strong> pattern.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fio ${path_of_config} section=sw</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>During the experiment, you can use the tool <code>iostat</code> to monitor the I/O information about the device we want to observe.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="step2">Step2<a href="#step2" class="hash-link" aria-label="Direct link to Step2" title="Direct link to Step2">​</a></h2><p>Open other terminal and use <code>blktrace</code> to collection the data, there are two parameter we need to use,
First one is <strong>-d</strong>, which indicate what target device blktrace will monitor to.
Second, is  <strong>-w</strong>, we use it to limit the time (seconds) how long blktrace will run.
So, our final command looks like below.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">blktrace -d /dev/nvme1n1 -w 60</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In the end of <strong>blktrace</strong>, you can discover some new files has created by <strong>blktrace</strong> and its prefix name is <strong>nvme1n1.blktrac.xx</strong>
The number of files is depends how may CPUs in your system.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r--  1 root     root         821152 Jun  2 10:39 nvme1n1.blktrace.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r--  1 root     root       21044368 Jun  2 10:39 nvme1n1.blktrace.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r--  1 root     root         462864 Jun  2 10:39 nvme1n1.blktrace.10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r--  1 root     root         737960 Jun  2 10:39 nvme1n1.blktrace.11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r--  1 root     root         865872 Jun  2 10:39 nvme1n1.blktrace.12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r--  1 root     root         755248 Jun  2 10:39 nvme1n1.blktrace.13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r--  1 root     root        4675176 Jun  2 10:39 nvme1n1.blktrace.14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r--  1 root     root        4471480 Jun  2 10:39 nvme1n1.blktrace.15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r--  1 root     root        5070264 Jun  2 10:39 nvme1n1.blktrace.16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r--  1 root     root        5075040 Jun  2 10:39 nvme1n1.blktrace.17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r--  1 root     root        5062104 Jun  2 10:39 nvme1n1.blktrace.18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r--  1 root     root        5586936 Jun  2 10:39 nvme1n1.blktrace.19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-r--r--  1 root     root        3718848 Jun  2 10:39 nvme1n1.blktrace.2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="step3">Step3<a href="#step3" class="hash-link" aria-label="Direct link to Step3" title="Direct link to Step3">​</a></h2><p>Now, we can use the <strong>blkparse</strong> to regenerate human-readable output form the output we get via <strong>blktrace</strong> before.</p><p>We need to indicate source files, you can just use the device name without <strong>.blktrace.xx</strong>, for example,
<strong>nvmen1</strong>, it will search all files which match the pattern <strong>nvmen1.blktrace.xx</strong> and put together to analyze.
Then, the <strong>-f</strong> option used to foramt the output data, you can find more about it via <strong>man blkparse</strong></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">OUTPUT DESCRIPTION AND FORMATTING</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       The output from blkparse can be tailored for specific use -- in particular, to ease parsing of output, and/or limit output fields to those the user wants to see. The data for fields which can be output include:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       a   Action, a (small) string (1 or 2 characters) -- see table below for more details</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       c   CPU id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       C   Command</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       d   RWBS field, a (small) string (1-3 characters)  -- see section below for more details</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       D   7-character string containing the major and minor numbers of the event's device (separated by a comma).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       e   Error value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       m   Minor number of event's device.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       M   Major number of event's device.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       n   Number of blocks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       N   Number of bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       p   Process ID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       P   Display packet data -- series of hexadecimal values</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       s   Sequence numbers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       S   Sector number</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       t   Time stamp (nanoseconds)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       T   Time stamp (seconds)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       u   Elapsed value in microseconds (-t command line option)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       U   Payload unsigned integer</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>For our observation, we use <strong>%5T.%9t, %p, %C, %a, %S\n</strong> to format our result containing timestamp, command, process ID, action and sequence number.</p><p>Since the data I/O contains many action, such as complete, queued, inserted..ect. we can use option <strong>-a</strong> to filter actions, you can find more info via <strong>man blktrace</strong>.
In this case, we use the <strong>write</strong> to filter the actions.</p><p>In the end, use the <strong>-o</strong> options to indicate the output file name.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">barrier: barrier attribute</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">complete: completed by driver</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fs: requests</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">issue: issued to driver</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pc: packet command events</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">queue: queue operations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">read: read traces</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">requeue: requeue operations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sync: synchronous attribute</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">write: write traces</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">notify: trace messages</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">drv_data: additional driver specific trace</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The command will look like below and it will output the result to file output.txt.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">blkparse nvme1n1 -f "%5T.%9t, %p, %C, %a, %S\n"  -a write -o output.txt</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>open the file, the result looks like</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    0.000000000, 22890, fio, Q, 1720960</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000001857, 22890, fio, G, 1720960</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000005803, 22890, fio, I, 1720960</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000009234, 22890, fio, D, 1720960</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000036821, 0, swapper/0, C, 1996928</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000067519, 22890, fio, Q, 1721088</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000068538, 22890, fio, G, 1721088</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000071531, 22890, fio, I, 1721088</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000073102, 22890, fio, D, 1721088</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000093464, 0, swapper/0, C, 1994624</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000123806, 0, swapper/0, C, 1785472</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000147436, 22892, fio, C, 1784576</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000159977, 22891, fio, C, 1997312</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000166653, 22891, fio, Q, 2006912</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000167632, 22891, fio, G, 2006912</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000169422, 22891, fio, I, 2006912</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000171178, 22891, fio, D, 2006912</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000188830, 22892, fio, Q, 1817728</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000189783, 22892, fio, G, 1817728</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000191405, 22892, fio, I, 1817728</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000192830, 22892, fio, D, 1817728</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000202367, 22891, fio, Q, 2007040</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000203160, 22891, fio, G, 2007040</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000205969, 22891, fio, I, 2007040</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000207524, 22891, fio, D, 2007040</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000227655, 22892, fio, Q, 1817856</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000228457, 22892, fio, G, 1817856</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000231936, 22892, fio, I, 1817856</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">....</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Since the fio will fork to two process to handle the process, we use the <strong>grep</strong> to focus on one specific process (pid=22892).</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">grep "22892, fio" output.txt | more</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, the result seems good, we can discover the sequence number (fifth column) is increasing.
One thing we need to care about is the row which action is "C", which means the completed, since we don't know how NVME handle those request and reply to upper layer. we only need to focus on other action. such as "Q (queued This notes intent to queue i/o at the given location.  No real requests exists yet.)" or "I (inserted A request is being sent to the i/o scheduler for addition to the internal queue and later service by the driver. The request is fully formed at this time)".</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    0.000147436, 22892, fio, C, 1784576</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000188830, 22892, fio, Q, 1817728</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000189783, 22892, fio, G, 1817728</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000191405, 22892, fio, I, 1817728</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000192830, 22892, fio, D, 1817728</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000227655, 22892, fio, Q, 1817856</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000228457, 22892, fio, G, 1817856</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000231936, 22892, fio, I, 1817856</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000233530, 22892, fio, D, 1817856</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000360361, 22892, fio, Q, 1817984</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000361310, 22892, fio, G, 1817984</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000364163, 22892, fio, I, 1817984</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000366696, 22892, fio, D, 1817984</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000536731, 22892, fio, Q, 1818112</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000537758, 22892, fio, G, 1818112</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000539371, 22892, fio, I, 1818112</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000541407, 22892, fio, D, 1818112</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000670209, 22892, fio, Q, 1818240</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000671345, 22892, fio, G, 1818240</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000673383, 22892, fio, I, 1818240</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.000676260, 22892, fio, D, 1818240</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.001885543, 22892, fio, Q, 1818368</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.001887444, 22892, fio, G, 1818368</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.001891353, 22892, fio, I, 1818368</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.001895917, 22892, fio, D, 1818368</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.001934546, 22892, fio, Q, 1818496</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.001935468, 22892, fio, G, 1818496</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.001936891, 22892, fio, I, 1818496</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.001938742, 22892, fio, D, 1818496</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    0.001965818, 22892, fio, Q, 1818624</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now, we can do all above command again and change the <strong>section</strong> to rw for fio using the randon write pattern. The <strong>blkparse</strong> result will show the random sequence number.</p><h1>Summary</h1><p>In this article, we try to use tools <strong>blktrace</strong> and <strong>blkparse</strong> to analysiz the block level I/O  for <strong>fio</strong> request.
We observe the filed <strong>sequence number</strong> to make sure thhat the fio can generate the <strong>sequence</strong> or <strong>random</strong> according to its config.</p><h1>Reference</h1><ul><li><a href="http://fibrevillage.com/storage/539-blktrace-and-btt-example-to-debug-and-tune-disk-i-o-on-linux" target="_blank" rel="noopener noreferrer">539-blktrace-and-btt-example-to-debug-and-tune-disk-i-o-on-linux</a></li></ul>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="Linux" term="Linux"/>
        <category label="Kernel" term="Kernel"/>
        <category label="System" term="System"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[perf_for_drbd_9.0]]></title>
        <id>https://hwchiu.com/2017/05/19/perf-for-drbd</id>
        <link href="https://hwchiu.com/2017/05/19/perf-for-drbd"/>
        <updated>2017-05-19T17:57:24.000Z</updated>
        <summary type="html"><![CDATA[本文主要嘗試分析 drbd(9.0) 於 kernel運行時的效能分析，希望藉由 perf 這個 tool 來分析整個程式運行的狀況，藉此觀察其運行時各 function 的比例。]]></summary>
        <content type="html"><![CDATA[<p>本文主要嘗試分析 drbd(9.0) 於 <strong>kernel</strong>運行時的效能分析，希望藉由 <strong>perf</strong> 這個 tool 來分析整個程式運行的狀況，藉此觀察其運行時各 function 的比例。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="testing-environment">Testing Environment<a href="#testing-environment" class="hash-link" aria-label="Direct link to Testing Environment" title="Direct link to Testing Environment">​</a></h3><p>為了進行效能上的分析，首要條件就是先將 <strong>DRBD</strong> 給衝到效能瓶頸才有機會去觀察，所以本文採用下列的環境與工具來進行這項作業</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="environment">Environment<a href="#environment" class="hash-link" aria-label="Direct link to Environment" title="Direct link to Environment">​</a></h4><p>CPU: Intel(R) Xeon(R) CPU E5-2695 v3 @ 2.30GHz
Storage: Non-Volatile memory controller(NVME)
Tool: <a href="https://github.com/axboe/fio" target="_blank" rel="noopener noreferrer">fio</a>
OS: Ubuntu 16.04 with linux 4.4.0-78-generic</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="setup">Setup<a href="#setup" class="hash-link" aria-label="Direct link to Setup" title="Direct link to Setup">​</a></h4><p>為了更方便觀察 drbd 的運行，我們將 drbd 創造的 kernel thread 都分別綁在不同的 cpu 上，這樣可以讓每隻 kernel thread 盡可能去使用cpu。</p><ol><li>透過 <code>ps</code> or <code>htop</code> 取得 kernel thread 的 <strong>pid</strong>,這邊可以關注的有<ul><li>drbd_s_r0 (sender)</li><li>drbd_r_r0 (receiver)</li><li>drbd_as_r0 (ack sender)</li><li>drbd_a_r0 (ack receiver)</li><li>drbd_w_r0 (worker)</li></ul></li><li>透過 <code>taskset</code> 這個指令將上述程式分別綁到不同的 cpu 上</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">taskset -p 0x100 18888</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="stress">Stress<a href="#stress" class="hash-link" aria-label="Direct link to Stress" title="Direct link to Stress">​</a></h4><p>本文使用 <strong>fio</strong> 來進行資料的讀取，下方提供一個簡易的 fio 設定檔，可依照自行的環境變換修改。</p><div class="language-config codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-config codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[global]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">iodepth=512</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">numjobs=3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">direct=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">time_based</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">runtime=30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">group_reporting</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">size=5G</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ioengine=libaio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">filename=/mnt/beegfs/fio1.test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[rrw]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bs=4k</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rw=randrw</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rwmixread=75</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[rr]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bs=4k</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rw=randread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[rw]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bs=4k</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rw=randwrite</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[sr]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bs=64k</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rw=read</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[sw]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bs=64k</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rw=write</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我們 fio 採用 client/server 的架構，要是可支援多台 client 同時一起進行資料讀取，提供更高的壓力測試。</p><p>假設該設定檔名稱為 <strong>fio.cfg</strong>，並且放置於 <strong>/tmp/fio.cfg</strong>
則首先在 <strong>node-1</strong> 上面執行下列指令以再背景跑一個 fio server</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fio -S &amp;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>接下來要運行的時候，執行下列指令來運行 fio，其中若想要改變測試的類型，可透過 <strong>--secion</strong>進行切換。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/fio --client=node-1 /tmp/fio.cfg --section=rw</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>這時候可以透過 <strong>htop</strong> 以及 <strong>iostat</strong> 的資訊去觀察，如下圖
當前透過 <strong>iostat</strong> 觀察到的確對 <strong>drbd0</strong> 有大量的讀寫動作
<img loading="lazy" src="http://i.imgur.com/C7EKH2f.jpg" class="img_ev3q">
同時由 <strong>htop</strong> (記得開啟 kernel thread觀察功能)，可以看到 <strong>drbd_s_r0</strong> 以及 <strong>drbd_a_r0</strong> 都各自吃掉一個 cpu，大概都快接近 100% 的使用率。
<img loading="lazy" src="http://i.imgur.com/neMXdHE.jpg" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="profile">Profile<a href="#profile" class="hash-link" aria-label="Direct link to Profile" title="Direct link to Profile">​</a></h4><p>有了上述的環境後，我們就可以準備來分析 drbd 程式碼運行狀況。</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="environemnt">Environemnt<a href="#environemnt" class="hash-link" aria-label="Direct link to Environemnt" title="Direct link to Environemnt">​</a></h6><p>這邊使用 <strong>perf</strong> 這套程式來分析，基本上 <strong>kernel</strong> 新一點的版本都已經內建此功能了，比較舊的 <strong>kernel</strong> 則需要自己重新開啟該 <strong>kernel config</strong>然後重新 build kernel，所以這邊使用 <strong>Ubuntu 16.04 with linux 4.4.0-78-generic</strong> 相對起來非常簡單。</p><p>直接執行 <code>perf</code> 這個指令，若系統上有缺少 <strong>linux-tools-4.4.0-78</strong> 相關 tool 的話會有文字提示你，如下所示，按照提示使用 <strong>apt-get</strong> 將相關的套件安裝完畢後，就可以使用 <strong>perf</strong> 了。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">WARNING: perf not found for kernel 4.4.0.78</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  You may need to install the following packages for this specific kernel:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    linux-tools-4.4.0-78-4.4.0-78</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    linux-cloud-tools-4.4.0-78-4.4.0-78</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="run">Run<a href="#run" class="hash-link" aria-label="Direct link to Run" title="Direct link to Run">​</a></h5><p>perf 的功能非常強大，可以參考 <a href="https://perf.wiki.kernel.org/index.php/Tutorial" target="_blank" rel="noopener noreferrer">wiki</a>, 這邊我們使用 <strong>perf top</strong> 的方式來觀察結果。
為了可以順便觀看 <strong>call graph</strong> 的過程，再執行<code>perf</code>的時候要多下<code>-g</code>這個參數</p><p>指令為 <strong>perf top -g -p $PID</strong>，如 <strong>perf top -g -p 18888</strong>。</p><p>在這邊我嘗試觀察 <strong>drbd_a</strong> 這隻，結果如下列</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="drbd_a">drbd_a<a href="#drbd_a" class="hash-link" aria-label="Direct link to drbd_a" title="Direct link to drbd_a">​</a></h5><p>這邊可以觀察到三隻吃比較兇的 <strong>function</strong> 都吃很兇,分別是 <strong>native_queue_spin_lock_slowpath</strong> 、 <strong>tr_release</strong> 以及 <strong>idr_get_next</strong>。</p><p>這邊比較麻煩的是你看這個只能知道就是卡在 spin_locK，系統上是不是 multithread，然後有太多的資料要搬移導致 spin_lock ? 這些搬移的資料是誰放進去的?，這些資料是什麼?</p><p>以及更多的問題都必須要看程式碼去理解其整體設計架構，才有辦法講出一套完整的流程說明這個結果。</p><p>這部份等之後能夠完整理解整個 drbd 的 write-path 或是 read-path 時再重新來看一次這張圖，到時候應該會有完全不一樣的思維。</p><p><img loading="lazy" src="http://i.imgur.com/Bi1ZKqn.jpg" class="img_ev3q"></p>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="DRBD" term="DRBD"/>
        <category label="performance" term="performance"/>
        <category label="System" term="System"/>
        <category label="Linux" term="Linux"/>
        <category label="Kernel" term="Kernel"/>
        <category label="Tool" term="Tool"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[curl with fewer malloc]]></title>
        <id>https://hwchiu.com/2017/07/05/curl-malloc</id>
        <link href="https://hwchiu.com/2017/07/05/curl-malloc"/>
        <updated>2017-05-05T18:22:03.000Z</updated>
        <summary type="html"><![CDATA[不久前有一篇文章https://daniel.haxx.se/blog/2017/04/22/fewer-mallocs-in-curl/指出， curl 開發者嘗試將 malloc 呼叫的次數減少，結果對整體的影響帶來的顯著的提升]]></summary>
        <content type="html"><![CDATA[<p>不久前有一篇文章<a href="https://daniel.haxx.se/blog/2017/04/22/fewer-mallocs-in-curl/" target="_blank" rel="noopener noreferrer">https://daniel.haxx.se/blog/2017/04/22/fewer-mallocs-in-curl/</a>指出， curl 開發者嘗試將 malloc 呼叫的次數減少，結果對整體的影響帶來的顯著的提升</p><p>使用 <code>curl http://localhost/512M</code> 當作第一個比較
原始版本的 curl 關於 malloc 相關數據如下</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Mallocs: 33901</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Reallocs: 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Callocs: 24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Strdups: 31</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Wcsdups: 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Frees: 33956</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Allocations: 33961</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Maximum allocated: 160385</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而修改後的版本為</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Mallocs: 69</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Reallocs: 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Callocs: 24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Strdups: 31</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Wcsdups: 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Frees: 124</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Allocations: 129</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Maximum allocated: 153247</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>比較起來可以發現， malloc 呼叫的次數有急遽的下降，從 33901 降落到 69，而整體使用的記憶體也少了 7KB 左右
此外，若比較兩者傳輸的速度，抓取一個 80GB 的檔案</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Original: 2200MB/sec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Modified: 2900MB/sec</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在傳輸方面提升了 30% 左右的速率，非常驚人
若使用 time 指令來比較新舊版本抓取 80G 檔案的差別</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Old code:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">real    0m36.705s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">user    0m20.176s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sys     0m16.072s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">New code:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">real    0m29.032s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">user    0m12.196s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sys     0m12.820s</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>修改相關的 commit 如下</p><ul><li><a href="https://github.com/curl/curl/commit/cbae73e1dd95946597ea74ccb580c30f78e3fa73" target="_blank" rel="noopener noreferrer">llist: no longer uses malloc</a></li><li><a href="https://github.com/curl/curl/commit/5f1163517e1597339d" target="_blank" rel="noopener noreferrer">multi: make curl_multi_wait avoid malloc in the typical case</a></li></ul><p>簡單來說就是將 malloc 的部分都拔除，盡量使用 stack 來提供記憶體，藉此減少呼叫 malloc 的部分。
主要是因為 curl 在傳輸的過程中，會有非常大量且小空間的 malloc 被呼叫到，這部分拖慢的整體的運行速度</p>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="System" term="System"/>
        <category label="Tool" term="Tool"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 314]]></title>
        <id>https://hwchiu.com/2017/03/01/leetcode-314</id>
        <link href="https://hwchiu.com/2017/03/01/leetcode-314"/>
        <updated>2017-03-01T05:04:00.000Z</updated>
        <summary type="html"><![CDATA[314 Binary Tree Vertical Order Traversal]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="314-binary-tree-vertical-order-traversal">314 Binary Tree Vertical Order Traversal<a href="#314-binary-tree-vertical-order-traversal" class="hash-link" aria-label="Direct link to 314 Binary Tree Vertical Order Traversal" title="Direct link to 314 Binary Tree Vertical Order Traversal">​</a></h2><p>原題目是付費題目，有興趣看到完整的請自行付費觀賞，在此就不提供超連結了。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction">Introduction<a href="#introduction" class="hash-link" aria-label="Direct link to Introduction" title="Direct link to Introduction">​</a></h2><ul><li>給定一個 binary tree，將此 tree 以 vertical 的方式走過，</li><li>輸出時，從最左邊開始輸出</li><li>相同 colume 的算同一個 group，若屬於同 row 且同 colume，則從左邊開始算起</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="example">Example<a href="#example" class="hash-link" aria-label="Direct link to Example" title="Direct link to Example">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">        0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   / \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  1   4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> / \ / \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2   35  6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           / \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          7   8</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>輸出為
<!-- -->[2][1]<!-- -->
<!-- -->[0,3,5][4,7]<!-- -->
<!-- -->[6][8]</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="solution">Solution<a href="#solution" class="hash-link" aria-label="Direct link to Solution" title="Direct link to Solution">​</a></h2><p>這題不太困難，基本上可以採用 BFS 來搜尋整個 tree，然後加入一個 index 的欄位，root 的 index 是 0，往左遞減，往右遞增，在 BFS 的過程中，就把相同 index 都收集起來，最後再一口氣輸出即可。</p><p>pseudo code 如下</p><div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">queue</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">push</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">pair</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> root</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">while</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">!</span><span class="token plain">queue</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">empty</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      index </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> queue</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">front</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">first</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      node </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> queue</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">front</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">second</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ans</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">index</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">push</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">node</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">val</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">node</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">left</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          queue</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">push</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">pair</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">index</span><span class="token operator" style="color:#393A34">-</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> node</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">left</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">node</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">right</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          queue</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">push</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">pair</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">index</span><span class="token operator" style="color:#393A34">+</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> node</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">right</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> ans</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="coding" term="coding"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Anki 使用感想]]></title>
        <id>https://hwchiu.com/2017/03/01/anki-thoughts</id>
        <link href="https://hwchiu.com/2017/03/01/anki-thoughts"/>
        <updated>2017-03-01T04:34:00.000Z</updated>
        <summary type="html"><![CDATA[還記得以前在工三讀書時，常常看到 Chun Norris 坐在我前面，然後畫面上是一張一張的卡片在不停地翻動，每張卡片上面都標記者一個日文單字， 看他快速地翻閱這些卡片，感覺就是在背頌單字，那時候也就沒有去想太多了。]]></summary>
        <content type="html"><![CDATA[<p>還記得以前在工三讀書時，常常看到 Chun Norris 坐在我前面，然後畫面上是一張一張的卡片在不停地翻動，每張卡片上面都標記者一個日文單字， 看他快速地翻閱這些卡片，感覺就是在背頌單字，那時候也就沒有去想太多了。</p><p>沒想到過了幾年後，Chun Norris 竟然出書了!!!
<img loading="lazy" src="http://cdn.kingstone.com.tw/book/images/product/20180/2018052742456/2018052742456b.jpg" class="img_ev3q">
<a href="http://www.books.com.tw/products/0010740471" target="_blank" rel="noopener noreferrer">英、日語同步Anki自學法：我是靠此神器，最短時間通過日檢N1、多益975分</a></p><p>看到這個消息後，就馬上預購了一本這個書，不但捧朋友的場，同時也順便瞭解看看到底 Anki 是什麼樣的東西。</p><p>對於想瞭解 Anki 基本操作的，可以參考<a href="http://blog.chunnorris.cc/2016/04/anki1.html" target="_blank" rel="noopener noreferrer">這邊</a>
經過了一陣摸索後，也開始使用了 Anki 來幫助我背單字，不過由於內建的一些卡片集(Deck)大都偏向特定主題，如托福、多益等
，所以我後來也自己創建了一個卡片集給我自己使用。
在卡片編輯的部分，原本都是透過Anki application上面的 GUI 去操作編輯，填寫正反兩面的卡片資訊。
所以本來的流程是這樣</p><ol><li>我看小說/文章</li><li>使用手機的 APP 去查詢單字</li><li>定期開啟 Anki 將 APP 內的歷史單字一個一個透過線上字典服務去查詢</li><li>將查詢的結果複製貼上到 Anki內，並轉成Anki的卡片</li></ol><p>上面第三步驟最花費時間，當卡片數量一多的時候，其實要非常可怕的
那時候APP內大概有五六百個查詢過的單字，每個單字花20秒去填寫，也要整整三個小時不間斷才有辦法處理完畢。</p><p>有鑑於未來單字量只會愈來愈多，這樣手動下去實在不是辦法，因此腦筋就轉了彎一下，看有沒有辦法讓上面的步驟簡單化
上述(1),(2)這兩個步驟是不可避免的，那(3),(4)這兩個步驟就是主要處理的對象了。</p><p>針對我的目標，我將其拆成兩部分</p><ol><li>給定一個單字，想辦法自動獲得其<strong>發音</strong>及<strong>解釋</strong></li><li>從上述的輸出中，將其自動變成 Anki 的卡片，然後塞到我的卡片集(Deck)中</li></ol><p>針對第一點，我使用 python 作為我的程式語言，然後很偷懶的就拿了 yahoo 字典當作我的搜索來源
於是用了 python + BeautifulSoup + urllib 來爬網頁，
於是就網頁爬阿爬~就爬出了<strong>發音</strong>跟<strong>解釋</strong>了，這邊一切搞定</p><p>再來第二點，想要自動加入倒 Anki 的資料庫中，於是就到github去翻一翻，還真的翻到有人寫好已經可以用的工具
<a href="https://github.com/nheinric/addToAnki" target="_blank" rel="noopener noreferrer">addToAnki</a>，這個作者使用 python 撰寫，提供一個 tool 讓第三方可以將卡片的內容輸入進去後，自動轉為卡片並且塞到對應的卡片集中。
雖然我個人是更偏向去呼叫 library 而不是只接呼叫 tool 來處理，不過我的目的能達成就好，所以就將我前面的程式碼跟他的結合起來。目前將此結果放在<a href="https://github.com/hwchiu/addToAnki/tree/master/examples/YahooDict" target="_blank" rel="noopener noreferrer">這邊</a>
同時我也發送了一個 pull request 到原先作者那邊，把我的使用情境當作一個多的範例使用，不過我看作者也兩三年沒碰了，應該也不會去接收我的 PR XDD</p><p>最後我的流程就是</p><ol><li>遇到不會的單字</li><li>使用手機查詢單字</li><li>定期將查詢過的單字匯出成一個文字檔</li><li>將該文字檔送給我的 python 去處理，等他自動處理好即可。</li></ol><p>上次一口氣加了四百多個單字，總共花費十五分鐘左右，大部分的時間應該都是消耗再去爬 yahoo dict這邊，目前這樣已經滿足我的需求。</p>]]></content>
        <category label="System" term="System"/>
        <category label="Anki" term="Anki"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git 筆記]]></title>
        <id>https://hwchiu.com/2014/07/28/git</id>
        <link href="https://hwchiu.com/2014/07/28/git"/>
        <updated>2014-07-28T13:04:00.000Z</updated>
        <summary type="html"><![CDATA[Basic]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="basic">Basic<a href="#basic" class="hash-link" aria-label="Direct link to Basic" title="Direct link to Basic">​</a></h2><ul><li><p>commit所使用的編輯器會依照下列優先度去選擇，</p><ol><li>GIT_EDITOR 環境變數</li><li>core.editor 的設定</li><li>VISUAL 環境變數</li><li>EDITOR 環境變數</li><li>vi 指令</li></ol></li><li><p>變動檔案請用 <code>git mv</code>，使用<code>git rm</code>要注意檔案系統內的檔案會被真的刪除。</p></li><li><p><code>git log</code>可以列出簡略的coommit資訊</p></li><li><p><code>git show [commit id]</code> 可以看詳細的commit資訊，可以加上commit ＩＤ來指定特定的commit</p></li><li><p><code>git show-branch --more=10</code> 可以看當前bracnh的詳細commit資訊，由<strong>--more</strong>控制數量</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="configuraion">Configuraion<a href="#configuraion" class="hash-link" aria-label="Direct link to Configuraion" title="Direct link to Configuraion">​</a></h2><p>總共有三種設定方式，優先度如順序</p><ul><li>.git/config， 可以用 <code>--file</code>或是預設的方式操作</li><li>~/.gitconfig， 可以用 <code>--global</code>操作</li><li>/etc/gitconfig，可以用 <code>--system</code>操作</li></ul><div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">git config --global user.name "hwchiu" (2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">git config user.email "hwchiu@cs.nctu.edu.tw" (1)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>可以透過 <code>git config -l</code>列出當前所有的設定</li><li>可以透過 <code>--unset</code>來移除設定</li></ul><div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">git config --unset --global user.name</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="Git" term="Git"/>
        <category label="System" term="System"/>
        <category label="Tool" term="Tool"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shell Script 筆記]]></title>
        <id>https://hwchiu.com/2013/11/24/shell-note</id>
        <link href="https://hwchiu.com/2013/11/24/shell-note"/>
        <updated>2013-11-24T12:39:00.000Z</updated>
        <summary type="html"><![CDATA[記錄一些之前寫 Shell Script 作業的心得與筆記]]></summary>
        <content type="html"><![CDATA[<p>本篇文章是用來記錄以前修課關於 Shell Script 的作業</p><h1>Introduction</h1><p>用Unix的指令，透過pipe的方式完成下列要求</p><ul><li>計算當前目錄底下資料夾的總數</li><li>計算當前目錄底下檔案總數<ul><li>只有計算regular file.不考慮FIFO、LINK</li></ul></li><li>計算所有檔案大小和 (Byte)</li><li>顯示前五大的檔案名稱</li><li>只能使用PIPE，不能使用 <code>$$</code> <code>;</code> <code>||</code> <code>&amp;</code> <code>&gt;</code> <code>&gt;&gt;</code> <code>&lt;</code></li></ul><h1>Implement</h1><ul><li>使用<code>ls</code>來取得所有資料夾跟檔案的資訊<ul><li>-l  可以顯示詳細資訊，這邊我們要取得的是 檔案大小</li><li>-R  遞迴的往每個資料夾繼續往下找</li><li>-A  不要把<code>.</code>跟<code>..</code>給顯示出來，因為這種當前目錄的東西我們不需要</li></ul></li><li>使用<code>sort</code>來幫忙排序，找出檔案大小前五個<ul><li>-r  排序結果反過來，由大到小排序</li><li>-n  排序的時候，採用數字的方式去排序，不使用字母大小去排序</li><li>-k  指定第幾個欄位要排序</li></ul></li><li>使用<code>awk</code>作最後的處理，找出前五大，印出所有檔案大小和<ul><li>因為再<code>ls -l</code>的結果中，會有很多資訊，包含 <code>./cs/.svn/pristine/74:</code> 或者 <code>total 28</code>，所以awk再處理的時候，先用NF判斷該行的欄位數，至少要有9個欄位才處理 <code>if(NF&gt;=9)</code></li><li>接下來針對檔案是資料夾還是檔案，做全部的計數，可以由 <code>-rw-r--r--</code> 的第一個欄位來決定，如果是d就代表資料夾，否則就是檔案。 這邊我使用 regular expression來判斷 <code>($1 ~/^d/)? (dir=dir+1) : (file=file+1)(size=size+$5)</code>，此外如果是檔案得話，就順便把大小也計算一下</li><li>執行過程中，因為剛剛已經排序過了，所以 前六行都把大小印出來， <code>if(NR&lt;6) print NR": "$5" "$9}</code></li><li>最後就把所有資訊都列印出來</li></ul></li></ul><div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ls -RlA | sort -rnk 5 | awk '{ if(NF&gt;=9) ($1 ~/^d/)? (dir=dir+1) : (file=file+1)(size=size+$5); if(NR&lt;6) print NR": "$5" "$9} END{ print "Dir = "dir"\n" "    File = " file"\n" "total = "size}'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="System" term="System"/>
        <category label="Tool" term="Tool"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZFS 筆記]]></title>
        <id>https://hwchiu.com/2013/10/12/zfs</id>
        <link href="https://hwchiu.com/2013/10/12/zfs"/>
        <updated>2013-10-12T17:53:00.000Z</updated>
        <summary type="html"><![CDATA[之前機器因為ZFS空間滿了，因為平常有再作snapshot的緣故，導致東西都刪除不了]]></summary>
        <content type="html"><![CDATA[<p>之前機器因為ZFS空間滿了，因為平常有再作snapshot的緣故，導致東西都刪除不了
因為刪除的時候都會有一些metadata的寫入，導致整個zfs動彈不得，這時候就花了很多時間再研就怎麼處理
這邊稍微記錄一下ZFS相關得操作。
ZPOOL的來源可以是device也可以是files,這邊就用兩個檔案當作來源。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="files">Files<a href="#files" class="hash-link" aria-label="Direct link to Files" title="Direct link to Files">​</a></h2><ul><li><code>sudo dd if=/dev/zero of=/zfs1 bs=1M count=256</code></li><li><code>sudo dd if=/dev/zero of=/zfs2 bs=1M count=256</code></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="zpool">Zpool<a href="#zpool" class="hash-link" aria-label="Direct link to Zpool" title="Direct link to Zpool">​</a></h2><ul><li>create a mirror pool<ul><li><code>zpool create ftphome mirror /zfs1 /zfs2</code></li></ul></li><li>destroy a pool<ul><li><code>zpool destroy ftphome</code></li></ul></li><li>check zpool status<ul><li><code>zpool status &lt;pool&gt;</code></li></ul></li><li>export pool ( 把某些pool export出去，暫時不使用)<ul><li><code>zpool export ftphome</code></li></ul></li><li>import pool ( 把被export 的pool 重新import回來)<ul><li><code>zpool import -d /  ftphome</code>  (用-d指定你檔案的位置，預設會去吃/dev/)</li><li>以我的範例來說，當import回來後，名稱會變成 <code>//zfs1</code>, <code>//zfs2</code>，多了一個/，原因不明中。</li></ul></li><li>attach ( 只能對mirror使用)<ul><li><code>zpool attach ftphome /xxx</code></li></ul></li><li>detach ( 只能對mirror使用)<ul><li><code>zpool detach ftphome /zfs1</code></li></ul></li></ul><p>還有<code>offline</code>,<code>online</code>,<code>remove</code>...，剩下的就要用的時候去man zpool,還滿詳細說明的。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="zfs-database">ZFS database<a href="#zfs-database" class="hash-link" aria-label="Direct link to ZFS database" title="Direct link to ZFS database">​</a></h2><ul><li>set attributes <code>zfs set key=value &lt;filesystem|volume|snapshot&gt; </code><ul><li><code>zfs get compression ftphome</code></li><li><code>zfs set mountpoint=/home/ftp ftphome</code></li></ul></li><li>get attributes <code>zfs get key &lt;filesystem|volume|snapshot&gt; </code><ul><li><code>zfs get compression ftphome</code></li></ul></li><li>snapshot<ul><li><code>zfs snapshot ftphome@today </code></li><li><code>zfs list -t snapshot</code></li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="其他">其他<a href="#其他" class="hash-link" aria-label="Direct link to 其他" title="Direct link to 其他">​</a></h2><ul><li>假如你的ZFS有使用snapshot同時空間又滿的話，這時候會發現所有檔案都會刪除失敗，都會得到空間不足的訊息,這邊稍微模擬一下該情況，並且想辦法解決此問題。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="模擬情況">模擬情況<a href="#模擬情況" class="hash-link" aria-label="Direct link to 模擬情況" title="Direct link to 模擬情況">​</a></h3><p><strong>snatshot 該zfs</strong></p><ul><li><code>zfs snapshot ftphome@today</code></li><li><code>zfs list -t snapshot</code>   看一下是否有成功</li></ul><p><strong>塞爆該空間</strong></p><ul><li><code>zfs list</code> 看一下還剩下多少空間</li><li><code>dd if=/dev/random of=/home/ftp/file bs=1M count=256</code></li><li><code>cd /home/ftp</code></li><li><code>rm file</code>  =&gt; 應該會得到 <code>No space left on device</code>空間不足的訊息。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="解決問題">解決問題<a href="#解決問題" class="hash-link" aria-label="Direct link to 解決問題" title="Direct link to 解決問題">​</a></h3><p>ZFS 變大容易(多塞個硬碟即可)，變小困難(幾乎無法)，因此當ZFS的硬碟滿的時候，有兩種做法</p><ol><li>再加入兩個新的硬碟，然後合併到目前的zpool,可是這樣就會變成有兩份mirror。</li><li>準備兩個更大的硬碟，把原本的zpool內的data全都複製過去。
這邊使用第二種做法</li></ol><p><strong>先幫本來的pool加入一個檔案，增加本來的空間，如此一來才可以做更多操作</strong></p><ul><li><code>dd if=/dev/zero of=/zfs5 bs=1M count=128</code></li><li><code>dd if=/dev/zero of=/zfs6 bs=1M count=128</code></li><li><code>zpool add ftphome mirror /zfs5 /zfs6</code></li><li><code>zfs list</code>
(此時可以看到本來的空間變大了)</li></ul><p><strong>創造一個更大的zpool來取代</strong></p><ul><li><code>dd if=/dev/zero of=/zfs3 bs=1M count=512</code></li><li><code>dd if=/dev/zero of=/zfs4 bs=1M count=512</code></li><li><code>zpool create ftphome3 mirror /zfs3 /zfs4</code></li><li><code>zfs set compression=gzip-9 ftphome2</code></li></ul><p><strong>把資料複製過去</strong></p><ul><li><code>zfs snapshot ftphome@send</code></li><li><code>zfs send ftphome@send | zfs receive -F ftphome2</code></li><li><code>zfs list</code> 看一下大小是否相同</li></ul><p><strong>mount新的，舊的砍掉</strong></p><ul><li><code>zfs umount ftphome</code></li><li><code>zfs set mountpoint=/home/ftp/ ftphome2</code></li><li><code>zpool destroy ftphome</code></li></ul><p>做到這邊，就算完成了，成功的把本來的資料複製過去。
如果想要改變zpool的名稱，可以用<code>export</code>跟<code>import</code>來改名稱。</p>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="FreeBSD" term="FreeBSD"/>
        <category label="System" term="System"/>
        <category label="ZFS" term="ZFS"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vim & Nerdtree]]></title>
        <id>https://hwchiu.com/2013/10/11/vim-plugin</id>
        <link href="https://hwchiu.com/2013/10/11/vim-plugin"/>
        <updated>2013-10-11T07:48:00.000Z</updated>
        <summary type="html"><![CDATA[最近重新整理vim的設定檔，意外的發現]]></summary>
        <content type="html"><![CDATA[<p>最近重新整理vim的設定檔，意外的發現
<a href="http://yoursachet.com/" target="_blank" rel="noopener noreferrer">http://yoursachet.com/</a>
這個網站滿好用的，可以根據你的需求來自動打造vim設定檔，對於不想動腦去研究設定檔而言的人來說是滿好用的工具
用滑鼠輕鬆點點就可以產生堪用的VIM了!!</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="vimrc-設定">vimrc 設定<a href="#vimrc-設定" class="hash-link" aria-label="Direct link to vimrc 設定" title="Direct link to vimrc 設定">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">set encoding=utf-8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set fileencodings=ucs-bom,utf-8,big5,latin1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set fileencoding=utf-8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set termencoding=utf-8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set number              " 行號</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set statusline=%&lt;\ %n:%f\ %m%r%y%=%-35.(line:\ %l\ of\ %L,\ col:\ %c%V\ (%P)%)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set ai                  " 自動縮排</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">syntax on               " 色彩標示</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set tabstop=4               " tab使用四個空白取代</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set shiftwidth=4            " 縮排空白數，要搭配set cin使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set cin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set cursorline              " 該行的線</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set t_Co=256                " 支援 256 色</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set textwidth=0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set backspace=2             "按下backspace會後退，道行首後會刪除到前一行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set showmatch               "顯示括號配對情況</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set nocompatible            "用vim的特性去運行，捨棄vi的特性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">" Pathogen</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">call pathogen#infect()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">call pathogen#helptags()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">filetype plugin indent on</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">" Nerdtree</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">autocmd VimEnter * NERDTree</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">autocmd VimEnter * wincmd p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let NERDTreeShowBookmarks=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let NERDTreeChDirMode=0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let NERDTreeQuitOnOpen=0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let NERDTreeMouseMode=2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let NERDTreeShowHidden=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let NERDTreeIgnore=['\.pyc','\~$','\.swo$','\.swp$','\.git','\.hg','\.svn','\.bzr']</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let NERDTreeKeepTreeInNewTab=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let g:nerdtree_tabs_open_on_gui_startup=0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set background=dark                 "背景顏色</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">colorscheme wombat</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nnoremap &lt;silent&gt; &lt;F5&gt; :NERDTree&lt;CR&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">"normal mode的時候+數字 可以切換tab</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nnoremap &lt;Esc&gt;1 gt1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nnoremap &lt;Esc&gt;2 gt2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nnoremap &lt;Esc&gt;3 gt3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nnoremap &lt;Esc&gt;4 gt4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nnoremap &lt;Esc&gt;5 gt5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nnoremap &lt;Esc&gt;6 gt6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nnoremap &lt;Esc&gt;7 gt7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nnoremap &lt;Esc&gt;8 gt8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nerdtree">NERDTree<a href="#nerdtree" class="hash-link" aria-label="Direct link to NERDTree" title="Direct link to NERDTree">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="更改呼叫方式使用f5">更改呼叫方式，使用F5<a href="#更改呼叫方式使用f5" class="hash-link" aria-label="Direct link to 更改呼叫方式，使用F5" title="Direct link to 更改呼叫方式，使用F5">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">nnoremap &lt;silent&gt; &lt;F5&gt; :NERDTree&lt;CR&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="在各界面中移動">在各界面中移動<a href="#在各界面中移動" class="hash-link" aria-label="Direct link to 在各界面中移動" title="Direct link to 在各界面中移動">​</a></h3><ul><li>按照順序往下移動 (crtl+w+w)</li><li>上一個view (ctrl+w+h)</li><li>下一個view (ctrl+w+l)</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="切割視窗">切割視窗<a href="#切割視窗" class="hash-link" aria-label="Direct link to 切割視窗" title="Direct link to 切割視窗">​</a></h3><ul><li>水平切割 (在該檔案前按i)</li><li>垂直切割 (在該檔案前按s)
i :水平
s :垂直</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tab使用">tab使用<a href="#tab使用" class="hash-link" aria-label="Direct link to tab使用" title="Direct link to tab使用">​</a></h3><ul><li>開新tab並且切換過去 (t)</li><li>開新tab但不切換過去 (T)</li><li>下一個tab (gt)</li><li>上一個tab (gT)</li></ul>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="Vim" term="Vim"/>
        <category label="System" term="System"/>
        <category label="Tool" term="Tool"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[cscope 使用筆記]]></title>
        <id>https://hwchiu.com/2013/10/05/cscope-note</id>
        <link href="https://hwchiu.com/2013/10/05/cscope-note"/>
        <updated>2013-10-05T09:25:00.000Z</updated>
        <summary type="html"><![CDATA[Introducion]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="introducion">Introducion<a href="#introducion" class="hash-link" aria-label="Direct link to Introducion" title="Direct link to Introducion">​</a></h2><p>Cscope 是一個用來trace code還滿方便的工具
我通常都用他來trace linuxe kernel code,雖然說有網頁版的reference可以使用，但是用起來不順手，網頁會卡卡的
因此還是習慣使用這種互動式的trace tools</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="install">Install<a href="#install" class="hash-link" aria-label="Direct link to Install" title="Direct link to Install">​</a></h2><p><code>sudo apt-get install cscope</code> on <strong>Ubuntu</strong></p><p><code>portmaster devel/cscope</code> on <strong>FreeBSd</strong></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="usage">Usage<a href="#usage" class="hash-link" aria-label="Direct link to Usage" title="Direct link to Usage">​</a></h3><p>詳細的可以參考man page. 通常我只有使用 -R 來觀看而已</p><p>第一次執行的時候，會花比較久的時間去建立一個<strong>cscope.out</strong>的檔案，會把一些相關資訊放進去</p><p>下次執行的時候就會利用該out檔案來作查詢。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="其他">其他<a href="#其他" class="hash-link" aria-label="Direct link to 其他" title="Direct link to 其他">​</a></h3><p>預設的情況下，cscope只能讀取</p><ul><li>.c</li><li>.h</li><li>.l</li><li>.y</li></ul><p>想要讓他讀取java或是cpp的專案，就必須要先自己建置該資料庫</p><ul><li>find ./  -name  *.cpp &gt; cscope.files</li><li>fine ./  -name  *.java &gt;&gt; cscope.files</li><li>cscope -bkq</li></ul><p>前面兩行會把所有的檔案路徑都寫入倒cscope.files裡面</p><ul><li>b:建立索引文件</li><li>k:建立索引文件時不會去搜尋/usr/local/目錄</li><li>q:生成cscope.out，加速索引,該檔案包含<ul><li>locate functions</li><li>function calls</li><li>macros</li><li>variables</li><li>preprocessor symbols</li></ul></li></ul><p>接下來只要使用cscope就可以了</p>]]></content>
        <category label="System" term="System"/>
        <category label="tool" term="tool"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Install News server on FreeBSD 9.1R]]></title>
        <id>https://hwchiu.com/2013/10/05/news-server</id>
        <link href="https://hwchiu.com/2013/10/05/news-server"/>
        <updated>2013-10-05T09:02:00.000Z</updated>
        <summary type="html"><![CDATA[這邊整理一下安裝 news servre on FreeBSD 9.1 時遇到的一些問題，並且筆記一些操作]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="文章轉移">文章轉移<a href="#文章轉移" class="hash-link" aria-label="Direct link to 文章轉移" title="Direct link to 文章轉移">​</a></h2><ul><li>rsync cycbuff</li><li>rsync db/history</li><li>重新建立overview<ul><li>ctlinnd pause 'make overview'</li><li>makehistory -x -O -b
x: won't write out history file entries.
O: Create the overview database
b: Delete any messages found in the spool that do not have valid Message-ID: headers in them.</li><li>makedbz -i
i:To ignore the old database</li><li>ctlinnd go 'over'</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="設定檔檢查">設定檔檢查<a href="#設定檔檢查" class="hash-link" aria-label="Direct link to 設定檔檢查" title="Direct link to 設定檔檢查">​</a></h2><ol><li>inncheck  (inn.conf)</li><li>scanspool -v (active, spool)</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="更新相關設定">更新相關設定<a href="#更新相關設定" class="hash-link" aria-label="Direct link to 更新相關設定" title="Direct link to 更新相關設定">​</a></h2><ul><li>重新編譯innd,進入innd src底下</li><li>./configure --opetions</li><li>make &amp;&amp; make update</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="創新的newsgroup">創新的newsgroup<a href="#創新的newsgroup" class="hash-link" aria-label="Direct link to 創新的newsgroup" title="Direct link to 創新的newsgroup">​</a></h2><ul><li>ctlinnd newgroup name</li><li>modity db/newsgroup</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="其他">其他<a href="#其他" class="hash-link" aria-label="Direct link to 其他" title="Direct link to 其他">​</a></h2><ol><li>創新newsgorup</li></ol><ol><li>執行innd &amp; nnrpd 會噴權限不足<ul><li>檢查/news/bin/innbind 有無SUID</li></ul></li></ol>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="System" term="System"/>
        <category label="FreeBSD" term="FreeBSD"/>
        <category label="Tool" term="Tool"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Install Sphinx on Ubuntu 12.04 LTS]]></title>
        <id>https://hwchiu.com/2013/10/05/sphinx</id>
        <link href="https://hwchiu.com/2013/10/05/sphinx"/>
        <updated>2013-10-05T09:01:00.000Z</updated>
        <summary type="html"><![CDATA[Sphinx是一套建置說明文建的軟體，本身是用python寫成的,目前使用Sphinx這套軟體來當作會議紀錄]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="install">Install<a href="#install" class="hash-link" aria-label="Direct link to Install" title="Direct link to Install">​</a></h2><p>直接透過atp-get 安裝即可</p><p><code>sudo apt-get install sphinx</code></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="config">Config<a href="#config" class="hash-link" aria-label="Direct link to Config" title="Direct link to Config">​</a></h2><p>安裝完畢後，執行</p><p><code>sphinx-quickstart</code>就可以基本設定了</p><p>每個選項都有說明，基本上都採用預設值即可</p><ul><li><p>設定檔: conf.py</p><ul><li>外掛管理</li><li>資料夾結構管理</li><li>一些通用參數，如作者名稱，版本...等</li></ul></li><li><p>主要的檔案: index.rst
-. 檔案的結構
-. toctree</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="indexrsta">index.rsta<a href="#indexrsta" class="hash-link" aria-label="Direct link to index.rsta" title="Direct link to index.rsta">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Lab Meetgins</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">=============</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.. toctree::</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   :maxdepth: 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   :titlesonly:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   20130924.rst</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   20131001.rst</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">國科會 meetings</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">===============</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.. toctree::</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   :maxdepth: 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   :titlesonly:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   20130925.rst</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>這邊我定義兩個toctree，每個toctree底下又會有其他的rst，結構大概是這樣</p><ul><li>Lab Meetings<ul><li>20130924.rst</li><li>20131001.rst</li></ul></li><li>國科會 meetings<ul><li>20130925.rst</li></ul></li></ul><p>總共兩個分類，每個分類底下的文章都是一個額外的rst檔案</p><p>在toctree底下的都是一些設定參數</p><ul><li>maxdepth : 最大深度</li><li>titlesonly : 在首頁面只顯示子類的標題</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="write">Write<a href="#write" class="hash-link" aria-label="Direct link to Write" title="Direct link to Write">​</a></h2><p>Sphinx採用的<code>reStructuredText</code>
格式跟markdown很類似，但是複雜了一些
官方網站有滿詳細的介紹，有需要時再去參考即可</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="build">Build<a href="#build" class="hash-link" aria-label="Direct link to Build" title="Direct link to Build">​</a></h2><p>如果想要轉成html網頁，有兩種方法可以執行</p><ol><li><p>sphinx-build -b html .  NSLMeeting
意思是建置html的網頁， 然後以當前目錄為source 來源，然後把檔案build到NSLMetting去。</p></li><li><p>make html
在Makefile中定義了相關得動作，當執行<code>make html</code>的時候，其實就是執行
<code>sphinx-build -b html . _build/html</code></p></li></ol><p>這邊因為我想要直接弄到別的資料夾，所以我直接設定aliase去執行方法1</p><p>目前對於這套軟體還在學習階段，有任何學習會繼續紀錄。</p>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="System" term="System"/>
        <category label="Ubuntu" term="Ubuntu"/>
        <category label="Tool" term="Tool"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Execution Floodlight]]></title>
        <id>https://hwchiu.com/2013/08/21/floodlight-env</id>
        <link href="https://hwchiu.com/2013/08/21/floodlight-env"/>
        <updated>2013-08-21T04:39:00.000Z</updated>
        <summary type="html"><![CDATA[記錄一下執行floodlight時，有ㄧ些參數可以使用，都是用來指定設定檔的位置。]]></summary>
        <content type="html"><![CDATA[<p>記錄一下執行floodlight時，有ㄧ些參數可以使用，都是用來指定設定檔的位置。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="floodlight-configuraion">Floodlight configuraion:<a href="#floodlight-configuraion" class="hash-link" aria-label="Direct link to Floodlight configuraion:" title="Direct link to Floodlight configuraion:">​</a></h3><p><strong>--configFile ${configuration path}</strong></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="log-configuraion">Log configuraion:<a href="#log-configuraion" class="hash-link" aria-label="Direct link to Log configuraion:" title="Direct link to Log configuraion:">​</a></h3><p><strong>-Dlogback.configurationFile=${FL_LOGBACK}</strong></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="範例">範例<a href="#範例" class="hash-link" aria-label="Direct link to 範例" title="Direct link to 範例">​</a></h2><p><code>java -Dlogback.configurationFile=logback.xml floodlight.jar --configFile floodlightdefault.properties</code></p>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="SDN" term="SDN"/>
        <category label="Openflow" term="Openflow"/>
        <category label="Network" term="Network"/>
        <category label="Floodlight" term="Floodlight"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python-pack_unpack]]></title>
        <id>https://hwchiu.com/2013/07/01/python-pack-unpack</id>
        <link href="https://hwchiu.com/2013/07/01/python-pack-unpack"/>
        <updated>2013-07-01T13:06:00.000Z</updated>
        <summary type="html"><![CDATA[pack & unpack]]></summary>
        <content type="html"><![CDATA[<p>pack &amp; unpack</p><p>根據特定的格式來讀取或封裝資料。</p><p>格式部份分成兩個部份</p><p>byte-order:
這邊可以決定採用big-endian 或是 little endian，
如果沒有給的話，預設是採用系統的方式去做，那這邊比較要注意到的是
以前再寫C語言的時候，都會有所謂的htons...類的轉換，在這邊可以使用'!'
這個符號來解決這個問題，他會自己使用network的Byte order rule去解讀資料，所以有在用網路連線傳資料的話，一定要用！
避免資料解讀錯誤的問題。</p><p>format-characters:</p><p>常用的有</p><ul><li>x:pad byte,就忽略他</li><li>h:short,2 Byte</li><li>s:char[], 代表字串，使用時前面要加上數字</li><li>i:long int, 4Byte</li><li>B:unsigned char, 1 Byte</li></ul><p>詳細的格式資訊請參考官網
<a href="http://docs.python.org/2/library/struct.html" target="_blank" rel="noopener noreferrer" title="Python struct">Python struct</a></p><p>這邊來個簡單範例
假設今天我們撰寫屬於自己的網路遊戲
然後我們玩家每次上線時，SERVER都會傳送一份玩家的資料給Client</p><p>這份資料包含了</p><ul><li>遊戲版本</li><li>玩家ID</li><li>玩家的座標(XY)</li><li>玩家當前的財產</li><li>玩家的職業</li><li>玩家的等級</li><li>玩家的經驗值</li></ul><p>每個資料所需要的型態跟大小如下敘述</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Myheader(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  uint8:version</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  uint8:playerID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  uint16:x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  uint16:y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  uint32:momey</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  char10:profession</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  uint8:level</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  uint32:experience</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>所以傳送資料過來的時候，我們必須要謹慎的按照這個規格去放置我們的資料。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="example">Example<a href="#example" class="hash-link" aria-label="Direct link to Example" title="Direct link to Example">​</a></h3><p>假設</p><ul><li>version = 1</li><li>playerID = 56</li><li>x = 123</li><li>y = 2341</li><li>momey = 5566217</li><li>profession = "warrior"</li><li>level = 128</li><li>experience = 2147383611</li></ul><div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">data </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> pack</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">'2B2HI10sBI'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">version</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">playerID</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">x</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">y</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">momey</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">profession</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">experience</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">//</span><span class="token string" style="color:#e3116c">'\x018{\x00%\t\x00\x00\t\xefT\x00warrior\x00\x00\x00\x80\x00\xdb\xff\xff\x7f'</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unpack</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">'2B2HI10sBI'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">data</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">56</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">123</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">2341</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">5566217</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'warrior\x00\x00\x00'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">128</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">2147483611</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <category label="Python" term="Python"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[nmap]]></title>
        <id>https://hwchiu.com/2013/06/15/nmap</id>
        <link href="https://hwchiu.com/2013/06/15/nmap"/>
        <updated>2013-06-15T09:25:00.000Z</updated>
        <summary type="html"><![CDATA[nmap是一個linux下的工具]]></summary>
        <content type="html"><![CDATA[<p>nmap是一個linux下的工具</p><p>nmap - Network exploration tool and security / port scanner</p><p>這邊記錄一下nmap的用法</p><p>nmap -sP 140.113.214.79/27</p><p>-sP: Ping Scan - go no further than determining if host is online
用ping去掃目標內的所有IP，並顯示有回應的IP，所以若對方是windows7且沒有打開ping的回應，則也會被當作host down</p><p>nmap -sL 140.113.214.79/27</p><p>-sL: List Scan - simply list targets to scan
只是單純的列出對方的hostname以及IP，不送出任何封包去檢測</p><p>nmap -O 140.113.214.94
nmap -A 140.113.214.94</p><p>-O: Enable OS detection
-A: Enables OS detection and Version detection, Script scanning and Traceroute</p><p>掃描對方主機的OS系統</p><p>nmap -PS/PA/PU/PY<!-- -->[portlist]<!-- --> 140.113.214.94</p><p>-PS/PA/PU/PY<!-- -->[portlist]<!-- -->: TCP SYN/ACK, UDP or SCTP discovery to given ports</p><p>用不同的方式去掃描特定的PORT。</p><ul><li>PS 用TCP 搭配 SYN FLAG去偵測。</li><li>PA 用TCP 搭配 ACK FLAG去偵測。</li><li>PU 用UDP去偵測。</li><li>PY 用SCTP去偵測。</li></ul><p>nmap -sS/sT/sU 140.113.214.94</p><p>採用不同的方式去掃描所有port。</p><ul><li>sS (TCP SYN scan) .</li><li>sT (TCP connect scan)</li><li>sU (UDP)</li></ul><p>nmap -v 140.113.214.94
顯示出詳細一點的資訊</p>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="System" term="System"/>
        <category label="Tool" term="Tool"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python-translate]]></title>
        <id>https://hwchiu.com/2013/06/13/python-translate</id>
        <link href="https://hwchiu.com/2013/06/13/python-translate"/>
        <updated>2013-06-13T21:30:00.000Z</updated>
        <summary type="html"><![CDATA[Python中有個很強大的字串轉換工具 maketrans 跟 translate]]></summary>
        <content type="html"><![CDATA[<p>Python中有個很強大的字串轉換工具 maketrans 跟 translate</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">str.translate(table[, deletechars]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Parameters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">table -- You can use the maketrans() helper function in the string module to create a translation table.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">deletechars -- The list of characters to be removed from the source string.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>字串中只要有符合deletechars中的字元都會被刪除，然後剩下的字元就會依照table裡面的mapping來做轉換。</p><p>這個mapping的就要利用string.maketrans()來幫忙產生囉,</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">str.maketrans(intab, outtab]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Parameters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">intab -- This is the string having actual characters.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">outtab -- This is the string having corresponding mapping character.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>intab跟outtab兩者的長度必須要一樣，會把intab中每一個字元與outtab中相同位置的字元做mapping。</p><p>舉例來說</p><div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    intab </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"aeiou"</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    outtab </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"12345"</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trantab </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> maketrans</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">intab</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> outtab</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>就會產生一個mapping,把aeiou分別轉換成12345。</p><div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token builtin">input</span><span class="token operator" style="color:#393A34">=</span><span class="token string" style="color:#e3116c">"abcdefgh"</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token builtin">input</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token builtin">input</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">translate</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">trantab</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>input就會變成 "1bcd2fgh"</p><p>那如果改成</p><div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token builtin">input</span><span class="token operator" style="color:#393A34">=</span><span class="token string" style="color:#e3116c">"abcdefgh"</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token builtin">input</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token builtin">input</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">translate</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">trantab</span><span class="token punctuation" style="color:#393A34">,</span><span class="token string" style="color:#e3116c">"fgh"</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>input就會變成 "1bcd2"</p><p>再來個簡單範例，希望能夠把所有的小寫轉成大寫，並把非英文字母外的所有字元都給刪除掉。</p><div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">import</span><span class="token plain"> string</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>#取得所有英文大小寫的集合</p><div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    lower </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">''</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">join</span><span class="token punctuation" style="color:#393A34">(</span><span class="token builtin">map</span><span class="token punctuation" style="color:#393A34">(</span><span class="token builtin">chr</span><span class="token punctuation" style="color:#393A34">,</span><span class="token builtin">range</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">97</span><span class="token punctuation" style="color:#393A34">,</span><span class="token number" style="color:#36acaa">123</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    upper </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> lower</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">upper</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>#創立一個對照表，可以把所有小寫轉成大寫</p><div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    ltu </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> string</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">maketrans</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">lower</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">upper</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>#接下來要利用捕集的方式取得非英文字母以外的所有字元，因此就用所有字元-英文字母
#創立一個代表所有字元的字元表</p><div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    allchars </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> string</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">maketrans</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">''</span><span class="token punctuation" style="color:#393A34">,</span><span class="token string" style="color:#e3116c">''</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>#利用translate的方式，取得所有非英文字母的集合</p><div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    delete </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> allchars</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">translate</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">allchars</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">lower</span><span class="token operator" style="color:#393A34">+</span><span class="token plain">upper</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>#定義一個對應的function,傳入的字串利用ltu跟delete，就能夠把所有非英文字母都刪除，並且小寫轉大寫了。</p><div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">def</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">makefilter</span><span class="token punctuation" style="color:#393A34">(</span><span class="token builtin">input</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">print</span><span class="token plain"> </span><span class="token builtin">input</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">translate</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">ltu</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">delete</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="Python" term="Python"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[MSN LOG解析以C#]]></title>
        <id>https://hwchiu.com/2013/04/21/msnlogparse</id>
        <link href="https://hwchiu.com/2013/04/21/msnlogparse"/>
        <updated>2013-04-21T20:11:00.000Z</updated>
        <summary type="html"><![CDATA[Msn的log採用的格式是XML，隨便打開一個LOG後仔細檢視，可以發現msn log的訊息格式大概是採這樣]]></summary>
        <content type="html"><![CDATA[<p>Msn的log採用的格式是XML，隨便打開一個LOG後仔細檢視，可以發現msn log的訊息格式大概是採這樣</p><div class="language-XML codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-XML codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;Message Date="2012/3/23" Time="下午 11:33:12" DateTime="2012-03-23T15:33:12.790Z" SessionID="1"&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;From&gt;&lt;User FriendlyName="邱 渣"/&gt;&lt;/From&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;To&gt;&lt;User FriendlyName="XXX"/&gt;&lt;/To&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;Text&gt;明天會到否&lt;/Text&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;/Message&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>每一則訊息，本身的屬性會包含該訊息的發送時間 ，有兩種格式，後面的790Z就不清楚是什麼意思了，SessionID這個屬性</p><p>也不是很清楚，但是這些都不重要</p><p>利用Date跟Time就可以取得基本時間了。</p><p>接者可以看到底下有三個屬性，代表訊息發送者，訊息接收者，以及發送的訊息為何</p><p>如果有啟動顏色跟字型的話，TEXT欄位就會變成下列樣子，會有屬性標示其顏色與字型</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;Text Style="font-family:Microsoft JhengHei; color:#000000; "&gt; test &lt;/Text&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在C#中，我這次使用XmlElement來做為解析XML的工具，載入檔案後，因為我們只關心訊息的傳送，</p><p>所以先利用GetElementsByTagName("message")來取得所有Message有關的nodes</p><p>接者針對這個結點內的所有資料去進行資料抓取，我們的目標有 時間、發送者、傳送文字</p><p>先將XmlNode轉型為XmlElement的類型，這樣方便處理，然後利用GetAttribute來取得Message的屬性</p><p>我們就可以知道每個對話的Date跟Time。接者要存取其child(From,To,Text)這些的值</p><p>這邊比較要注意的是這兩種的差別</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;From&gt;"邱渣"&lt;/From&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;From&gt;&lt;User FriendlyName="邱渣"/&gt;&lt;/From&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>以Type1來說，邱渣是From這個結點的值，可以利用childList<!-- -->[0]<!-- -->.value 取得發送者的名稱</p><p>但是對Type2來說，邱渣是From這個結點底下的一個結點中的屬性，所以就要利用childList<!-- -->[0]<!-- -->.FirstChild</p><p>的方式來取得<code>&lt;User&gt;</code>這個結點，再搭配Attributes<!-- -->[0]<!-- -->.Value來取得第一個屬性的值，如此才可以取得"邱渣"的值</p><p>所以利用childList<!-- -->[2]<!-- -->.FirstChild.Attributeds<!-- -->[0]<!-- -->.Value就可以取得文字訊息了!</p><p>另外，如果要取得文字的顏色跟字型的話，利用</p><p>childList<!-- -->[2]<!-- -->.GetAttribute("Style")</p><p>接者在去自己處理字串來取得字型跟顏色。</p><p>範例code如下</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    xml = new XmlDocument();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    xml.Load(filename);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    XmlNodeList nodeList = xml.GetElementsByTagName("Message");</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    foreach (XmlNode parentNode in nodeList)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        XmlElement element = (XmlElement)parentNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        string Date = element.GetAttribute("Date");</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        string Time = element.GetAttribute("Time");</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        XmlNodeList childList = element.ChildNodes;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        data += childList[0].FirstChild.Attributes[0].Value + " 說 (" + Time + ")\r\n";</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <category label="C#" term="C#"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux下 pipe介紹]]></title>
        <id>https://hwchiu.com/2013/03/29/c-pipe</id>
        <link href="https://hwchiu.com/2013/03/29/c-pipe"/>
        <updated>2013-03-29T15:05:00.000Z</updated>
        <summary type="html"><![CDATA[不論是bash,tcsh,又或者是windows的cmd，都有一種叫做PIPE的功能]]></summary>
        <content type="html"><![CDATA[<p>#<!-- -->[User]</p><p>不論是bash,tcsh,又或者是windows的cmd，都有一種叫做PIPE的功能</p><p>能夠將兩個獨立的程式給串接起來，把前面程式的輸出當作下一個程式的輸入</p><p>擁有這個指令，就能將本來當一功能的程式給組合起來變成複雜的工具了</p><p>舉例來說，我想要知道我當前目錄下有多少個檔案</p><p>就可以使用ls跟wc兩個指令合作完成，</p><p>使用 ls | wc  就會將ls的結果(檔案列表)當作輸入傳給wc這隻程式，然後就可以輕鬆地算出當前目錄的檔案數量</p><p>或者是有時候想要搜尋某些特定的字串，都會使用grep這個指令，譬如想要搜尋某個特定使用者正在執行的所有程序</p><p>ps auxww | grep username</p><p>所以pipe對於系統管理來說，是個非常重要的概念，能夠將每個獨立細小的程式給串接起來完成複雜的工作。</p><p>#<!-- -->[程式設計]</p><p>在FreeBSD(linux)上，shell能夠辦得到這樣的功能，實際上是利用了kernel中pipe的功能，這邊就已linux kernel 3.5.4為架構。</p><p>在程式中，pipe的概念就是一個水管，這個水管有兩個端口，一端負責寫資料到pipe，一端負責將資料從pipe中讀出來，所以我們可以做個簡單的測試。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int rand1,rand2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int fd[2];// declare a two-d array, store file_descriptor of the pipe (two side)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              // fd[0] mease read side, fd[1] means write side</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pid_t pid;//child process的pid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pipe(fd); //call system call (pipe) to create a pipe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //use fork to create a child process</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //child process will wrtie data to pipe, and parent will read data from pipe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //child process</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if((pid=fork())==0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        srand(getpid());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        close(fd[READ_END]);//child won't use read size, so close it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rand1=rand()%RANGE; //create random number</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        write(fd[WRITE_END],&amp;rand1,sizeof(rand1)); //write to pipe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        close(fd[WRITE_END]);//close write side when write over</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf("%d has been created In Child Process \n",rand1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        exit(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if(pid&gt;0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        srand(getpid());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        close(fd[WRITE_END]);//parent won't use write size, so close it。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rand2=rand()%RANGE;//create random number</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        read(fd[READ_END],&amp;rand1,sizeof(rand1));//read the data from pipe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf("%d has been created In Parent Process \n",rand2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wait();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf("Parent Process calulate sum is :%d \n",rand1+rand2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        close(fd[READ_END]);//close read side</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        exit(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>執行結果:
8 has been created In Child Process</p></blockquote><blockquote><p>5 has been created In Parent Process</p></blockquote><blockquote><p>Parent Process calulate sum is :13</p></blockquote><blockquote><hr></blockquote><blockquote><p>3 has been created In Child Process</p></blockquote><blockquote><p>3 has been created In Parent Process</p></blockquote><blockquote><p>Parent Process calulate sum is :6</p></blockquote><p>實際上，如果想要對同個端口去進行寫跟讀的動作，是行不通的，乍看之下會覺得PIPE只是一個</p><p>buffer，放置資料而已，實際上在kernel中，pipe被視為是一個file，當我們呼叫pipe時，真正最後會</p><p>呼叫到do_pipe這個function，在這個function中，會針對pipe的兩個端口分別去設定</p><p>O_RDONLY;O_WRONLY的標籤，這樣的設定使得pipe的端口就真的一邊只能讀，一邊只能寫。</p><p>有空在來講述一下file_descriptor file file_operation三者的關係，以及到底 file,socket,pipe...等這些device到底在kernel中如何運作。</p>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="C" term="C"/>
        <category label="System" term="System"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matlab 簡單練習]]></title>
        <id>https://hwchiu.com/2013/03/29/matlab-1</id>
        <link href="https://hwchiu.com/2013/03/29/matlab-1"/>
        <updated>2013-03-29T15:04:00.000Z</updated>
        <summary type="html"><![CDATA[應朋友的要求，用matlab幫忙寫了一個簡單的腳本]]></summary>
        <content type="html"><![CDATA[<p>應朋友的要求，用matlab幫忙寫了一個簡單的腳本</p><p>需要能夠ˋ彈出對話框選擇一個資料夾，讀取資料夾底下的影像檔，然後與某個特定的影像檔做相減，並命名輸出</p><p>這部分用到了一些指令，在這邊紀錄下來</p><div class="language-matlab codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-matlab codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">%choose directory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">target_path = uigetdir();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">file_path = [target_path '/C00*.tif'];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">background = [target_path '/REF.tif'];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">file_struct = dir(file_path);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">back_struct = dir(background);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">%load background image</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">back = imread([target_path '/' back_struct.name]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i=1:length(file_struct)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">temp_image = imread([target_path '/' file_struct(i).name]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">result_image = imsubtract(temp_image,back);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">imwrite(result_image,[target_path '/new' file_struct(i).name]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>====END=======</p><p>首先使用到了uigetdir,與其類似的還有uigetfile</p><p>呼叫此函數後，會彈出directoryOpenDialog的介面，選擇完畢後，會把選擇的路徑回傳</p><p>接下來我想要移動到該路徑，於是希望透過 cd 這個指令，無奈 cd這個指令沒有辦法吃參數，只能吃完整路徑，所以就必須要改換成其他的方法</p><p>由於我已經知道圖檔的命名規則，於是先用 [] 的方式，把字串給連接起來，這邊使用regular的方式，之後再搜尋檔案的時候會更方便</p><p>接者使用dir這個指令，就可以得到我想要的所有檔案，dir回傳的是一個struct，內容包含了檔案的</p><blockquote><p>name    -- 檔案名稱
date    -- 修改日期
bytes   -- 檔案大小
isdir   -- 是否為資料夾
datenum -- Matlab特定的修改日期</p></blockquote><p>這邊我只需要它的名稱，於是透過一個迴圈，把所有的路徑檔案都以圖片的方式(imread)給讀取近來
在與事先讀取好的背景圖片(back)使用imsubtract做相減，得到新的圖片，再透過imwrite給寫出檔案</p>]]></content>
        <category label="Matlab" term="Matlab"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows VPN]]></title>
        <id>https://hwchiu.com/2013/03/29/windows-vpn</id>
        <link href="https://hwchiu.com/2013/03/29/windows-vpn"/>
        <updated>2013-03-29T15:02:00.000Z</updated>
        <summary type="html"><![CDATA[最近因為某個教授的要求，希望windows開機就可以自動vpn連線，所以這部份花了一些時間去研究，雖然我認為每次開機自己動手點兩下好像也沒有多困難阿~冏]]></summary>
        <content type="html"><![CDATA[<p>最近因為某個教授的要求，希望windows開機就可以自動vpn連線，所以這部份花了一些時間去研究，雖然我認為每次開機自己動手點兩下好像也沒有多困難阿~冏</p><p>這個概念其實不難，寫一個可以連線的batch file,每次開機的時候，自動去執行該batch file，就可以達到連線的功能了。</p><ol><li><p>在網際網路那邊手動增加一個VPN連線，假設該VPN連線名稱為 vpn_connection。</p></li><li><p>寫一個batch file,內容增加一行</p></li></ol><blockquote><p>rasdial "my_vpn_connection" "myname"  "mypasswd"</p></blockquote><p>這時候可以手動執行看看，看會不會連線成功，如果連線不會成功，就根據錯誤代碼去解決。</p><ol start="3"><li>執行taskschd.msc 這個排班程式，把該batch file加入至開機執行，並且在網路連線成功後才執行。</li></ol><p>重開機測試!</p>]]></content>
        <author>
            <name>hwchiu</name>
        </author>
        <category label="System" term="System"/>
        <category label="Windows" term="Windows"/>
        <category label="Network" term="Network"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++ explicit修飾]]></title>
        <id>https://hwchiu.com/2013/03/29/cpp</id>
        <link href="https://hwchiu.com/2013/03/29/cpp"/>
        <updated>2013-03-29T14:12:00.000Z</updated>
        <summary type="html"><![CDATA[C++中，有所謂的顯性轉換跟隱性轉換]]></summary>
        <content type="html"><![CDATA[<p>C++中，有所謂的顯性轉換跟隱性轉換</p><p>在宣告時，加入explicit 這個關鍵字，可以禁止使用顯性轉換，以下為例</p><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    using namespace std;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class Stack {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         Stack(int a){};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Test(Stack b){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     Stack s1 = 1;  //ok</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     Stack s2 = Stack(12); //ok</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     Stack s3(s1); //ok</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     Test(123); //ok</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    using namespace std;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class Stack {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       explicit   Stack(int){};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Test(Stack b){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     Stack s1 = 123;  //error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     Stack s2 = Stack(123); //ok</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     Stack s3(s1); //ok</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     Test(123); // error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <category label="C" term="C"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[檢查port使用情況]]></title>
        <id>https://hwchiu.com/2013/03/29/port-check</id>
        <link href="https://hwchiu.com/2013/03/29/port-check"/>
        <updated>2013-03-29T12:33:00.000Z</updated>
        <summary type="html"><![CDATA[有時候根據應用需求，會需要針對去檢查目前系統上有哪些port正在被使用]]></summary>
        <content type="html"><![CDATA[<p>有時候根據應用需求，會需要針對去檢查目前系統上有哪些port正在被使用</p><p>#<strong>[FreeBSD]</strong></p><p>可以使用 sockstat 這個command 來檢查系統上port的使用。</p><blockquote><p>USER COMMAND PID   FD PROTO LOCAL ADDRESS FOREIGN ADDRESS</p></blockquote><blockquote><p>root     cron 93468     4   udp4           <em>:638                          </em>:*</p></blockquote><p>在預設的情況下，會輸出</p><p>使用者名稱，執行的程序，該程序的pid，在該程序中使用該port的file descriptor是多少 使用何種協定，以及address</p><p>如果使用 sockstat -4lP tcp 就可以找出 使用tcp &amp; ipv4 ，並且正在listen的port</p><p>這對於要尋找是否有人在寫<strong>Socket programming</strong>來說是很方便的。</p><p>詳細的可以man sockstat</p><hr><p>#<strong>[Linux]</strong>
可以使用 netstat 這個工具來檢視，搭配一些參數還可以看到該 port 被那些 process 使用</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">netstat -anptn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tcp        1      0 127.0.0.1:40147         127.0.0.1:36524         CLOSE_WAIT  7147/vim</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tcp        1      0 127.0.0.1:58289         127.0.0.1:52849         CLOSE_WAIT  19421/vi</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>#<strong>[Windows]</strong></p><p>可以使用netstat來檢視，netstat能夠顯示的資訊非常的多，為了精簡我們的需求，必須去過濾這些資訊</p><p>在windows上使用find這個指令，類似於UNIX中grep的功能</p><p>舉例來說，netstat -an |find /i “listening" 這個指令</p><p>netstat  -an 會顯示所有連線以及正在監聽的port，並且以數字的形式來顯示IP以及PORT</p><p>find /i “listening" 則會以不區分的方式去搜尋每一行，若包含listening則將該行印出</p><p>EX:</p><blockquote><p>TCP 192.168.1.116:139 0.0.0.0:0 LISTENING</p></blockquote><blockquote><p>TCP 192.168.1.116:49156 216.52.233.65:12975 ESTABLISHED</p></blockquote><p>ref:
<a href="http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/find.mspx?mfr=true" target="_blank" rel="noopener noreferrer">www.microsoft.com/resources/</a></p>]]></content>
        <category label="System" term="System"/>
        <category label="Network" term="Network"/>
        <category label="FreeBSD" term="FreeBSD"/>
        <category label="Windows" term="Windows"/>
        <category label="Linux" term="Linux"/>
    </entry>
</feed>