"use strict";(self.webpackChunkhwchiu=self.webpackChunkhwchiu||[]).push([[63919],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),_=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=_(e.components);return a.createElement(p.Provider,{value:t},e.children)},k="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},i=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,p=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),k=_(n),i=r,d=k["".concat(p,".").concat(i)]||k[i]||c[i]||s;return n?a.createElement(d,l(l({ref:t},u),{},{components:n})):a.createElement(d,l({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,l=new Array(s);l[0]=i;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[k]="string"==typeof e?e:r,l[1]=o;for(var _=2;_<s;_++)l[_]=n[_];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}i.displayName="MDXCreateElement"},44998:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>_});var a=n(87462),r=(n(67294),n(3905));const s={title:"OpenvSwitch source code(3)",date:"2013-12-22 14:20",comments:!0,tags:["SDN","Network","OpenvSwitch","SourceCode"],description:"\u9019\u7bc7\u6587\u7ae0\u5e36\u9818\u5927\u5bb6\u900f\u904e\u95b1\u8b80\u539f\u59cb\u78bc\u7684\u65b9\u4f86\u5b78\u7fd2\u5982\u4f55 OpenvSwitch \u662f\u5982\u4f55\u8655\u7406\u5c01\u5305\u7684\uff0c\u7576\u5e95\u5c64\u7684 Kernel Switch(datapath) \u6c92\u6709\u8fa6\u6cd5\u8f49\u767c\u5c01\u5305\u6642\uff0c\u8981\u5982\u4f55\u5c07\u8a72\u5c01\u5305\u9001\u5230\u4e0a\u5c64\u7684 User Space Table \u9032\u884c Openflow \u898f\u5247\u7684\u67e5\u8a62\u3002\u9019\u90e8\u4efd\u727d\u626f\u5230\u8cc7\u6599\u5982\u4f55\u6a6b\u8de8\u65bc User-Space \u4ee5\u53ca Kernel-Space."},l="Preface",o={unversionedId:"2013/openvswitch-source-code3",id:"2013/openvswitch-source-code3",title:"OpenvSwitch source code(3)",description:"\u9019\u7bc7\u6587\u7ae0\u5e36\u9818\u5927\u5bb6\u900f\u904e\u95b1\u8b80\u539f\u59cb\u78bc\u7684\u65b9\u4f86\u5b78\u7fd2\u5982\u4f55 OpenvSwitch \u662f\u5982\u4f55\u8655\u7406\u5c01\u5305\u7684\uff0c\u7576\u5e95\u5c64\u7684 Kernel Switch(datapath) \u6c92\u6709\u8fa6\u6cd5\u8f49\u767c\u5c01\u5305\u6642\uff0c\u8981\u5982\u4f55\u5c07\u8a72\u5c01\u5305\u9001\u5230\u4e0a\u5c64\u7684 User Space Table \u9032\u884c Openflow \u898f\u5247\u7684\u67e5\u8a62\u3002\u9019\u90e8\u4efd\u727d\u626f\u5230\u8cc7\u6599\u5982\u4f55\u6a6b\u8de8\u65bc User-Space \u4ee5\u53ca Kernel-Space.",source:"@site/docs/2013/openvswitch-source-code3.md",sourceDirName:"2013",slug:"/2013/openvswitch-source-code3",permalink:"/docs/2013/openvswitch-source-code3",draft:!1,tags:[{label:"SDN",permalink:"/docs/tags/sdn"},{label:"Network",permalink:"/docs/tags/network"},{label:"OpenvSwitch",permalink:"/docs/tags/openv-switch"},{label:"SourceCode",permalink:"/docs/tags/source-code"}],version:"current",lastUpdatedBy:"HWC",frontMatter:{title:"OpenvSwitch source code(3)",date:"2013-12-22 14:20",comments:!0,tags:["SDN","Network","OpenvSwitch","SourceCode"],description:"\u9019\u7bc7\u6587\u7ae0\u5e36\u9818\u5927\u5bb6\u900f\u904e\u95b1\u8b80\u539f\u59cb\u78bc\u7684\u65b9\u4f86\u5b78\u7fd2\u5982\u4f55 OpenvSwitch \u662f\u5982\u4f55\u8655\u7406\u5c01\u5305\u7684\uff0c\u7576\u5e95\u5c64\u7684 Kernel Switch(datapath) \u6c92\u6709\u8fa6\u6cd5\u8f49\u767c\u5c01\u5305\u6642\uff0c\u8981\u5982\u4f55\u5c07\u8a72\u5c01\u5305\u9001\u5230\u4e0a\u5c64\u7684 User Space Table \u9032\u884c Openflow \u898f\u5247\u7684\u67e5\u8a62\u3002\u9019\u90e8\u4efd\u727d\u626f\u5230\u8cc7\u6599\u5982\u4f55\u6a6b\u8de8\u65bc User-Space \u4ee5\u53ca Kernel-Space."},sidebar:"techPost",previous:{title:"OpenvSwitch - 2",permalink:"/docs/2013/openvswitch-source-2"},next:{title:"Install the FTP server on FreeBSD",permalink:"/docs/2013/pure-ftpd"}},p={},_=[{value:"netdev_frame_hook",id:"netdev_frame_hook",level:2},{value:"netdev_port_receive",id:"netdev_port_receive",level:2},{value:"ovs_vport_receive",id:"ovs_vport_receive",level:2},{value:"ovs_dp_process_received_packet",id:"ovs_dp_process_received_packet",level:2},{value:"ovs_flow_extract",id:"ovs_flow_extract",level:2},{value:"Found",id:"found",level:2},{value:"ovs_flow_used",id:"ovs_flow_used",level:3},{value:"ovs_execute_actions",id:"ovs_execute_actions",level:3},{value:"do_execute_actions",id:"do_execute_actions",level:3},{value:"Not found",id:"not-found",level:2},{value:"queue_userspace_packet",id:"queue_userspace_packet",level:3}],u={toc:_},k="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(k,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"preface"},"Preface"),(0,r.kt)("p",null,"\u9019\u908a\u8981\u63a2\u8a0e\u7684\u662f\u7576\u7db2\u5361\u6536\u5230\u5c01\u5305\u5f8c\uff0c\u5728 ",(0,r.kt)("strong",{parentName:"p"},"KERNEL")," \u4e2d\u7531\u4e0b\u5f80\u4e0a\u7684\u6d41\u7a0b"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"http://user-image.logdown.io/user/415/blog/415/post/168532/USgXG7XQxy3ZF5Qh1RY7_test.png",alt:"test.png"})),(0,r.kt)("h2",{id:"netdev_frame_hook"},"netdev_frame_hook"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"static rx_handler_result_t netdev_frame_hook(struct sk_buff **pskb)\n{\n        struct sk_buff *skb = *pskb;\n        struct vport *vport;\n\n        if (unlikely(skb->pkt_type == PACKET_LOOPBACK))\n                return RX_HANDLER_PASS;\n\n        vport = ovs_netdev_get_vport(skb->dev);\n\n        netdev_port_receive(vport, skb);\n\n        return RX_HANDLER_CONSUMED;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"net_device"),"\u6536\u5230\u5c01\u5305\u5f8c\uff0c\u8b8a\u8b8a\u547c\u53eb\u9019\u500bfucntion call\u4f86\u8655\u7406\u3002"),(0,r.kt)("li",{parentName:"ul"},"\u5148\u5224\u65b7\u662f\u4e0d\u662fLOOPBACK\u7684\uff0c\u662f\u7684\u8a71\u5c31\u4e0d\u9700\u8981\u8655\u7406\u4e86\u3002"),(0,r.kt)("li",{parentName:"ul"},"\u900f\u904e ",(0,r.kt)("strong",{parentName:"li"},"ovs_netdev_get_vport"),"\u53d6\u5f97\u8a72dev\u5c0d\u61c9\u7684vport"),(0,r.kt)("li",{parentName:"ul"},"\u547c\u53eb ",(0,r.kt)("strong",{parentName:"li"},"netdev_port_receive"),"\u4f86\u8655\u7406\u9019\u500b\u5c01\u5305")),(0,r.kt)("h2",{id:"netdev_port_receive"},"netdev_port_receive"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"static void netdev_port_receive(struct vport *vport, struct sk_buff *skb)\n{\n        if (unlikely(!vport))\n                goto error;\n        if (unlikely(skb_warn_if_lro(skb)))\n                goto error;\n        /* Make our own copy of the packet.  Otherwise we will mangle the\n         * packet for anyone who came before us (e.g. tcpdump via AF_PACKET).\n         * (No one comes after us, since we tell handle_bridge() that we took\n         * the packet.) */\n        skb = skb_share_check(skb, GFP_ATOMIC);\n        if (unlikely(!skb))\n                return;\n\n        skb_push(skb, ETH_HLEN);\n        ovs_skb_postpush_rcsum(skb, skb->data, ETH_HLEN);\n\n        ovs_vport_receive(vport, skb, NULL);\n        return;\n\nerror:\n        kfree_skb(skb);\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"skb_warn_if_lro"),"\u5224\u65b7\u5176LRO\u7684\u8a2d\u5b9a\u6709\u6c92\u6709\u554f\u984c"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"skb_push"),"\u8abf\u6574skb\u4e2d\u7684data\u6307\u6a19"),(0,r.kt)("li",{parentName:"ul"},"ovs_skb_postpush_rcsum \u8655\u7406ip checksum\u3002"),(0,r.kt)("li",{parentName:"ul"},"\u547c\u53eb ",(0,r.kt)("strong",{parentName:"li"},"ovs_vport_receive"),"\u7e7c\u7e8c\u8655\u7406")),(0,r.kt)("h2",{id:"ovs_vport_receive"},"ovs_vport_receive"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"void ovs_vport_receive(struct vport *vport, struct sk_buff *skb,\n                       struct ovs_key_ipv4_tunnel *tun_key)\n{\n        struct pcpu_tstats *stats;\n\n        stats = this_cpu_ptr(vport->percpu_stats);\n        u64_stats_update_begin(&stats->syncp);\n        stats->rx_packets++;\n        stats->rx_bytes += skb->len;\n        u64_stats_update_end(&stats->syncp);\n\n        OVS_CB(skb)->tun_key = tun_key;\n        ovs_dp_process_received_packet(vport, skb);\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"struct pcpu_tstats")," \u7d00\u9304\u7576\u524dcpu\u5c0d\u65bc\u5c01\u5305\u7684\u4e00\u4e9b\u8a08\u6578 (rx,tx)"),(0,r.kt)("li",{parentName:"ul"},"\u7531 ",(0,r.kt)("strong",{parentName:"li"},"this_cpu_ptr"),"\u53d6\u5f97\u9019\u500bvport\u7684(tx,rx) counter."),(0,r.kt)("li",{parentName:"ul"},"Update counters (packets,bytes)"),(0,r.kt)("li",{parentName:"ul"},"\u900f\u904e ",(0,r.kt)("strong",{parentName:"li"},"ovs_dp_process_received_packet"),"\u7e7c\u7e8c\u8655\u7406")),(0,r.kt)("h2",{id:"ovs_dp_process_received_packet"},"ovs_dp_process_received_packet"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u9019\u500bfunction\u7684\u76ee\u7684\u5c31\u662f",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"\u7531skb\u5167\u53d6\u51fa\u5c01\u5305\u5404\u6b04\u4f4d\u7684\u8cc7\u8a0a(L2,L3,L4)"),(0,r.kt)("li",{parentName:"ol"},"\u53bb\u67e5\u8a62\u8a72 ",(0,r.kt)("strong",{parentName:"li"},"datapath"),"\u7684flow table\u4e2d\u5426\u6709\u7b26\u5408\u7684flow entry"),(0,r.kt)("li",{parentName:"ol"},"\u6709\u627e\u5230\uff0c\u5c31\u57f7\u884c\u5c0d\u61c9\u7684action."),(0,r.kt)("li",{parentName:"ol"},"\u6c92\u6709\u627e\u5230\uff0c\u5c31\u57f7\u884c ",(0,r.kt)("strong",{parentName:"li"},"ovs_dp_upcall"),"\u9001\u5230 ",(0,r.kt)("strong",{parentName:"li"},"user space"))))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"void ovs_dp_process_received_packet(struct vport *p, struct sk_buff *skb)\n{\n        struct datapath *dp = p->dp;\n        struct sw_flow *flow;\n        struct dp_stats_percpu *stats;\n        struct sw_flow_key key;\n        u64 *stats_counter;\n        int error;\n\n        stats = this_cpu_ptr(dp->stats_percpu);\n\n        /* Extract flow from 'skb' into 'key'. */\n        error = ovs_flow_extract(skb, p->port_no, &key);\n        if (unlikely(error)) {\n                kfree_skb(skb);\n                return;\n        }\n\n        /* Look up flow. */\n        flow = ovs_flow_lookup(rcu_dereference(dp->table), &key);\n        if (unlikely(!flow)) {\n                struct dp_upcall_info upcall;\n\n                upcall.cmd = OVS_PACKET_CMD_MISS;\n                upcall.key = &key;\n                upcall.userdata = NULL;\n                upcall.portid = p->upcall_portid;\n                ovs_dp_upcall(dp, skb, &upcall);\n                consume_skb(skb);\n                stats_counter = &stats->n_missed;\n                goto out;\n        }\n\n        OVS_CB(skb)->flow = flow;\n        OVS_CB(skb)->pkt_key = &key;\n\n        stats_counter = &stats->n_hit;\n        ovs_flow_used(OVS_CB(skb)->flow, skb);\n        ovs_execute_actions(dp, skb);\n\nout:\n        /* Update datapath statistics. */\n        u64_stats_update_begin(&stats->sync);\n        (*stats_counter)++;\n        u64_stats_update_end(&stats->sync);\n}\n\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5148\u7531 ",(0,r.kt)("strong",{parentName:"li"},"vport")," \u53d6\u5f97 \u5c0d\u61c9\u7684 ",(0,r.kt)("strong",{parentName:"li"},"datapath")),(0,r.kt)("li",{parentName:"ul"},"\u7531 ",(0,r.kt)("strong",{parentName:"li"},"this_cpu_ptr"),"\u53d6\u5f97\u9019\u500bdatapath\u7684(tx,rx) counter."),(0,r.kt)("li",{parentName:"ul"},"\u900f\u904e ",(0,r.kt)("strong",{parentName:"li"},"ovs_flow_extract")," \u628a ",(0,r.kt)("strong",{parentName:"li"},"skb"),", ",(0,r.kt)("strong",{parentName:"li"},"vport")," \u7684\u8cc7\u8a0a\u90fd\u5beb\u5165 ",(0,r.kt)("strong",{parentName:"li"},"sw_flow_key key"),"\u4e4b\u4e2d"),(0,r.kt)("li",{parentName:"ul"},"\u547c\u53eb ",(0,r.kt)("strong",{parentName:"li"},"ovs_flow_lookup")," \u53bb\u67e5\u8a62\u9019\u500bpacket\u5728table\u4e4b\u4e2d\u6709\u6c92\u6709match\u7684flow entry."),(0,r.kt)("li",{parentName:"ul"},"\u5982\u679c\u6c92\u6709\u627e\u5230\uff0c\u90a3\u5c31\u900f\u904e ",(0,r.kt)("strong",{parentName:"li"},"upcall"),"\u7684\u65b9\u5f0f\uff0c\u628a\u9019\u500bflow_miss\u544a\u8a34 ",(0,r.kt)("strong",{parentName:"li"},"ovs-vswitchd"),"\u53bb\u8655\u7406"),(0,r.kt)("li",{parentName:"ul"},"\u5982\u679c\u6709\u627e\u5230\uff0c\u5148\u900f\u904e ",(0,r.kt)("strong",{parentName:"li"},"ovs_flow_used"),"\u66f4\u65b0\u8a72flow\u7684\u4e00\u4e9b\u8cc7\u8a0a(usedtime,packet,byte,tcp_flag),\u63a5\u8005\u5728\u547c\u53eb ",(0,r.kt)("strong",{parentName:"li"},"ovs_execute_actions")," \u57f7\u884c\u9019\u500bflow \u5c0d\u61c9\u7684actions")),(0,r.kt)("h2",{id:"ovs_flow_extract"},"ovs_flow_extract"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"int ovs_flow_extract(struct sk_buff *skb, u16 in_port, struct sw_flow_key *key)\n{\n        int error;\n        struct ethhdr *eth;\n\n        memset(key, 0, sizeof(*key));\n\n        key->phy.priority = skb->priority;\n        if (OVS_CB(skb)->tun_key)\n                memcpy(&key->tun_key, OVS_CB(skb)->tun_key, sizeof(key->tun_key));\n        key->phy.in_port = in_port;\n        key->phy.skb_mark = skb->mark;\n\n        skb_reset_mac_header(skb);\n\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"OVS_CB\u662f\u4e00\u500bmarco,\u6703\u628askbuff\u4e2d\u7684cb\u5340\u57df\u62ff\u4f86\u4f7f\u7528\uff0c\u4e26\u4e14\u8f49\u578b\u6210 ovs_skb_cb\n",(0,r.kt)("strong",{parentName:"li"},"#define OVS_CB(skb) ((struct ovs_skb_cb *)(skb)->cb)")),(0,r.kt)("li",{parentName:"ul"},"\u5982\u679c\u8a72packet\u6709\u4f7f\u7528 ",(0,r.kt)("strong",{parentName:"li"},"tunnel_key"),"\u7684\u8a71\uff0c\u5c31\u628a\u8a72 ",(0,r.kt)("strong",{parentName:"li"},"tun_key"),"\u7d66\u8907\u88fd\u5230 ",(0,r.kt)("strong",{parentName:"li"},"key"),"\u3002"),(0,r.kt)("li",{parentName:"ul"},"\u628a\u6536\u5230\u5c01\u5305\u7684port number\u4e5f\u8a18\u9304\u5230key\u88e1\u9762( ingress port)"),(0,r.kt)("li",{parentName:"ul"},"\u4f7f\u7528 ",(0,r.kt)("strong",{parentName:"li"},"skb_reset_mac_header")," \u5f97\u5230 mac header (\u653e\u5728 skb->mac_header)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"        /* Link layer.  We are guaranteed to have at least the 14 byte Ethernet\n         * header in the linear data area.\n         */\n        eth = eth_hdr(skb);\n        memcpy(key->eth.src, eth->h_source, ETH_ALEN);\n        memcpy(key->eth.dst, eth->h_dest, ETH_ALEN);\n\n        __skb_pull(skb, 2 * ETH_ALEN);\n        /* We are going to push all headers that we pull, so no need to\n         * update skb->csum here. */\n\n        if (vlan_tx_tag_present(skb))\n                key->eth.tci = htons(vlan_get_tci(skb));\n        else if (eth->h_proto == htons(ETH_P_8021Q))\n                if (unlikely(parse_vlan(skb, key)))\n                        return -ENOMEM;\n\n        key->eth.type = parse_ethertype(skb);\n        if (unlikely(key->eth.type == htons(0)))\n                return -ENOMEM;\n\n        skb_reset_network_header(skb);\n        __skb_push(skb, skb->data - skb_mac_header(skb));\n\n        ....\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u53d6\u5f97 ethernet header,\u4e26\u4e14\u628a sourcee/destinaion mac address\u7d66\u8907\u88fd\u5230key\u3002"),(0,r.kt)("li",{parentName:"ul"},"\u900f\u904e ",(0,r.kt)("strong",{parentName:"li"},"__skb_pull"),",\u628a ",(0,r.kt)("strong",{parentName:"li"},"skb-data"),"\u7d66\u5f80\u4e0b\u6307 ",(0,r.kt)("strong",{parentName:"li"},"ETH_ALEN*2")),(0,r.kt)("li",{parentName:"ul"},"\u6aa2\u67e5\u6709\u6c92\u6709\u7528 ",(0,r.kt)("strong",{parentName:"li"},"vlan tag"),",\u6709\u7684\u8a71\u5c31\u628atci\u7d66\u6293\u8fd1\u4f86"),(0,r.kt)("li",{parentName:"ul"},"\u4f7f\u7528 ",(0,r.kt)("strong",{parentName:"li"},"parse_ethertype")," \u5f97\u5230\u8a72\u5c01\u5305\u7684 ethernet type"),(0,r.kt)("li",{parentName:"ul"},"\u4f7f\u7528 ",(0,r.kt)("strong",{parentName:"li"},"skb_reset_network_header")," \u5f97\u5230 network header (\u653e\u5728 skb->network_header)"),(0,r.kt)("li",{parentName:"ul"},"\u900f\u904e ",(0,r.kt)("strong",{parentName:"li"},"__skb_push")," \u628askb\u4e2d\u7684data\u6307\u6a19\u5f80\u4e0a\u79fb(\u9019\u6a23\u53ef\u4ee5\u53d6\u56demac header\u7684\u4e00\u4e9b\u8cc7\u8a0a)\uff0c\u4f9b\u672a\u4f86\u4f7f\u7528"),(0,r.kt)("li",{parentName:"ul"},"\u5f8c\u9762\u5c31\u662f\u91dd\u5c0d (IP,IPV6,ARP)\u7b49\u5728\u505a\u66f4\u7d30\u90e8\u7684\u8cc7\u6599\u53d6\u5f97")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"struct sw_flow *ovs_flow_lookup(struct flow_table *tbl,\n                                const struct sw_flow_key *key)\n{\n        struct sw_flow *flow = NULL;\n        struct sw_flow_mask *mask;\n\n        list_for_each_entry_rcu(mask, tbl->mask_list, list) {\n                flow = ovs_masked_flow_lookup(tbl, key, mask);\n                if (flow)  /* Found */\n                        break;\n        }\n\n        return flow;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5f9e ",(0,r.kt)("strong",{parentName:"li"},"datapath"),"\u7684",(0,r.kt)("strong",{parentName:"li"},"flow table"),"\u4e2d\u5148\u53d6\u5f97\u6240\u6709\u7684 ",(0,r.kt)("strong",{parentName:"li"},"mask_list")),(0,r.kt)("li",{parentName:"ul"},"\u4f7f\u7528 ",(0,r.kt)("strong",{parentName:"li"},"ovs_masked_flow_lookup"),"\u53bb\u641c\u5c0b\u9032\u4f86\u7684\u5c01\u5305\u662f\u5426\u6709match"),(0,r.kt)("li",{parentName:"ul"},"\u6700\u5f8c\u56de\u50b3 flow.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"static struct sw_flow *ovs_masked_flow_lookup(struct flow_table *table,\n                                    const struct sw_flow_key *unmasked,\n                                    struct sw_flow_mask *mask)\n{\n        struct sw_flow *flow;\n        struct hlist_head *head;\n        int key_start = mask->range.start;\n        int key_end = mask->range.end;\n        u32 hash;\n        struct sw_flow_key masked_key;\n\n        ovs_flow_key_mask(&masked_key, unmasked, mask);\n        hash = ovs_flow_hash(&masked_key, key_start, key_end);\n        head = find_bucket(table, hash);\n        hlist_for_each_entry_rcu(flow, head, hash_node[table->node_ver]) {\n                if (flow->mask == mask &&\n                    __flow_cmp_masked_key(flow, &masked_key,\n                                          key_start, key_end))\n                        return flow;\n        }\n        return NULL;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"OVS 2.0\u5f8c\u589e\u52a0\u5c0dmegaflow\u7684\u652f\u6301\uff0c\u6240\u4ee5\u5728kernel\u7aef\u4e5f\u53ef\u4ee5\u652f\u63f4wildcard\u7684flow matching."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"sw_flow_key"),"\u5be6\u969b\u4e0a\u5c31\u662f\u500bwildcard\uff0c\u6bcf\u500b\u9032\u4f86\u7684\u5c01\u5305\u90fd\u5148\u8ddfwildcard\u505a ",(0,r.kt)("strong",{parentName:"li"},"ovs_flow_key_mask"),",\u7136\u5f8c\u5728\u7528mask\u5f8c\u7684\u7d50\u679c\u53bbtable\u4e2d\u5c0b\u627e\u6709\u6c92\u6709\u53ef\u4ee5match\u7684"),(0,r.kt)("li",{parentName:"ul"},"\u4f7f\u7528mask\u904e\u5f8c\u7684\u7d50\u679c\u4f86\u505ahash,\u4e26\u4e14\u900f\u904e ",(0,r.kt)("strong",{parentName:"li"},"find_bucket"),"\u627e\u5230\u90a3\u500bhash\u503c\u6240\u5728\u7684bucket"),(0,r.kt)("li",{parentName:"ul"},"\u91dd\u5c0d\u90a3\u500bbucket\u4e2d\u6240\u6709\u7684flow\u53bb\u505a\u6bd4\u5c0d\uff0c\u5982\u679c mask\u76f8\u540c\u4e14 ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("strong",{parentName:"strong"},"flow_cmp"),"masked"),"\u7d50\u679c\u70ba\u771f\uff0c\u5c31\u4ee3\u8868match."),(0,r.kt)("li",{parentName:"ul"},"key\u7684start & end \u9084\u4e0d\u662f\u5f88\u660e\u77ad\u5176\u76ee\u7684\u4ee5\u53ca\u7528\u9014\uff0c\u5f85\u91d0\u6e05")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"void ovs_flow_key_mask(struct sw_flow_key *dst, const struct sw_flow_key *src,\n                       const struct sw_flow_mask *mask)\n{\n        const long *m = (long *)((u8 *)&mask->key + mask->range.start);\n        const long *s = (long *)((u8 *)src + mask->range.start);\n        long *d = (long *)((u8 *)dst + mask->range.start);\n        int i;\n\n        /* The memory outside of the 'mask->range' are not set since\n         * further operations on 'dst' only uses contents within\n         * 'mask->range'.\n         */\n        for (i = 0; i < range_n_bytes(&mask->range); i += sizeof(long))\n                *d++ = *s++ & *m++;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u628a ",(0,r.kt)("strong",{parentName:"li"},"src"),"\u7528 ",(0,r.kt)("strong",{parentName:"li"},"mask"),"\u53bb\u8655\u7406\uff0c\u7d50\u679c\u653e\u5230 ",(0,r.kt)("strong",{parentName:"li"},"dst"),"\u4e0a"),(0,r.kt)("li",{parentName:"ul"},"\u9019\u908a\u53ef\u4ee5\u770b\u5230\u505amask\u7684\u65b9\u6cd5\u5c31\u662f\u4e0d\u505c\u5730\u7528 &\u4f86\u53d6\u7d50\u679c\u800c\u5df2\u3002")),(0,r.kt)("h2",{id:"found"},"Found"),(0,r.kt)("p",null,"\u5c0b\u627e\u5230flow\u5f8c"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"\u66f4\u65b0\u8a72flow\u7684\u4e00\u4e9b\u7d71\u8a08\u8cc7\u8a0a ( ",(0,r.kt)("strong",{parentName:"li"},"ovs_flow_used"),")"),(0,r.kt)("li",{parentName:"ol"},"\u57f7\u884c\u8a72flow entry\u4e0a\u7684actions (",(0,r.kt)("strong",{parentName:"li"},"ovs_execute_actions"),")")),(0,r.kt)("h3",{id:"ovs_flow_used"},"ovs_flow_used"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"void ovs_flow_used(struct sw_flow *flow, struct sk_buff *skb)\n{\n        u8 tcp_flags = 0;\n\n        if ((flow->key.eth.type == htons(ETH_P_IP) ||\n             flow->key.eth.type == htons(ETH_P_IPV6)) &&\n            flow->key.ip.proto == IPPROTO_TCP &&\n            likely(skb->len >= skb_transport_offset(skb) + sizeof(struct tcphdr))) {\n                u8 *tcp = (u8 *)tcp_hdr(skb);\n                tcp_flags = *(tcp + TCP_FLAGS_OFFSET) & TCP_FLAG_MASK;\n        }\n\n        spin_lock(&flow->lock);\n        flow->used = jiffies;\n        flow->packet_count++;\n        flow->byte_count += skb->len;\n        flow->tcp_flags |= tcp_flags;\n        spin_unlock(&flow->lock);\n}\n\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5982\u679c\u8a72\u5c01\u5305\u6eff\u8db3(IP/IPV6,TCP)\u4e14TCP\u6709\u984d\u5916\u7684flag\u7684\u8a71\uff0c\u5c31\u66f4\u65b0\u5176TCP_FLAGS"),(0,r.kt)("li",{parentName:"ul"},"\u66f4\u65b0\u8a72flow\u7684\u76f8\u95dc\u8cc7\u8a0a"),(0,r.kt)("li",{parentName:"ul"},"used(\u4e0a\u6b21\u4f7f\u7528\u6642\u9593),\u55ae\u4f4d\u662f ",(0,r.kt)("strong",{parentName:"li"},"jiffies")),(0,r.kt)("li",{parentName:"ul"},"counter.")),(0,r.kt)("h3",{id:"ovs_execute_actions"},"ovs_execute_actions"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"/* Execute a list of actions against 'skb'. */\nint ovs_execute_actions(struct datapath *dp, struct sk_buff *skb)\n{\n        struct sw_flow_actions *acts = rcu_dereference(OVS_CB(skb)->flow->sf_acts);\n        struct loop_counter *loop;\n        int error;\n\n        /* Check whether we've looped too much. */\n        loop = &__get_cpu_var(loop_counters);\n        if (unlikely(++loop->count > MAX_LOOPS))\n                loop->looping = true;\n        if (unlikely(loop->looping)) {\n                error = loop_suppress(dp, acts);\n                kfree_skb(skb);\n                goto out_loop;\n        }\n\n        OVS_CB(skb)->tun_key = NULL;\n        error = do_execute_actions(dp, skb, acts->actions,\n                                         acts->actions_len, false);\n\n        /* Check whether sub-actions looped too much. */\n        if (unlikely(loop->looping))\n                error = loop_suppress(dp, acts);\n\nout_loop:\n        /* Decrement loop counter. */\n        if (!--loop->count)\n                loop->looping = false;\n\n        return error;\n}\n\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u5148\u5f9eflow_sf_acts\u4e2d\u53d6\u51fa\u5c0d\u61c9\u7684actions(sw_flow_actions)"),(0,r.kt)("li",{parentName:"ul"},"\u9019\u908a\u6703\u9650\u5236\u57f7\u884c ",(0,r.kt)("strong",{parentName:"li"},"do_execute_actions"),"\u7684\u6b21\u6578\uff0c\u8a2d\u8a08\u7406\u5ff5\u5c1a\u672a\u660e\u77ad\u3002"),(0,r.kt)("li",{parentName:"ul"},"\u547c\u53eb ",(0,r.kt)("strong",{parentName:"li"},"do_execute_actions"),"\u4f86\u505a\u5f8c\u7e8c\u7684\u8655\u7406")),(0,r.kt)("h3",{id:"do_execute_actions"},"do_execute_actions"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"static int do_execute_actions(struct datapath *dp, struct sk_buff *skb,\n                        const struct nlattr *attr, int len, bool keep_skb)\n{\n        /* Every output action needs a separate clone of 'skb', but the common\n         * case is just a single output action, so that doing a clone and\n         * then freeing the original skbuff is wasteful.  So the following code\n         * is slightly obscure just to avoid that. */\n        int prev_port = -1;\n        const struct nlattr *a;\n        int rem;\n\n        for (a = attr, rem = len; rem > 0;\n             a = nla_next(a, &rem)) {\n                int err = 0;\n\n                if (prev_port != -1) {\n                        do_output(dp, skb_clone(skb, GFP_ATOMIC), prev_port);\n                        prev_port = -1;\n                }\n\n                switch (nla_type(a)) {\n                case OVS_ACTION_ATTR_OUTPUT:\n                        prev_port = nla_get_u32(a);\n                        break;\n\n                case OVS_ACTION_ATTR_USERSPACE:\n                        output_userspace(dp, skb, a);\n                        break;\n\n                case OVS_ACTION_ATTR_PUSH_VLAN:\n                        err = push_vlan(skb, nla_data(a));\n                        if (unlikely(err)) /* skb already freed. */\n                                return err;\n                        break;\n\n                case OVS_ACTION_ATTR_POP_VLAN:\n                        err = pop_vlan(skb);\n                        break;\n\n                case OVS_ACTION_ATTR_SET:\n                        err = execute_set_action(skb, nla_data(a));\n                        break;\n\n                case OVS_ACTION_ATTR_SAMPLE:\n                        err = sample(dp, skb, a);\n                        break;\n                }\n\n                if (unlikely(err)) {\n                        kfree_skb(skb);\n                        return err;\n                }\n        }\n\n        if (prev_port != -1) {\n                if (keep_skb)\n                        skb = skb_clone(skb, GFP_ATOMIC);\n\n                do_output(dp, skb, prev_port);\n        } else if (!keep_skb)\n                consume_skb(skb);\n\n        return 0;\n\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"flow\u7684action\u90fd\u662f\u900f\u904e",(0,r.kt)("strong",{parentName:"li"},"nlattr"),"\u4f86\u5132\u5b58\uff0c\u9019\u662fnetlink\u76f8\u95dc\u7684\u8cc7\u6599\u7d50\u69cb\uff0c\u56e0\u70ba ",(0,r.kt)("strong",{parentName:"li"},"user space"),"\u4e5f\u6703\u900f\u904enetlink\u7684\u65b9\u5f0f\u8981\u6c42kernel\u76f4\u63a5\u8655\u7406\u5c01\u5305\uff0c\u6240\u4ee5action\u90fd\u7528 ",(0,r.kt)("strong",{parentName:"li"},"nlattr"),"\u4f86\u8655\u7406"),(0,r.kt)("li",{parentName:"ul"},"\u56e0\u70ba\u53ef\u4ee5 output\u5230\u591a\u500bport\u53bb\uff0c\u6bcf\u6b21\u90fd\u6703\u9700\u8981\u8907\u88fd ",(0,r.kt)("strong",{parentName:"li"},"skb"),"\uff0c\u6240\u4ee5\u9019\u908a\u4f7f\u7528 ",(0,r.kt)("strong",{parentName:"li"},"prev_port"),"\u4f86\u8655\u7406\u53ea\u6709\u4e00\u6b21 output\u7684\u60c5\u6cc1(\u4e0d\u7528\u8907\u88fd)")),(0,r.kt)("h2",{id:"not-found"},"Not found"),(0,r.kt)("p",null,"\u5982\u679c\u6c92\u6709\u627e\u5230\u8a72flow\uff0ckernel\u5c31\u6703\u900f\u904enetlink\u7684\u65b9\u5f0f\uff0c\u628a\u9019\u500b\u5c01\u5305\u9001\u5230 ",(0,r.kt)("strong",{parentName:"p"},"ovs-vswitched"),"\u53bb\u8655\u7406\u3002"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"               struct dp_upcall_info upcall;\n               upcall.cmd = OVS_PACKET_CMD_MISS;\n               upcall.key = &key;\n               upcall.userdata = NULL;\n               upcall.portid = p->upcall_portid;\n               ovs_dp_upcall(dp, skb, &upcall);\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"struct dp_upcall_info {\n        u8 cmd;\n        const struct sw_flow_key *key;\n        const struct nlattr *userdata;\n        u32 portid;\n};\n\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u6bcf\u500b ",(0,r.kt)("strong",{parentName:"li"},"dp_upcall_info"),"\u90fd\u662f\u900f\u904e ",(0,r.kt)("strong",{parentName:"li"},"netlink"),"\u7684\u65b9\u5f0f\u628a\u8cc7\u6599\u9001\u5230 ",(0,r.kt)("strong",{parentName:"li"},"userspace"),",\u9019\u908a\u8981\u8a18\u9304"),(0,r.kt)("li",{parentName:"ul"},"\u8cc7\u6599\u8a2d\u5b9a\u5b8c\u7562\u5f8c\uff0c \u547c\u53eb ",(0,r.kt)("strong",{parentName:"li"},"ovs_dp_upcall"),"\u4f86\u8655\u7406")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"int ovs_dp_upcall(struct datapath *dp, struct sk_buff *skb,\n                  const struct dp_upcall_info *upcall_info)\n{\n        struct dp_stats_percpu *stats;\n        int dp_ifindex;\n        int err;\n\n        if (upcall_info->portid == 0) {\n                err = -ENOTCONN;\n                goto err;\n        }\n\n        dp_ifindex = get_dpifindex(dp);\n        if (!dp_ifindex) {\n                err = -ENODEV;\n                goto err;\n        }\n\n        if (!skb_is_gso(skb))\n                err = queue_userspace_packet(ovs_dp_get_net(dp), dp_ifindex, skb, upcall_info);\n        else\n                err = queue_gso_packets(ovs_dp_get_net(dp), dp_ifindex, skb, upcall_info);\n        if (err)\n                goto err;\n\n        return 0;\n\nerr:\n        stats = this_cpu_ptr(dp->stats_percpu);\n\n        u64_stats_update_begin(&stats->sync);\n        stats->n_lost++;\n        u64_stats_update_end(&stats->sync);\n\n        return err;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u6aa2\u67e5 porrid(port number)\u662f\u5426\u6b63\u5e38"),(0,r.kt)("li",{parentName:"ul"},"\u53d6\u5f97\u8a72 datapath\u7684index"),(0,r.kt)("li",{parentName:"ul"},"\u6839\u64da\u6709\u4f7f\u7528 ",(0,r.kt)("strong",{parentName:"li"},"gso"),"\u7684\u8a71\uff0c\u5c31\u6703\u7279\u5225\u8655\u7406\uff0c\u56e0\u70ba\u5c01\u5305\u7684\u9577\u5ea6\u6bd4\u8f03\u5927\uff0c\u6703\u900f\u904e\u591a\u6b21\u7684 ",(0,r.kt)("strong",{parentName:"li"},"queue_userspace_packet"),"\u4f86\u8655\u7406\u652f\u63f4 ",(0,r.kt)("strong",{parentName:"li"},"gso"),"\u7684\u5c01\u5305\u3002"),(0,r.kt)("li",{parentName:"ul"},"\u5982\u679c\u767c\u751ferror\uff0c\u610f\u5473\u8005\u9019\u500b\u5c01\u5305\u5c31\u4e0d\u6703\u6709\u4eba\u8655\u7406\u4e86\uff0c\u56e0\u6b64\u628alost\u7684\u503c\u589e\u52a0")),(0,r.kt)("h3",{id:"queue_userspace_packet"},"queue_userspace_packet"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"\n static int queue_userspace_packet(struct net *net, int dp_ifindex,\n                                  struct sk_buff *skb,\n                                  const struct dp_upcall_info *upcall_info)\n{\n        struct ovs_header *upcall;\n        struct sk_buff *nskb = NULL;\n        struct sk_buff *user_skb; /* to be queued to userspace */\n        struct nlattr *nla;\n        int err;\n        if (vlan_tx_tag_present(skb)) {\n                nskb = skb_clone(skb, GFP_ATOMIC);\n                if (!nskb)\n                        return -ENOMEM;\n\n                nskb = __vlan_put_tag(nskb, nskb->vlan_proto, vlan_tx_tag_get(nskb));\n                if (!nskb)\n                        return -ENOMEM;\n\n                vlan_set_tci(nskb, 0);\n\n                skb = nskb;\n        }\n\n        if (nla_attr_size(skb->len) > USHRT_MAX) {\n                err = -EFBIG;\n                goto out;\n        }\n\n        user_skb = genlmsg_new(upcall_msg_size(skb, upcall_info->userdata), GFP_ATOMIC);\n        if (!user_skb) {\n                err = -ENOMEM;\n                goto out;\n        }\n\n        upcall = genlmsg_put(user_skb, 0, 0, &dp_packet_genl_family,\n                             0, upcall_info->cmd);\n        upcall->dp_ifindex = dp_ifindex;\n\n        nla = nla_nest_start(user_skb, OVS_PACKET_ATTR_KEY);\n        ovs_flow_to_nlattrs(upcall_info->key, upcall_info->key, user_skb);\n        nla_nest_end(user_skb, nla);\n\n        if (upcall_info->userdata)\n                __nla_put(user_skb, OVS_PACKET_ATTR_USERDATA,\n                          nla_len(upcall_info->userdata),\n                          nla_data(upcall_info->userdata));\n\n        nla = __nla_reserve(user_skb, OVS_PACKET_ATTR_PACKET, skb->len);\n\n        skb_copy_and_csum_dev(skb, nla_data(nla));\n        err = genlmsg_unicast(net, user_skb, upcall_info->portid);\n\nout:\n        kfree_skb(nskb);\n        return err;\n}\n\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u9019\u908a\u7522\u751f ",(0,r.kt)("strong",{parentName:"li"},"generic netlink")," \u7136\u5f8c\u628a\u8cc7\u6599\u8a2d\u5b9a\u5b8c\u7562\u5f8c\uff0c\u5c31\u9001\u51fa\u5230 ",(0,r.kt)("strong",{parentName:"li"},"userspace")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"genlmsg_"),"\u7cfb\u5217\u5c1a\u672a\u5b8c\u5168\u77ad\u89e3\uff0c\u5f85\u88dc\u5145")))}c.isMDXComponent=!0}}]);