"use strict";(self.webpackChunkhwchiu=self.webpackChunkhwchiu||[]).push([[1029],{3905:(e,n,t)=>{t.d(n,{Zo:()=>i,kt:()=>m});var a=t(67294);function _(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){_(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,_=function(e,n){if(null==e)return{};var t,a,_={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(_[t]=e[t]);return _}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(_[t]=e[t])}return _}var c=a.createContext({}),o=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},i=function(e){var n=o(e.components);return a.createElement(c.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,_=e.mdxType,r=e.originalType,c=e.parentName,i=s(e,["components","mdxType","originalType","parentName"]),d=o(t),u=_,m=d["".concat(c,".").concat(u)]||d[u]||p[u]||r;return t?a.createElement(m,l(l({ref:n},i),{},{components:t})):a.createElement(m,l({ref:n},i))}));function m(e,n){var t=arguments,_=n&&n.mdxType;if("string"==typeof e||_){var r=t.length,l=new Array(r);l[0]=u;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s[d]="string"==typeof e?e:_,l[1]=s;for(var o=2;o<r;o++)l[o]=t[o];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},49872:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>o});var a=t(87462),_=(t(67294),t(3905));const r={title:"Ceph Network - AsyncConnection",tags:["Network","Ceph","SDS","SourceCode","Linux"],date:new Date("2017-05-31T06:50:49.000Z")},l=void 0,s={unversionedId:"2017/ceph-async-connection",id:"2017/ceph-async-connection",title:"Ceph Network - AsyncConnection",description:"AsyncConnection \u6b64\u7269\u4ef6\u4ee3\u8868\u6574\u500b connection\uff0c\u88e1\u9762\u63d0\u4f9b\u4e86\u6536\u9001(Write/Read)\u5169\u500b\u4e3b\u8981\u4ecb\u9762\u4f9b\u61c9\u7528\u5c64(OSD/MON\u7b49)\u4f7f\u7528\u5916\uff0c\u88e1\u9762\u4e5f\u8655\u7406\u4e86\u6574\u500b Ceph Node\u6536\u9001\u5c01\u5305\u7684\u908f\u8f2f\u8655\u7406\uff0c\u9019\u90e8\u5206\u6bd4\u8f03\u50cf\u662f\u4e00\u500b finite state machine(FSM)\uff0c\u7576\u524d\u72c0\u614b\u662f\u4ec0\u9ebc\u6642\u5019\uff0c\u6536\u5230\u7684\u5c01\u5305\u662f\u4ec0\u9ebc\uff0c\u5c31\u5207\u63db\u5230\u4ec0\u9ebc\u72c0\u614b\u4f86\u8655\u7406\u3002",source:"@site/docs/2017/ceph-async-connection.md",sourceDirName:"2017",slug:"/2017/ceph-async-connection",permalink:"/docs/2017/ceph-async-connection",draft:!1,tags:[{label:"Network",permalink:"/docs/tags/network"},{label:"Ceph",permalink:"/docs/tags/ceph"},{label:"SDS",permalink:"/docs/tags/sds"},{label:"SourceCode",permalink:"/docs/tags/source-code"},{label:"Linux",permalink:"/docs/tags/linux"}],version:"current",lastUpdatedBy:"HWC",frontMatter:{title:"Ceph Network - AsyncConnection",tags:["Network","Ceph","SDS","SourceCode","Linux"],date:"2017-05-31T06:50:49.000Z"},sidebar:"techPost",previous:{title:"Anki \u4f7f\u7528\u611f\u60f3 (tutorial)",permalink:"/docs/2017/anki-tutorial"},next:{title:"Ceph Network Architecture \u7814\u7a76(\u4e00)",permalink:"/docs/2017/ceph-network-i"}},c={},o=[{value:"STATE_ACCEPTING",id:"state_accepting",level:2},{value:"STATE_ACCEPTING_WAIT_BANNER_ADDR",id:"state_accepting_wait_banner_addr",level:2},{value:"STATE_ACCEPTING_WAIT_CONNECT_MSG",id:"state_accepting_wait_connect_msg",level:2},{value:"STATE_ACCEPTING_WAIT_CONNECT_MSG_AUTH",id:"state_accepting_wait_connect_msg_auth",level:2},{value:"STATE_ACCEPTING_WAIT_SEQ",id:"state_accepting_wait_seq",level:2},{value:"STATE_ACCEPTING_READY",id:"state_accepting_ready",level:2},{value:"STATE_OPEN",id:"state_open",level:2},{value:"STATE_OPEN_MESSAGE_HEADER",id:"state_open_message_header",level:2},{value:"STATE_OPEN_MESSAGE_THROTTLE_MESSAGE",id:"state_open_message_throttle_message",level:2},{value:"STATE_OPEN_MESSAGE_THROTTLE_BYTES;",id:"state_open_message_throttle_bytes",level:2},{value:"STATE_OPEN_MESSAGE_THROTTLE_DISPATCH_QUEUE",id:"state_open_message_throttle_dispatch_queue",level:2},{value:"STATE_OPEN_MESSAGE_READ_FRONT",id:"state_open_message_read_front",level:2},{value:"STATE_OPEN_MESSAGE_READ_MIDDLE",id:"state_open_message_read_middle",level:2},{value:"STATE_OPEN_MESSAGE_READ_DATA_PREPARE",id:"state_open_message_read_data_prepare",level:2},{value:"STATE_OPEN_MESSAGE_READ_DATA",id:"state_open_message_read_data",level:2},{value:"STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH",id:"state_open_message_read_footer_and_dispatch",level:2},{value:"STATE_CONNECTING",id:"state_connecting",level:2},{value:"STATE_CONNECTING_RE",id:"state_connecting_re",level:2},{value:"STATE_CONNECTING_WAIT_BANNER_AND_IDENTIFY",id:"state_connecting_wait_banner_and_identify",level:2},{value:"STATE_CONNECTING_SEND_CONNECT_MSG",id:"state_connecting_send_connect_msg",level:2},{value:"STATE_CONNECTING_WAIT_CONNECT_REPLY",id:"state_connecting_wait_connect_reply",level:2},{value:"STATE_CONNECTING_WAIT_CONNECT_REPLY_AUTH",id:"state_connecting_wait_connect_reply_auth",level:2},{value:"STATE_CONNECTING_READY",id:"state_connecting_ready",level:2},{value:"handle_connect_reply",id:"handle_connect_reply",level:2},{value:"handle_connect_msg",id:"handle_connect_msg",level:2}],i={toc:o},d="wrapper";function p(e){let{components:n,...t}=e;return(0,_.kt)(d,(0,a.Z)({},i,t,{components:n,mdxType:"MDXLayout"}),(0,_.kt)("p",null,"AsyncConnection \u6b64\u7269\u4ef6\u4ee3\u8868\u6574\u500b connection\uff0c\u88e1\u9762\u63d0\u4f9b\u4e86\u6536\u9001(Write/Read)\u5169\u500b\u4e3b\u8981\u4ecb\u9762\u4f9b\u61c9\u7528\u5c64(OSD/MON\u7b49)\u4f7f\u7528\u5916\uff0c\u88e1\u9762\u4e5f\u8655\u7406\u4e86\u6574\u500b ",(0,_.kt)("strong",{parentName:"p"},"Ceph Node"),"\u6536\u9001\u5c01\u5305\u7684\u908f\u8f2f\u8655\u7406\uff0c\u9019\u90e8\u5206\u6bd4\u8f03\u50cf\u662f\u4e00\u500b ",(0,_.kt)("strong",{parentName:"p"},"finite state machine(FSM)"),"\uff0c\u7576\u524d\u72c0\u614b\u662f\u4ec0\u9ebc\u6642\u5019\uff0c\u6536\u5230\u7684\u5c01\u5305\u662f\u4ec0\u9ebc\uff0c\u5c31\u5207\u63db\u5230\u4ec0\u9ebc\u72c0\u614b\u4f86\u8655\u7406\u3002\n\u6bcf\u500b AsyncConnection \u6703\u50cf\u5e95\u5c64\u7684 ",(0,_.kt)("strong",{parentName:"p"},"Event Engine"),"\u8a3b\u518a\u4e00\u500b ",(0,_.kt)("strong",{parentName:"p"},"call back function"),"\uff0c\u7576\u8a72 ",(0,_.kt)("strong",{parentName:"p"},"connection")," \u63a5\u6536\u5230\u5c01\u5305\u5f8c\uff0c\u5c31\u6703\u89f8\u767c\u8a72 ",(0,_.kt)("strong",{parentName:"p"},"function"),"\uff0c\u800c\u6b64 ",(0,_.kt)("strong",{parentName:"p"},"function"),"\u5c31\u662f ",(0,_.kt)("strong",{parentName:"p"},"Process"),"\uff0c\u6240\u4ee5\u63a5\u4e0b\u4f86\u6703\u5f9e\u6b64 function \u7576\u4f5c\u4e0b\u624b\u9ede\uff0c\u4e3b\u8981\u7814\u7a76\u96d9\u65b9\u9023\u7dda\u5efa\u7acb\u7684\u904e\u7a0b\uff0c\u7279\u5225\u662f\u5f9e ",(0,_.kt)("strong",{parentName:"p"},"Service side")," \u53bb\u89c0\u5bdf ",(0,_.kt)("strong",{parentName:"p"},"Accept")," \u5c01\u5305\u5f8c\u7684\u6d41\u7a0b\u3002"),(0,_.kt)("h1",{id:"accept"},"Accept"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u7576 ",(0,_.kt)("strong",{parentName:"li"},"Server Side")," \u547c\u53eb\u6b64 ",(0,_.kt)("strong",{parentName:"li"},"function"),"\u5f8c\uff0c\u5c31\u6703\u958b\u59cb\u7b49\u5f85 ",(0,_.kt)("strong",{parentName:"li"},"client"),"\u4f86\u9023\u7dda\u3002"),(0,_.kt)("li",{parentName:"ul"},"\u5c07 socket \u8ddf addr \u90fd\u8a18\u9304\u4e0b\u4f86\uff0c\u4e26\u4e14\u5c07\u72c0\u614b\u6539\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_ACCEPTING")),(0,_.kt)("li",{parentName:"ul"},"\u767c\u9001\u4e00\u500b external event(read_handler) \u7d66 eventCenter",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"\u6b64 read_handler \u5c31\u662f ",(0,_.kt)("inlineCode",{parentName:"li"},"process"),"\uff0c\u6703\u4e00\u76f4\u6839\u64da\u7576\u524d state \u7684\u72c0\u614b\u4f86\u9032\u884c\u5404\u7a2e\u8655\u7406")))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'1866 void AsyncConnection::accept(ConnectedSocket socket, entity_addr_t &addr)\n1867 {\n1868   ldout(async_msgr->cct, 10) << __func__ << " sd=" << socket.fd() << dendl;\n1869   assert(socket.fd() >= 0);\n1870\n1871   std::lock_guard<std::mutex> l(lock);\n1872   cs = std::move(socket);\n1873   socket_addr = addr;\n1874   state = STATE_ACCEPTING;\n1875   // rescheduler connection in order to avoid lock dep\n1876   center->dispatch_event_external(read_handler);\n1877 }\n')),(0,_.kt)("h1",{id:"process"},"Process"),(0,_.kt)("p",null,"\u7576",(0,_.kt)("strong",{parentName:"p"},"AsyncConnection"),"\u6709\u6536\u5230\u4efb\u4f55\u5c01\u5305\u6642\uff0c\u5c31\u6703\u547c\u53eb\u9019\u500b ",(0,_.kt)("strong",{parentName:"p"},"function"),"\uff0c\u6211\u5011\u9019\u908a\u5047\u8a2d\u6211\u5011\u662f ",(0,_.kt)("strong",{parentName:"p"},"Server Side"),"\uff0c\u7136\u5f8c\u7576\u524d ",(0,_.kt)("strong",{parentName:"p"},"Socket")," \u8655\u65bc\u4e00\u7a2e ",(0,_.kt)("strong",{parentName:"p"},"Accepting")," \u7684\u72c0\u614b\uff0c\u5728\u6b64\u72c0\u614b\u4e0b\u6536\u5230\u9023\u7dda\u7684\u5c01\u5305\u5f8c\uff0c\u6703\u600e\u9ebc\u8655\u7406\u3002"),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'0329 void AsyncConnection::process()\n0330 {\n0331   ssize_t r = 0;\n0332   int prev_state = state;\n0333 #if defined(WITH_LTTNG) && defined(WITH_EVENTTRACE)\n0334   utime_t ltt_recv_stamp = ceph_clock_now();\n0335 #endif\n0336   bool need_dispatch_writer = false;\n0337   std::lock_guard<std::mutex> l(lock);\n0338   last_active = ceph::coarse_mono_clock::now();\n0339   do {\n0340     ldout(async_msgr->cct, 20) << __func__ << " prev state is " << get_state_name(prev_state) << dendl;\n0341     prev_state = state;\n0342     switch (state) {\n0343       case STATE_OPEN:\n....\n0837       default:\n0838         {\n0839           if (_process_connection() < 0)\n0840             goto fail;\n0841           break;\n0842         }\n0843     }\n0844   } while (prev_state != state);\n0845\n0846   if (need_dispatch_writer && is_connected())\n0847     center->dispatch_event_external(write_handler);\n0848   return;\n0849\n0850  fail:\n0851   fault();\n0852 }\n')),(0,_.kt)("p",null,"\u57fa\u672c\u4e0a\u5c31\u662f\u8dd1\u4e00\u500b\u5927\u8ff4\u5708\uff0c\u6839\u64da\u7576\u524d\u72c0\u614b\u8655\u7406\u4e0d\u540c\u7684\u4e8b\u60c5\uff0c\u76f4\u5230\u72c0\u614b\u5df2\u7d93\u7a69\u5b9a ",(0,_.kt)("strong",{parentName:"p"},"(prev_state == state)"),"\uff0c \u5982\u679c\u4e0d\u7b26\u5408\u5927\u90e8\u5206\u7684 State\uff0c\u5247\u547c\u53eb ",(0,_.kt)("inlineCode",{parentName:"p"},"_process_connection")," \u4f86\u8655\u7406\uff0c\u8b6c\u5982 ",(0,_.kt)("strong",{parentName:"p"},"STATE_ACCEPTING"),"\u3002\n\u4e00\u65e6\u5efa\u7acb ",(0,_.kt)("strong",{parentName:"p"},"Server Socket"),"\u6642\u4e26\u4e14\u958b\u59cb\u900f\u904e ",(0,_.kt)("strong",{parentName:"p"},"Accept")," \u7b49\u5f85\u9023\u7dda\u6642\uff0c\u72c0\u614b\u5247\u521d\u59cb\u5316\u70ba ",(0,_.kt)("strong",{parentName:"p"},"STATE_ACCEPTING"),"\uff0c\u6240\u4ee5\u63a5\u4e0b\u4f86\u5c31\u5f9e\u9019\u500b\u72c0\u614b\u958b\u59cb\u5f80\u4e0b\u7814\u7a76\u3002"),(0,_.kt)("h2",{id:"state_accepting"},"STATE_ACCEPTING"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u56e0\u70ba\u5148\u524d\u5207\u63db\u5230\u6b64\u72c0\u614b\u6642\uff0c\u662f\u900f\u904e ",(0,_.kt)("strong",{parentName:"li"},"external event")," \u547c\u53eb\u7684(\u53ea\u6703\u57f7\u884c\u4e00\u6b21)\uff0c\u6240\u4ee5\u9019\u908a\u8981\u5c07\u8a72 ",(0,_.kt)("strong",{parentName:"li"},"readable event handler (process)")," \u6b63\u5f0f\u7684\u4e1f\u7d66 ",(0,_.kt)("strong",{parentName:"li"},"event center")," \u4e00\u6b21"),(0,_.kt)("li",{parentName:"ul"},"\u63a5\u4e0b\u4f86\u8981\u767c\u9001\u4e00\u4e9b\u8a0a\u606f\u5230\u5c0d\u9762\u53bb\uff0c\u9019\u908a\u9700\u8981\u4e0b\u5217\u8cc7\u8a0a",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"CEPH_BANNER"),(0,_.kt)("li",{parentName:"ul"},"Addr + Port"))),(0,_.kt)("li",{parentName:"ul"},"\u547c\u53eb try_send \u53bb\u767c\u9001\u8a0a\u606f",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"\u82e5\u6210\u529f (r == 0), \u72c0\u614b\u5207\u63db\u5230 ",(0,_.kt)("strong",{parentName:"li"},"STATE_ACCEPTING_WAIT_BANNER_ADDR")),(0,_.kt)("li",{parentName:"ul"},"\u82e5\u5931\u6557 (r > 0),\u72c0\u614b\u5207\u63db\u5230 ",(0,_.kt)("strong",{parentName:"li"},"STATE_WAIT_SEND"),"\uff0c\u4e26\u4e14\u4f7f\u7528\u4e00\u500b ",(0,_.kt)("strong",{parentName:"li"},"strate_after_send")," \u7684\u8b8a\u6578\u4f86\u8a18\u4f4f\u7576\u6210\u529f\u9001\u51fa\u5f8c\u8981\u5207\u63db\u6210\u4ec0\u9ebc\u72c0\u614b"),(0,_.kt)("li",{parentName:"ul"},"\u82e5\u5931\u6557 (r < 0),\u771f\u7684\u5931\u6557\u4e86\uff0c\u5c31\u7576\u4f5c\u5931\u6557\u8655\u7406\u3002")))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'1215     case STATE_ACCEPTING:\n1216       {\n1217         bufferlist bl;\n1218         center->create_file_event(cs.fd(), EVENT_READABLE, read_handler);\n1219\n1220         bl.append(CEPH_BANNER, strlen(CEPH_BANNER));\n1221\n1222         ::encode(async_msgr->get_myaddr(), bl, 0); // legacy\n1223         port = async_msgr->get_myaddr().get_port();\n1224         ::encode(socket_addr, bl, 0); // legacy\n1225         ldout(async_msgr->cct, 1) << __func__ << " sd=" << cs.fd() << " " << socket_addr << dendl;\n1226\n1227         r = try_send(bl);\n1228         if (r == 0) {\n1229           state = STATE_ACCEPTING_WAIT_BANNER_ADDR;\n1230           ldout(async_msgr->cct, 10) << __func__ << " write banner and addr done: "\n1231             << get_peer_addr() << dendl;\n1232         } else if (r > 0) {\n1233           state = STATE_WAIT_SEND;\n1234           state_after_send = STATE_ACCEPTING_WAIT_BANNER_ADDR;\n1235           ldout(async_msgr->cct, 10) << __func__ << " wait for write banner and addr: "\n1236                               << get_peer_addr() << dendl;\n1237         } else {\n1238           goto fail;\n1239         }\n1240\n1241         break;\n1242       }\n')),(0,_.kt)("h2",{id:"state_accepting_wait_banner_addr"},"STATE_ACCEPTING_WAIT_BANNER_ADDR"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u8b80\u53d6\u5c0d\u65b9\u7684\u5c01\u5305\u7684\u8cc7\u8a0a(\u4ee3\u8868 Client Side \u4e5f\u5fc5\u9808\u8981\u767c\u9001\u76f8\u95dc\u8a0a\u606f)",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"CEPH_BANNER"),(0,_.kt)("li",{parentName:"ul"},"Addr + Port"))),(0,_.kt)("li",{parentName:"ul"},"\u6bd4\u8f03 banner \u8cc7\u8a0a"),(0,_.kt)("li",{parentName:"ul"},"\u82e5\u5c0d\u65b9\u4e0d\u77e5\u9053\u81ea\u5df1\u7684 addr\uff0c\u5247\u900f\u904e socket \u7684\u8cc7\u8a0a\u53d6\u5f97\u4e26\u4e14\u8a18\u9304\u4e0b\u4f86"),(0,_.kt)("li",{parentName:"ul"},"\u72c0\u614b\u6539\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_ACCEPTING_WAIT_CONNECT_MSG"))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'1243     case STATE_ACCEPTING_WAIT_BANNER_ADDR:\n1244       {\n1245         bufferlist addr_bl;\n1246         entity_addr_t peer_addr;\n1247\n1248         r = read_until(strlen(CEPH_BANNER) + sizeof(ceph_entity_addr), state_buffer);\n1249         if (r < 0) {\n1250           ldout(async_msgr->cct, 1) << __func__ << " read peer banner and addr failed" << dendl;\n1251           goto fail;\n1252         } else if (r > 0) {\n1253           break;\n1254         }\n1255\n1256         if (memcmp(state_buffer, CEPH_BANNER, strlen(CEPH_BANNER))) {\n1257           ldout(async_msgr->cct, 1) << __func__ << " accept peer sent bad banner \'" << state_buffer\n1258                                     << "\' (should be \'" << CEPH_BANNER << "\')" << dendl;\n1259           goto fail;\n1260         }\n1261\n1262         addr_bl.append(state_buffer+strlen(CEPH_BANNER), sizeof(ceph_entity_addr));\n1263         {\n1264           bufferlist::iterator ti = addr_bl.begin();\n1265           ::decode(peer_addr, ti);\n1266         }\n1267\n1268         ldout(async_msgr->cct, 10) << __func__ << " accept peer addr is " << peer_addr << dendl;\n1269         if (peer_addr.is_blank_ip()) {\n1270           // peer apparently doesn\'t know what ip they have; figure it out for them.\n1271           int port = peer_addr.get_port();\n1272           peer_addr.u = socket_addr.u;\n1273           peer_addr.set_port(port);\n1274           ldout(async_msgr->cct, 0) << __func__ << " accept peer addr is really " << peer_addr\n1275                              << " (socket is " << socket_addr << ")" << dendl;\n1276         }\n1277         set_peer_addr(peer_addr);  // so that connection_state gets set up\n1278         state = STATE_ACCEPTING_WAIT_CONNECT_MSG;\n1279         break;\n1280       }\n')),(0,_.kt)("h2",{id:"state_accepting_wait_connect_msg"},"STATE_ACCEPTING_WAIT_CONNECT_MSG"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u8b80\u53d6 connect_msg \u5927\u5c0f\u7684\u8cc7\u6599,\u4e26\u4e14\u5b58\u653e\u5230 ",(0,_.kt)("strong",{parentName:"li"},"AsyncConnection")," \u7684\u6210\u54e1 ",(0,_.kt)("strong",{parentName:"li"},"connect_msg"),"\u4e2d\uff0c\u8a72\u7d50\u69cb\u5982\u4e0b\uff0c\u7d00\u9304\u4e86\u5982 ",(0,_.kt)("strong",{parentName:"li"},"feature"),", ",(0,_.kt)("strong",{parentName:"li"},"type")," \u7b49\u8cc7\u8a0a\u3002"),(0,_.kt)("li",{parentName:"ul"},"\u6700\u5f8c\u5c07\u72c0\u614b\u8f49\u63db\u6210 **\n**")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},"0099 struct ceph_msg_connect {\n0100     __le64 features;     /* supported feature bits */\n0101     __le32 host_type;    /* CEPH_ENTITY_TYPE_* */\n0102     __le32 global_seq;   /* count connections initiated by this host */\n0103     __le32 connect_seq;  /* count connections initiated in this session */\n0104     __le32 protocol_version;\n0105     __le32 authorizer_protocol;\n0106     __le32 authorizer_len;\n0107     __u8  flags;         /* CEPH_MSG_CONNECT_* */\n0108 } __attribute__ ((packed));\n")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'1282     case STATE_ACCEPTING_WAIT_CONNECT_MSG:\n1283       {\n1284         r = read_until(sizeof(connect_msg), state_buffer);\n1285         if (r < 0) {\n1286           ldout(async_msgr->cct, 1) << __func__ << " read connect msg failed" << dendl;\n1287           goto fail;\n1288         } else if (r > 0) {\n1289           break;\n1290         }\n1291\n1292         connect_msg = *((ceph_msg_connect*)state_buffer);\n1293         state = STATE_ACCEPTING_WAIT_CONNECT_MSG_AUTH;\n1294         break;\n1295       }\n')),(0,_.kt)("h2",{id:"state_accepting_wait_connect_msg_auth"},"STATE_ACCEPTING_WAIT_CONNECT_MSG_AUTH"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u6839\u64da\u4e4b\u524d\u8b80\u53d6\u5230\u7684 ",(0,_.kt)("strong",{parentName:"li"},"connect_msg")," \u4f86\u64cd\u4f5c"),(0,_.kt)("li",{parentName:"ul"},"\u5982\u679c\u5c0d\u65b9\u6709\u8a2d\u5b9a authorizer_len \u7684\u8a71\uff0c\u5247\u5728\u984d\u5916\u8b80\u53d6 authorizer \u76f8\u95dc\u7684\u8cc7\u8a0a"),(0,_.kt)("li",{parentName:"ul"},"\u8a2d\u5b9a peer \u7684 host type"),(0,_.kt)("li",{parentName:"ul"},"\u6839\u64da host type\uff0c\u53d6\u5f97\u5c0d\u61c9\u7684 policy"),(0,_.kt)("li",{parentName:"ul"},"\u547c\u53eb handle_connect_msg \u8655\u7406\u8a72 connection_msg"),(0,_.kt)("li",{parentName:"ul"},"\u6700\u5f8c\u78ba\u8a8d\u72c0\u614b\u5df2\u7d93\u4e0d\u662f\u672c\u4f86\u7684 ",(0,_.kt)("strong",{parentName:"li"},"STATE_ACCEPTING_WAIT_CONNECT_MSG_AUTH"),(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"\u72c0\u614b\u7406\u8ad6\u4e0a\u8981\u56e0\u70ba\u547c\u53eb\u4e86 ",(0,_.kt)("strong",{parentName:"li"},"handle_connect_msg")," \u800c\u8b8a\u63db\uff0c\u6b63\u5e38\u4f86\u8aaa\u8981\u8b8a\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_ACCEPTING_WAIT_SEQ"))))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'1297     case STATE_ACCEPTING_WAIT_CONNECT_MSG_AUTH:\n1298       {\n1299         bufferlist authorizer_reply;\n1300\n1301         if (connect_msg.authorizer_len) {\n1302           if (!authorizer_buf.length())\n1303             authorizer_buf.push_back(buffer::create(connect_msg.authorizer_len));\n1304\n1305           r = read_until(connect_msg.authorizer_len, authorizer_buf.c_str());\n1306           if (r < 0) {\n1307             ldout(async_msgr->cct, 1) << __func__ << " read connect authorizer failed" << dendl;\n1308             goto fail;\n1309           } else if (r > 0) {\n1310             break;\n1311           }\n1312         }\n1313\n1314         ldout(async_msgr->cct, 20) << __func__ << " accept got peer connect_seq "\n1315                              << connect_msg.connect_seq << " global_seq "\n1316                              << connect_msg.global_seq << dendl;\n1317         set_peer_type(connect_msg.host_type);\n1318         policy = async_msgr->get_policy(connect_msg.host_type);\n1319         ldout(async_msgr->cct, 10) << __func__ << " accept of host_type " << connect_msg.host_type\n1320                                    << ", policy.lossy=" << policy.lossy << " policy.server="\n1321                                    << policy.server << " policy.standby=" << policy.standby\n1322                                    << " policy.resetcheck=" << policy.resetcheck << dendl;\n1323\n1324         r = handle_connect_msg(connect_msg, authorizer_buf, authorizer_reply);\n1325         if (r < 0)\n1326           goto fail;\n1327\n1328         // state is changed by "handle_connect_msg"\n1329         assert(state != STATE_ACCEPTING_WAIT_CONNECT_MSG_AUTH);\n1330         break;\n1331       }\n')),(0,_.kt)("h2",{id:"state_accepting_wait_seq"},"STATE_ACCEPTING_WAIT_SEQ"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u5f9e\u5c0d\u9762\u8b80\u53d6\u5176\u4f7f\u7528\u7684 seq"),(0,_.kt)("li",{parentName:"ul"},"\u547c\u53eb discard_requeued_up_to \u4f86\u8655\u7406\uff0c\u6839\u64da\u7576\u524d\u6536\u5230\u7684 seq \u4f86\u505a\u689d\u4ef6",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"\u5c07 ",(0,_.kt)("strong",{parentName:"li"},"out_q")," \u4e00\u4e9b\u4e0d\u7b26\u5408\u689d\u4ef6\u7684\u6210\u54e1\u90fd\u79fb\u9664"))),(0,_.kt)("li",{parentName:"ul"},"\u72c0\u614b\u6539\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_ACCEPTING_READY")),(0,_.kt)("li",{parentName:"ul"})),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'1333     case STATE_ACCEPTING_WAIT_SEQ:\n1334       {\n1335         uint64_t newly_acked_seq;\n1336         r = read_until(sizeof(newly_acked_seq), state_buffer);\n1337         if (r < 0) {\n1338           ldout(async_msgr->cct, 1) << __func__ << " read ack seq failed" << dendl;\n1339           goto fail_registered;\n1340         } else if (r > 0) {\n1341           break;\n1342         }\n1343\n1344         newly_acked_seq = *((uint64_t*)state_buffer);\n1345         ldout(async_msgr->cct, 2) << __func__ << " accept get newly_acked_seq " << newly_acked_seq << dendl;\n1346         discard_requeued_up_to(newly_acked_seq);\n1347         state = STATE_ACCEPTING_READY;\n1348         break;\n1349       }\n')),(0,_.kt)("h2",{id:"state_accepting_ready"},"STATE_ACCEPTING_READY"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u6e05\u7a7a ",(0,_.kt)("strong",{parentName:"li"},"connect_msg")),(0,_.kt)("li",{parentName:"ul"},"\u72c0\u614b\u6539\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_OPEN")),(0,_.kt)("li",{parentName:"ul"},"\u5982\u679c\u7576\u524d queue \u5167\u6709\u8cc7\u6599(\u4e5f\u8a31\u662f\u5148\u524d existing connection\u7522\u751f\u7684?)\uff0c\u99ac\u4e0a\u9001\u4e00\u500b write_handler \u5c07\u5176\u8655\u7406\u5b8c\u7562")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'1351     case STATE_ACCEPTING_READY:\n1352       {\n1353         ldout(async_msgr->cct, 20) << __func__ << " accept done" << dendl;\n1354         state = STATE_OPEN;\n1355         memset(&connect_msg, 0, sizeof(connect_msg));\n1356\n1357         if (delay_state)\n1358           assert(delay_state->ready());\n1359         // make sure no pending tick timer\n1360         if (last_tick_id)\n1361           center->delete_time_event(last_tick_id);\n1362         last_tick_id = center->create_time_event(inactive_timeout_us, tick_handler);\n1363\n1364         write_lock.lock();\n1365         can_write = WriteStatus::CANWRITE;\n1366         if (is_queued())\n1367           center->dispatch_event_external(write_handler);\n1368         write_lock.unlock();\n1369         maybe_start_delay_thread();\n1370         break;\n1371       }\n')),(0,_.kt)("h2",{id:"state_open"},"STATE_OPEN"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u8b80\u53d6 TAG\uff0c\u6839\u64da TAG \u4e0d\u540c\u7684\u6578\u503c\u57f7\u884c\u4e0d\u540c\u7684\u4e8b\u60c5",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"CEPH_MSGR_TAG_MSG: \u4ee3\u8868\u6709\u8a0a\u606f\u8fd1\u4f86\uff0c\u6545\u5c07\u72c0\u614b\u5207\u63db\u6210 STATE_OPEN_MESSAGE_HEADER")))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'0343       case STATE_OPEN:\n0344         {\n0345           char tag = -1;\n0346           r = read_until(sizeof(tag), &tag);\n0347           if (r < 0) {\n0348             ldout(async_msgr->cct, 1) << __func__ << " read tag failed" << dendl;\n0349             goto fail;\n0350           } else if (r > 0) {\n0351             break;\n0352           }\n0353\n0354           if (tag == CEPH_MSGR_TAG_KEEPALIVE) {\n0355             ldout(async_msgr->cct, 20) << __func__ << " got KEEPALIVE" << dendl;\n0356             set_last_keepalive(ceph_clock_now());\n0357           } else if (tag == CEPH_MSGR_TAG_KEEPALIVE2) {\n0358             state = STATE_OPEN_KEEPALIVE2;\n0359           } else if (tag == CEPH_MSGR_TAG_KEEPALIVE2_ACK) {\n0360             state = STATE_OPEN_KEEPALIVE2_ACK;\n0361           } else if (tag == CEPH_MSGR_TAG_ACK) {\n0362             state = STATE_OPEN_TAG_ACK;\n0363           } else if (tag == CEPH_MSGR_TAG_MSG) {\n0364             state = STATE_OPEN_MESSAGE_HEADER;\n0365           } else if (tag == CEPH_MSGR_TAG_CLOSE) {\n0366             state = STATE_OPEN_TAG_CLOSE;\n0367           } else {\n0368             ldout(async_msgr->cct, 0) << __func__ << " bad tag " << (int)tag << dendl;\n0369             goto fail;\n0370           }\n0371\n0372           break;\n0373         }\n')),(0,_.kt)("h2",{id:"state_open_message_header"},"STATE_OPEN_MESSAGE_HEADER"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u6839\u64da feature \u7684\u503c\uff0c\u6c7a\u5b9a\u8981\u8d70\u65b0\u7248\u9084\u662f\u820a\u7248\u7684 header"),(0,_.kt)("li",{parentName:"ul"},"\u8b80\u53d6 header \u5927\u5c0f\u7684\u8cc7\u6599\uff0c\u7136\u5f8c\u5c07\u9700\u8981\u7684\u8cc7\u6599\u90fd\u6293\u51fa\u4f86\u8a18\u9304\u4e0b\u4f86\u3002"),(0,_.kt)("li",{parentName:"ul"},"\u9a57\u8b49\u5c0d\u65b9\u9001\u4f86\u8cc7\u6599\u7684 CRC \u662f\u5426\u6b63\u78ba"),(0,_.kt)("li",{parentName:"ul"},"\u5c07\u76f8\u95dc\u8cc7\u6599\u7d66 reset (\u9019\u4e9b\u7d50\u69cb\u90fd\u8ddf header \u6709\u95dc)",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"data_buf"),(0,_.kt)("li",{parentName:"ul"},"front"),(0,_.kt)("li",{parentName:"ul"},"middle"),(0,_.kt)("li",{parentName:"ul"},"data"))),(0,_.kt)("li",{parentName:"ul"},"\u8a18\u9304\u6536\u5230\u6642\u9593\u7684\u6642\u9593\u6233"),(0,_.kt)("li",{parentName:"ul"},"\u5c07\u72c0\u614b\u6539\u8b8a\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_OPEN_MESSAGE_THROTTLE_MESSAGE"))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-C++"},'0435       case STATE_OPEN_MESSAGE_HEADER:\n0436         {\n0437 #if defined(WITH_LTTNG) && defined(WITH_EVENTTRACE)\n0438           ltt_recv_stamp = ceph_clock_now();\n0439 #endif\n0440           ldout(async_msgr->cct, 20) << __func__ << " begin MSG" << dendl;\n0441           ceph_msg_header header;\n0442           ceph_msg_header_old oldheader;\n0443           __u32 header_crc = 0;\n0444           unsigned len;\n0445           if (has_feature(CEPH_FEATURE_NOSRCADDR))\n0446             len = sizeof(header);\n0447           else\n0448             len = sizeof(oldheader);\n0449\n0450           r = read_until(len, state_buffer);\n0451           if (r < 0) {\n0452             ldout(async_msgr->cct, 1) << __func__ << " read message header failed" << dendl;\n0453             goto fail;\n0454           } else if (r > 0) {\n0455             break;\n0456           }\n0457\n0458           ldout(async_msgr->cct, 20) << __func__ << " got MSG header" << dendl;\n0459\n0460           if (has_feature(CEPH_FEATURE_NOSRCADDR)) {\n0461             header = *((ceph_msg_header*)state_buffer);\n0462             if (msgr->crcflags & MSG_CRC_HEADER)\n0463               header_crc = ceph_crc32c(0, (unsigned char *)&header,\n0464                                        sizeof(header) - sizeof(header.crc));\n0465           } else {\n0466             oldheader = *((ceph_msg_header_old*)state_buffer);\n0467             // this is fugly\n0468             memcpy(&header, &oldheader, sizeof(header));\n0469             header.src = oldheader.src.name;\n0470             header.reserved = oldheader.reserved;\n0471             if (msgr->crcflags & MSG_CRC_HEADER) {\n0472               header.crc = oldheader.crc;\n0473               header_crc = ceph_crc32c(0, (unsigned char *)&oldheader, sizeof(oldheader) - sizeof(oldheader.crc));\n0474             }\n0475           }\n0476\n0477           ldout(async_msgr->cct, 20) << __func__ << " got envelope type=" << header.type\n0478                               << " src " << entity_name_t(header.src)\n0479                               << " front=" << header.front_len\n0480                               << " data=" << header.data_len\n0481                               << " off " << header.data_off << dendl;\n0482\n0483           // verify header crc\n0484           if (msgr->crcflags & MSG_CRC_HEADER && header_crc != header.crc) {\n0485             ldout(async_msgr->cct,0) << __func__ << " got bad header crc "\n0486                                      << header_crc << " != " << header.crc << dendl;\n0487             goto fail;\n0488           }\n0489\n0490           // Reset state\n0491           data_buf.clear();\n0492           front.clear();\n0493           middle.clear();\n0494           data.clear();\n0495           recv_stamp = ceph_clock_now();\n0496           current_header = header;\n0497           state = STATE_OPEN_MESSAGE_THROTTLE_MESSAGE;\n0498           break;\n0499         }\n')),(0,_.kt)("h2",{id:"state_open_message_throttle_message"},"STATE_OPEN_MESSAGE_THROTTLE_MESSAGE"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u5728 Policy \u4e2d\u6709\u5169\u500b\u95dc\u65bc Throttle \u7684\u8b8a\u6578")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},"0085     /**\n0086      *  The throttler is used to limit how much data is held by Messages from\n0087      *  the associated Connection(s). When reading in a new Message, the Messenger\n0088      *  will call throttler->throttle() for the size of the new Message.\n0089      */\n0090     Throttle *throttler_bytes;\n0091     Throttle *throttler_messages;\n")),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u9019\u500b function \u6aa2\u67e5\u662f\u5426\u6709 ",(0,_.kt)("strong",{parentName:"li"},"throttle")," \u8a0a\u606f\u7684\u6578\u91cf\u9650\u5236\uff0c\u82e5\u6709\u9650\u5236\u4e14\u8d85\u904e\u4e0a\u9650\uff0c\u5247\u5efa\u7acb\u4e00\u500b time event\uff0c\u4e26\u5132\u5b58\u4e0b\u4f86\u3002"),(0,_.kt)("li",{parentName:"ul"},"\u6700\u5f8c\u5c07\u72c0\u614b\u5207\u63db\u5230 ",(0,_.kt)("strong",{parentName:"li"},"STATE_OPEN_MESSAGE_THROTTLE_BYTES"))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-C++"},'0501       case STATE_OPEN_MESSAGE_THROTTLE_MESSAGE:\n0502         {\n0503           if (policy.throttler_messages) {\n0504             ldout(async_msgr->cct, 10) << __func__ << " wants " << 1 << " message from policy throttler "\n0505                                        << policy.throttler_messages->get_current() << "/"\n0506                                        << policy.throttler_messages->get_max() << dendl;\n0507             if (!policy.throttler_messages->get_or_fail()) {\n0508               ldout(async_msgr->cct, 10) << __func__ << " wants 1 message from policy throttle "\n0509                                          << policy.throttler_messages->get_current() << "/"\n0510                                          << policy.throttler_messages->get_max() << " failed, just wait." << dendl;\n0511               // following thread pool deal with th full message queue isn\'t a\n0512               // short time, so we can wait a ms.\n0513               if (register_time_events.empty())\n0514                 register_time_events.insert(center->create_time_event(1000, wakeup_handler));\n0515               break;\n0516             }\n0517           }\n0518\n0519           state = STATE_OPEN_MESSAGE_THROTTLE_BYTES;\n0520           break;\n0521         }\n')),(0,_.kt)("h2",{id:"state_open_message_throttle_bytes"},"STATE_OPEN_MESSAGE_THROTTLE_BYTES;"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u5f9e ",(0,_.kt)("strong",{parentName:"li"},"connection")," \u8b80\u53d6\u8cc7\u6599\uff0c\u5206\u5225\u5c0d\u61c9\u5230 header \u4e2d\u7684\u4e09\u500b\u6210\u54e1",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"front"),(0,_.kt)("li",{parentName:"ul"},"middle"),(0,_.kt)("li",{parentName:"ul"},"data"))),(0,_.kt)("li",{parentName:"ul"},"\u6b64 function \u5247\u662f\u6aa2\u67e5 throttle \u8a0a\u606f\u7684 bytes \u6578\u91cf\uff0c\u82e5\u6578\u91cf\u8d85\u904e\u4e0a\u9650\uff0c\u4e5f\u662f\u5efa\u8b70\u4e00\u500b time event\u4e26\u5b58\u4e0b\u4f86\uff0c\u5f85\u4e4b\u5f8c\u8655\u7406"),(0,_.kt)("li",{parentName:"ul"},"\u6700\u5f8c\u5c07\u72c0\u614b\u5207\u63db\u5230 ",(0,_.kt)("strong",{parentName:"li"},"STATE_OPEN_MESSAGE_THROTTLE_DISPATCH_QUEUE"))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-C++"},'0523       case STATE_OPEN_MESSAGE_THROTTLE_BYTES:\n0524         {\n0525           cur_msg_size = current_header.front_len + current_header.middle_len + current_header.data_len;\n0526           if (cur_msg_size) {\n0527             if (policy.throttler_bytes) {\n0528               ldout(async_msgr->cct, 10) << __func__ << " wants " << cur_msg_size << " bytes from policy throttler "\n0529                                          << policy.throttler_bytes->get_current() << "/"\n0530                                          << policy.throttler_bytes->get_max() << dendl;\n0531               if (!policy.throttler_bytes->get_or_fail(cur_msg_size)) {\n0532                 ldout(async_msgr->cct, 10) << __func__ << " wants " << cur_msg_size << " bytes from policy throttler "\n0533                                            << policy.throttler_bytes->get_current() << "/"\n0534                                            << policy.throttler_bytes->get_max() << " failed, just wait." << dendl;\n0535                 // following thread pool deal with th full message queue isn\'t a\n0536                 // short time, so we can wait a ms.\n0537                 if (register_time_events.empty())\n0538                   register_time_events.insert(center->create_time_event(1000, wakeup_handler));\n0539                 break;\n0540               }\n0541             }\n0542           }\n0543\n0544           state = STATE_OPEN_MESSAGE_THROTTLE_DISPATCH_QUEUE;\n0545           break;\n0546         }\n')),(0,_.kt)("h2",{id:"state_open_message_throttle_dispatch_queue"},"STATE_OPEN_MESSAGE_THROTTLE_DISPATCH_QUEUE"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u5982\u679c\u525b\u525b\u6709\u5728 ",(0,_.kt)("strong",{parentName:"li"},"STATE_OPEN_MESSAGE_THROTTLE_BYTES")," \u8b80\u53d6\u5230 front/middle/data \u7684\u8cc7\u6599\u7684\u8a71\uff0c\u5247\u9019\u908a\u8981\u78ba\u8a8d disaptch \u672c\u8eab\u7684 throttle \u6709\u6c92\u6709\u8d85\u904e\uff0c\u82e5\u8d85\u904e\u4e5f\u662f\u9001\u4e00\u500b time event \u5f85\u7a0d\u5f8c\u518d\u4f86\u91cd\u65b0\u8a66\u8a66\u770b"),(0,_.kt)("li",{parentName:"ul"},"\u7d00\u9304 throttle \u7684\u6642\u9593\u6233"),(0,_.kt)("li",{parentName:"ul"},"\u72c0\u614b\u5207\u63db\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_OPEN_MESSAGE_READ_FRONT"))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'0548       case STATE_OPEN_MESSAGE_THROTTLE_DISPATCH_QUEUE:\n0549         {\n0550           if (cur_msg_size) {\n0551             if (!dispatch_queue->dispatch_throttler.get_or_fail(cur_msg_size)) {\n0552               ldout(async_msgr->cct, 10) << __func__ << " wants " << cur_msg_size << " bytes from dispatch throttle "\n0553                                          << dispatch_queue->dispatch_throttler.get_current() << "/"\n0554                                          << dispatch_queue->dispatch_throttler.get_max() << " failed, just wait." << dendl;\n0555               // following thread pool deal with th full message queue isn\'t a\n0556               // short time, so we can wait a ms.\n0557               if (register_time_events.empty())\n0558                 register_time_events.insert(center->create_time_event(1000, wakeup_handler));\n0559               break;\n0560             }\n0561           }\n0562\n0563           throttle_stamp = ceph_clock_now();\n0564           state = STATE_OPEN_MESSAGE_READ_FRONT;\n0565           break;\n0566         }\n')),(0,_.kt)("h2",{id:"state_open_message_read_front"},"STATE_OPEN_MESSAGE_READ_FRONT"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u63a5\u4e0b\u4f86\u5c31\u662f\u958b\u59cb\u8b80\u53d6\u771f\u6b63\u7684\u5c01\u5305\u8cc7\u6599\u4e86\uff0c\u4e3b\u8981\u662f\u5206\u6210\u4e09\u500b\u90e8\u5206",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"front"),(0,_.kt)("li",{parentName:"ul"},"middle"),(0,_.kt)("li",{parentName:"ul"},"data"))),(0,_.kt)("li",{parentName:"ul"},"\u8b80\u53d6\u524d\u6bb5\u8cc7\u6599\uff0c\u5c07\u5167\u5bb9\u5148\u653e\u5230\u672c\u8eab\u7684 front \u8b8a\u6578\u4e2d"),(0,_.kt)("li",{parentName:"ul"},"\u5c07\u72c0\u614b\u5207\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_OPEN_MESSAGE_READ_MIDDLE"))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-C++"},'0568       case STATE_OPEN_MESSAGE_READ_FRONT:\n0569         {\n0570           // read front\n0571           unsigned front_len = current_header.front_len;\n0572           if (front_len) {\n0573             if (!front.length())\n0574               front.push_back(buffer::create(front_len));\n0575\n0576             r = read_until(front_len, front.c_str());\n0577             if (r < 0) {\n0578               ldout(async_msgr->cct, 1) << __func__ << " read message front failed" << dendl;\n0579               goto fail;\n0580             } else if (r > 0) {\n0581               break;\n0582             }\n0583\n0584             ldout(async_msgr->cct, 20) << __func__ << " got front " << front.length() << dendl;\n0585           }\n0586           state = STATE_OPEN_MESSAGE_READ_MIDDLE;\n0587         }\n')),(0,_.kt)("h2",{id:"state_open_message_read_middle"},"STATE_OPEN_MESSAGE_READ_MIDDLE"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u8b80\u53d6\u4e2d\u6bb5\u8cc7\u6599\uff0c\u5c07\u5167\u5bb9\u5148\u653e\u5230\u672c\u8eab\u7684 middle \u8b8a\u6578\u4e2d"),(0,_.kt)("li",{parentName:"ul"},"\u5c07\u72c0\u614b\u5207\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_OPEN_MESSAGE_READ_DATA_PREPARE"))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-C++"},'0589       case STATE_OPEN_MESSAGE_READ_MIDDLE:\n0590         {\n0591           // read middle\n0592           unsigned middle_len = current_header.middle_len;\n0593           if (middle_len) {\n0594             if (!middle.length())\n0595               middle.push_back(buffer::create(middle_len));\n0596\n0597             r = read_until(middle_len, middle.c_str());\n0598             if (r < 0) {\n0599               ldout(async_msgr->cct, 1) << __func__ << " read message middle failed" << dendl;\n0600               goto fail;\n0601             } else if (r > 0) {\n0602               break;\n0603             }\n0604             ldout(async_msgr->cct, 20) << __func__ << " got middle " << middle.length() << dendl;\n0605           }\n0606\n0607           state = STATE_OPEN_MESSAGE_READ_DATA_PREPARE;\n0608         }\n')),(0,_.kt)("h2",{id:"state_open_message_read_data_prepare"},"STATE_OPEN_MESSAGE_READ_DATA_PREPARE"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u6e96\u5099\u597d buffer \u4f9b\u4e4b\u5f8c\u8b80\u53d6 data \u7528\uff0c\u5176\u4e2d data \u90e8\u5206\u9664\u4e86\u9577\u5ea6\u5916\uff0c\u9084\u6709 ",(0,_.kt)("strong",{parentName:"li"},"offset")," \u4e5f\u8981\u8655\u7406"),(0,_.kt)("li",{parentName:"ul"},"\u9019\u908a\u9084\u4e0d\u6703\u8b80\u53d6\u8cc7\u6599\uff0c\u53ea\u662f\u6703\u6839\u64da\u8b80\u51fa\u4f86\u7684\u7a7a\u9593\u9577\u5ea6\u9810\u5148\u914d\u7f6e\u4e00\u500b\u7a7a\u9593\u4f9b\u4e4b\u5f8c\u8b80\u53d6\u8cc7\u6599\u4f7f\u7528"),(0,_.kt)("li",{parentName:"ul"},"\u5c07\u72c0\u614b\u5207\u6210 STATE_OPEN_MESSAGE_READ_DATA")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-C++"},'0610       case STATE_OPEN_MESSAGE_READ_DATA_PREPARE:\n0611         {\n0612           // read data\n0613           unsigned data_len = le32_to_cpu(current_header.data_len);\n0614           unsigned data_off = le32_to_cpu(current_header.data_off);\n0615           if (data_len) {\n0616             // get a buffer\n0617             map<ceph_tid_t,pair<bufferlist,int> >::iterator p = rx_buffers.find(current_header.tid);\n0618             if (p != rx_buffers.end()) {\n0619               ldout(async_msgr->cct,10) << __func__ << " seleting rx buffer v " << p->second.second\n0620                                   << " at offset " << data_off\n0621                                   << " len " << p->second.first.length() << dendl;\n0622               data_buf = p->second.first;\n0623               // make sure it\'s big enough\n0624               if (data_buf.length() < data_len)\n0625                 data_buf.push_back(buffer::create(data_len - data_buf.length()));\n0626               data_blp = data_buf.begin();\n0627             } else {\n0628               ldout(async_msgr->cct,20) << __func__ << " allocating new rx buffer at offset " << data_off << dendl;\n0629               alloc_aligned_buffer(data_buf, data_len, data_off);\n0630               data_blp = data_buf.begin();\n0631             }\n0632           }\n0633\n0634           msg_left = data_len;\n0635           state = STATE_OPEN_MESSAGE_READ_DATA;\n0636         }\n')),(0,_.kt)("h2",{id:"state_open_message_read_data"},"STATE_OPEN_MESSAGE_READ_DATA"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u900f\u904e\u4e00\u500b\u8ff4\u5708\u5617\u8a66\u5c07\u8cc7\u6599\u8b80\u53d6\u51fa\u4f86\u4e26\u4e14\u653e\u5230\u4e4b\u524d\u6240\u9810\u5148\u914d\u7f6e\u7684\u7a7a\u9593 ",(0,_.kt)("strong",{parentName:"li"},"DATA")),(0,_.kt)("li",{parentName:"ul"},"\u6700\u5f8c\u72c0\u614b\u5207\u63db\u5230 ",(0,_.kt)("strong",{parentName:"li"},"STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH"))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'0638       case STATE_OPEN_MESSAGE_READ_DATA:\n0639         {\n0640           while (msg_left > 0) {\n0641             bufferptr bp = data_blp.get_current_ptr();\n0642             unsigned read = MIN(bp.length(), msg_left);\n0643             r = read_until(read, bp.c_str());\n0644             if (r < 0) {\n0645               ldout(async_msgr->cct, 1) << __func__ << " read data error " << dendl;\n0646               goto fail;\n0647             } else if (r > 0) {\n0648               break;\n0649             }\n0650\n0651             data_blp.advance(read);\n0652             data.append(bp, 0, read);\n0653             msg_left -= read;\n0654           }\n0655\n0656           if (msg_left > 0)\n0657             break;\n0658\n0659           state = STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH;\n0660         }\n0661\n')),(0,_.kt)("h2",{id:"state_open_message_read_footer_and_dispatch"},"STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u9019\u500b function \u6bd4\u8f03\u9577\uff0c\u4e0d\u904e\u53ef\u4ee5\u8aaa\u662f\u6700\u5f8c\u4e00\u6b65\u9a5f\u4e86\u3002"),(0,_.kt)("li",{parentName:"ul"},"\u8ddf header \u4e00\u6a23\uff0c\u6839\u64da ",(0,_.kt)("strong",{parentName:"li"},"feature")," \u6c7a\u5b9a\u4f7f\u7528\u65b0\u820a\u7248\u672c\u7684 ",(0,_.kt)("strong",{parentName:"li"},"footer")," \u683c\u5f0f"),(0,_.kt)("li",{parentName:"ul"},"\u8b80\u53d6 footer \u7684\u8cc7\u6599\uff0c\u5982\u5404\u5340\u6bb5\u7684CRC\u7b49"),(0,_.kt)("li",{parentName:"ul"},"\u900f\u904e decode_message \u6b64 function\uff0c\u5c07\u6536\u96c6\u5230\u7684 (front, middle, data, footer.etc) \u7d44\u5408\u6210\u4e00\u500b\u5b8c\u6574\u7684 ",(0,_.kt)("strong",{parentName:"li"},"message")," \u683c\u5f0f\u7684\u5c01\u5305")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},"0270 Message *decode_message(CephContext *cct, int crcflags,\n0271                         ceph_msg_header& header,\n0272                         ceph_msg_footer& footer,\n0273                         bufferlist& front, bufferlist& middle,\n0274                         bufferlist& data)\n....\n0315   // make message\n0316   Message *m = 0;\n0317   int type = header.type;\n0318   switch (type) {\n0319\n0320     // -- with payload --\n0321\n0322   case MSG_PGSTATS:\n0323     m = new MPGStats;\n0324     break;\n0325   case MSG_PGSTATSACK:\n0326     m = new MPGStatsAck;\n0327     break;\n0328\n0329   case CEPH_MSG_STATFS:\n0330     m = new MStatfs;\n0331     break;\n0332   case CEPH_MSG_STATFS_REPLY:\n0333     m = new MStatfsReply;\n0334     break;\n0335   case MSG_GETPOOLSTATS:\n0336     m = new MGetPoolStats;\n0337     break;\n0338   case MSG_GETPOOLSTATSREPLY:\n0339     m = new MGetPoolStatsReply;\n...\n")),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u91dd\u5c0d\u8a72 message \u8a2d\u5b9a\u4e00\u4e9b\u76f8\u95dc\u5c6c\u6027",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"byte_throttler"),(0,_.kt)("li",{parentName:"ul"},"message_throttler"),(0,_.kt)("li",{parentName:"ul"},"dispatch_throttle_size"),(0,_.kt)("li",{parentName:"ul"},"recv_stamp"),(0,_.kt)("li",{parentName:"ul"},"throttle_stamp"),(0,_.kt)("li",{parentName:"ul"},"recv_complete_stamp"))),(0,_.kt)("li",{parentName:"ul"},"\u91dd\u5c0d sequence \u9032\u884c\u4e00\u4e9b\u5224\u65b7\uff0c\u7576\u524d\u7684 message \u53ef\u80fd\u4e2d\u9593\u6709\u907a\u6f0f\uff0c\u6216\u662f\u5f88\u4e45\u4ee5\u524d\u7684 message"),(0,_.kt)("li",{parentName:"ul"},"\u5c07\u8a72 messaged \u7684 sequence \u7576\u4f5c\u76ee\u524d\u6700\u5f8c\u4e00\u500b\u6536\u5230 sequence")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},"0765           // note last received message.\n0766           in_seq.set(message->get_seq());\n")),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u5c07\u72c0\u614b\u6539\u6210 STATE_OPEN"),(0,_.kt)("li",{parentName:"ul"},"\u5c07\u672c\u8a0a\u606f\u585e\u5165\u5230 dispatch_queue \u5167\uff0c\u4f9b\u61c9\u7528\u5c64\u53bb\u8655\u7406"),(0,_.kt)("li",{parentName:"ul"},"\u5230\u9019\u908a\u5c31\u7d50\u675f\u4e86\uff0c\u63a5\u4e0b\u4f86 ",(0,_.kt)("strong",{parentName:"li"},"AsyncManager")," \u53bb\u5b9a\u671f\u53bb\u6aa2\u67e5 ",(0,_.kt)("strong",{parentName:"li"},"dispatch_queue"),"\uff0c\u7576\u6709\u5c01\u5305\u9032\u4f86\u5f8c\uff0c\u5c31\u6703\u5c07\u8a72\u5c01\u5305\u9001\u7d66\u6240\u6709\u8a3b\u518a\u7684 ",(0,_.kt)("strong",{parentName:"li"},"Dispatcher")," \u53bb\u8655\u7406\u3002")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'0662       case STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH:\n0663         {\n0664           ceph_msg_footer footer;\n0665           ceph_msg_footer_old old_footer;\n0666           unsigned len;\n0667           // footer\n0668           if (has_feature(CEPH_FEATURE_MSG_AUTH))\n0669             len = sizeof(footer);\n0670           else\n0671             len = sizeof(old_footer);\n0672\n0673           r = read_until(len, state_buffer);\n0674           if (r < 0) {\n0675             ldout(async_msgr->cct, 1) << __func__ << " read footer data error " << dendl;\n0676             goto fail;\n0677           } else if (r > 0) {\n0678             break;\n0679           }\n0680\n0681           if (has_feature(CEPH_FEATURE_MSG_AUTH)) {\n0682             footer = *((ceph_msg_footer*)state_buffer);\n0683           } else {\n0684             old_footer = *((ceph_msg_footer_old*)state_buffer);\n0685             footer.front_crc = old_footer.front_crc;\n0686             footer.middle_crc = old_footer.middle_crc;\n0687             footer.data_crc = old_footer.data_crc;\n0688             footer.sig = 0;\n0689             footer.flags = old_footer.flags;\n0690           }\n0691           int aborted = (footer.flags & CEPH_MSG_FOOTER_COMPLETE) == 0;\n0692           ldout(async_msgr->cct, 10) << __func__ << " aborted = " << aborted << dendl;\n0693           if (aborted) {\n0694             ldout(async_msgr->cct, 0) << __func__ << " got " << front.length() << " + " << middle.length() << " + " << data.length()\n0695                                 << " byte message.. ABORTED" << dendl;\n0696             goto fail;\n0697           }\n0698\n0699           ldout(async_msgr->cct, 20) << __func__ << " got " << front.length() << " + " << middle.length()\n0700                               << " + " << data.length() << " byte message" << dendl;\n0701           Message *message = decode_message(async_msgr->cct, async_msgr->crcflags, current_header, footer,\n0702                                             front, middle, data, this);\n0703           if (!message) {\n0704             ldout(async_msgr->cct, 1) << __func__ << " decode message failed " << dendl;\n0705             goto fail;\n0706           }\n0707\n0708           //\n0709           //  Check the signature if one should be present.  A zero return indicates success. PLR\n0710           //\n0711\n0712           if (session_security.get() == NULL) {\n0713             ldout(async_msgr->cct, 10) << __func__ << " no session security set" << dendl;\n0714           } else {\n0715             if (session_security->check_message_signature(message)) {\n0716               ldout(async_msgr->cct, 0) << __func__ << " Signature check failed" << dendl;\n0717               message->put();\n0718               goto fail;\n0719             }\n0720           }\n0721           message->set_byte_throttler(policy.throttler_bytes);\n0722           message->set_message_throttler(policy.throttler_messages);\n0723\n0724           // store reservation size in message, so we don\'t get confused\n0725           // by messages entering the dispatch queue through other paths.\n0726           message->set_dispatch_throttle_size(cur_msg_size);\n0727\n0728           message->set_recv_stamp(recv_stamp);\n0729           message->set_throttle_stamp(throttle_stamp);\n0730           message->set_recv_complete_stamp(ceph_clock_now());\n0731\n0732           // check received seq#.  if it is old, drop the message.\n0733           // note that incoming messages may skip ahead.  this is convenient for the client\n0734           // side queueing because messages can\'t be renumbered, but the (kernel) client will\n0735           // occasionally pull a message out of the sent queue to send elsewhere.  in that case\n0736           // it doesn\'t matter if we "got" it or not.\n0737           uint64_t cur_seq = in_seq.read();\n0738           if (message->get_seq() <= cur_seq) {\n0739             ldout(async_msgr->cct,0) << __func__ << " got old message "\n0740                     << message->get_seq() << " <= " << cur_seq << " " << message << " " << *message\n0741                     << ", discarding" << dendl;\n0742             message->put();\n0743             if (has_feature(CEPH_FEATURE_RECONNECT_SEQ) && async_msgr->cct->_conf->ms_die_on_old_message)\n0744               assert(0 == "old msgs despite reconnect_seq feature");\n0745             break;\n0746           }\n0747           if (message->get_seq() > cur_seq + 1) {\n0748             ldout(async_msgr->cct, 0) << __func__ << " missed message?  skipped from seq "\n0749                                       << cur_seq << " to " << message->get_seq() << dendl;\n0750             if (async_msgr->cct->_conf->ms_die_on_skipped_message)\n0751               assert(0 == "skipped incoming seq");\n0752           }\n0753\n0754           message->set_connection(this);\n0755\n0756 #if defined(WITH_LTTNG) && defined(WITH_EVENTTRACE)\n0757           if (message->get_type() == CEPH_MSG_OSD_OP || message->get_type() == CEPH_MSG_OSD_OPREPLY) {\n0758             utime_t ltt_processed_stamp = ceph_clock_now();\n0759             double usecs_elapsed = (ltt_processed_stamp.to_nsec()-ltt_recv_stamp.to_nsec())/1000;\n0760             ostringstream buf;\n0761             if (message->get_type() == CEPH_MSG_OSD_OP)\n0762               OID_ELAPSED_WITH_MSG(message, usecs_elapsed, "TIME_TO_DECODE_OSD_OP", false);\n0763             else\n0764               OID_ELAPSED_WITH_MSG(message, usecs_elapsed, "TIME_TO_DECODE_OSD_OPREPLY", false);\n0765           }\n0766 #endif\n0767\n0768           // note last received message.\n0769           in_seq.set(message->get_seq());\n0770           ldout(async_msgr->cct, 5) << " rx " << message->get_source() << " seq "\n0771                                     << message->get_seq() << " " << message\n0772                                     << " " << *message << dendl;\n0773\n0774           if (!policy.lossy) {\n0775             ack_left.inc();\n0776             need_dispatch_writer = true;\n0777           }\n0778           state = STATE_OPEN;\n0779\n0780           logger->inc(l_msgr_recv_messages);\n0781           logger->inc(l_msgr_recv_bytes, cur_msg_size + sizeof(ceph_msg_header) + sizeof(ceph_msg_footer));\n0782\n0783           async_msgr->ms_fast_preprocess(message);\n0784           if (delay_state) {\n0785             utime_t release = message->get_recv_stamp();\n0786             double delay_period = 0;\n0787             if (rand() % 10000 < async_msgr->cct->_conf->ms_inject_delay_probability * 10000.0) {\n0788               delay_period = async_msgr->cct->_conf->ms_inject_delay_max * (double)(rand() % 10000) / 10000.0;\n0789               release += delay_period;\n0790               ldout(async_msgr->cct, 1) << "queue_received will delay until " << release << " on "\n0791                                         << message << " " << *message << dendl;\n0792             }\n0793             delay_state->queue(delay_period, release, message);\n0794           } else if (async_msgr->ms_can_fast_dispatch(message)) {\n0795             lock.unlock();\n0796             dispatch_queue->fast_dispatch(message);\n0797             lock.lock();\n0798           } else {\n0799             dispatch_queue->enqueue(message, message->get_priority(), conn_id);\n0800           }\n0801\n0802           break;\n0803         }\n0804\n')),(0,_.kt)("p",null,"\u4e0a\u8ff0\u5df2\u7d93\u5927\u6982\u8dd1\u5b8c\u4e86\u6574\u500b ",(0,_.kt)("strong",{parentName:"p"},"Accept")," \u7684\u6d41\u7a0b\uff0c\u7576\u7136\u6b64\u6d41\u7a0b\u4e2d\u662f\u78ba\u4fdd\u6c92\u6709\u4efb\u4f55\u932f\u8aa4\uff0c\u4e00\u5207\u90fd\u662f\u9806\u5229\u5f80\u4e0b\u9032\u884c\u7684\u3002\n\u63a5\u4e0b\u4f86\u4f86\u63a2\u8a0e\u82e5 ",(0,_.kt)("strong",{parentName:"p"},"Client")," \u60f3\u8981\u9023\u7dda\uff0c\u5247\u6703\u600e\u9ebc\u8655\u7406\u3002"),(0,_.kt)("h1",{id:"connect"},"Connect"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u7576 AsyncMessager \u5275\u7acb AsyncConnection\u6642\uff0c\u5c31\u6703\u5148\u547c\u53eb\u6b64 function \u9032\u884c\u9023\u7dda\u4e86\uff0c\u5f8c\u7e8c\u82e5\u6709\u8a0a\u606f\u767c\u9001\u6642\uff0c\u6703\u900f\u904e ",(0,_.kt)("inlineCode",{parentName:"li"},"_connect"),"\u91cd\u65b0\u9023\u7dda\u3002"),(0,_.kt)("li",{parentName:"ul"},"\u8a2d\u5b9a peer \u7684 addr\u4ee5\u53ca policy"),(0,_.kt)("li",{parentName:"ul"},"\u547c\u53eb _connect \u5b8c\u6210\u6700\u5f8c\u7684\u9023\u7dda\u6b65\u9a5f")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},"0200   void connect(const entity_addr_t& addr, int type) {\n0201     set_peer_type(type);\n0202     set_peer_addr(addr);\n0203     policy = msgr->get_policy(type);\n0204     _connect();\n0205   }\n")),(0,_.kt)("h1",{id:"_connect"},"_connect"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u5c07\u72c0\u614b\u8a2d\u5b9a\u70ba ",(0,_.kt)("strong",{parentName:"li"},"STATE_CONNECTING"),"\uff0c\u63a5\u4e0b\u4f86\u5c31\u5c07 ",(0,_.kt)("strong",{parentName:"li"},"read_handler")," \u9001\u7d66 ",(0,_.kt)("strong",{parentName:"li"},"Event Engine"),"\u53bb\u8655\u7406\uff0c\u7531\u65bc\u662f\u900f\u904e ",(0,_.kt)("strong",{parentName:"li"},"external event"),"\uff0c\u6240\u4ee5\u5247\u6703\u99ac\u4e0a\u57f7\u884c ",(0,_.kt)("strong",{parentName:"li"},"read_handler"),"\uff0c\u4e5f\u5c31\u662f ",(0,_.kt)("strong",{parentName:"li"},"process"),"\u3002")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'1856 void AsyncConnection::_connect()\n1857 {\n1858   ldout(async_msgr->cct, 10) << __func__ << " csq=" << connect_seq << dendl;\n1859\n1860   state = STATE_CONNECTING;\n1861   // rescheduler connection in order to avoid lock dep\n1862   // may called by external thread(send_message)\n1863   center->dispatch_event_external(read_handler);\n1864 }\n')),(0,_.kt)("h2",{id:"state_connecting"},"STATE_CONNECTING"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u6aa2\u67e5 cs \u6b64\u8b8a\u6578\uff0c\u5982\u679c\u4e4b\u524d\u6709\u9023\u7dda\u904e\uff0c\u5247\u95dc\u9589\u5148\u524d\u7684\u9023\u7dda",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"\u540c\u6642\u4e5f\u5148\u522a\u9664\u4e4b\u524d\u7684 event"))),(0,_.kt)("li",{parentName:"ul"},"\u547c\u53eb worker \u8ddf\u5c0d\u65b9\u7684 socket \u53bb\u9023\u7dda"),(0,_.kt)("li",{parentName:"ul"},"\u5275\u9020\u4e00\u500b read_handler \u7684 event\uff0c\u4f86\u8655\u7406\u63a5\u4e0b\u4f86\u6536\u5230\u5c01\u5305\u7684\u884c\u70ba",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"read_handler \u5c31\u662f process"))),(0,_.kt)("li",{parentName:"ul"},"\u72c0\u614b\u5207\u63db\u6210 STATE_CONNECTING_RE")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},"0870     case STATE_CONNECTING:\n0871       {\n0872         assert(!policy.server);\n0873\n0874         // reset connect state variables\n0875         got_bad_auth = false;\n0876         delete authorizer;\n0877         authorizer = NULL;\n0878         authorizer_buf.clear();\n0879         memset(&connect_msg, 0, sizeof(connect_msg));\n0880         memset(&connect_reply, 0, sizeof(connect_reply));\n0881\n0882         global_seq = async_msgr->get_global_seq();\n0883         // close old socket.  this is safe because we stopped the reader thread above.\n0884         if (cs) {\n0885           center->delete_file_event(cs.fd(), EVENT_READABLE|EVENT_WRITABLE);\n0886           cs.close();\n0887         }\n0888\n0889         SocketOptions opts;\n0890         opts.priority = async_msgr->get_socket_priority();\n0891         opts.connect_bind_addr = msgr->get_myaddr();\n0892         r = worker->connect(get_peer_addr(), opts, &cs);\n0893         if (r < 0)\n0894           goto fail;\n0895\n0896         center->create_file_event(cs.fd(), EVENT_READABLE, read_handler);\n0897         state = STATE_CONNECTING_RE;\n0898         break;\n0899       }\n\n")),(0,_.kt)("h2",{id:"state_connecting_re"},"STATE_CONNECTING_RE"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u6aa2\u67e5\u7576\u524d connectionSocket \u9023\u7dda\u72c0\u614b\uff0c\u672c\u8eab\u82e5\u767c\u73fe\u6c92\u6709\u9023\u7dda\u5247\u6703\u81ea\u5df1\u91cd\u65b0\u9023\u7dda",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"r < 0, \u9023\u7dda\u4f9d\u7136\u5931\u6557\uff0c\u5247\u5224\u5b9a\u6709\u554f\u984c\uff0c goto \u96e2\u958b"),(0,_.kt)("li",{parentName:"ul"},"r == 1, \u6210\u529f\uff0c\u4e0d\u505a\u4e8b\u60c5"),(0,_.kt)("li",{parentName:"ul"},"r == 0, \u91cd\u9023\u904e\u7a0b\u4e2d\u6709\u51fa\u73fe\u932f\u8aa4\uff0c\u53ef\u80fd\u662f EINPROGRESS  \u6216\u662f EALREADY\u3002"))),(0,_.kt)("li",{parentName:"ul"},"\u5617\u8a66\u9001\u51fa CEPH_BANNER"),(0,_.kt)("li",{parentName:"ul"},"\u82e5\u6210\u529f\uff0c\u72c0\u614b\u5207\u63db\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_CONNECTING_WAIT_BANNER_AND_IDENTIFY")),(0,_.kt)("li",{parentName:"ul"},"\u82e5\u5931\u6557\uff0c\u72c0\u614b\u5207\u63db\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_WAIT_SEND"),"\uff0c\u5f85\u4e4b\u5f8c\u91cd\u9001\u5f8c\u518d\u8655\u7406\u3002")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},"0055   int is_connected() override {\n0056     if (connected)\n0057       return 1;\n0058\n0059     int r = handler.reconnect(sa, _fd);\n0060     if (r == 0) {\n0061       connected = true;\n0062       return 1;\n0063     } else if (r < 0) {\n0064       return r;\n0065     } else {\n0066       return 0;\n0067     }\n0068   }\n")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'0901     case STATE_CONNECTING_RE:\n0902       {\n0903         r = cs.is_connected();\n0904         if (r < 0) {\n0905           ldout(async_msgr->cct, 1) << __func__ << " reconnect failed " << dendl;\n0906           if (r == -ECONNREFUSED) {\n0907             ldout(async_msgr->cct, 2) << __func__ << " connection refused!" << dendl;\n0908             dispatch_queue->queue_refused(this);\n0909           }\n0910           goto fail;\n0911         } else if (r == 0) {\n0912           ldout(async_msgr->cct, 10) << __func__ << " nonblock connect inprogress" << dendl;\n0913           if (async_msgr->get_stack()->nonblock_connect_need_writable_event())\n0914             center->create_file_event(cs.fd(), EVENT_WRITABLE, read_handler);\n0915           break;\n0916         }\n0917\n0918         center->delete_file_event(cs.fd(), EVENT_WRITABLE);\n0919         ldout(async_msgr->cct, 10) << __func__ << " connect successfully, ready to send banner" << dendl;\n0920\n0921         bufferlist bl;\n0922         bl.append(CEPH_BANNER, strlen(CEPH_BANNER));\n0923         r = try_send(bl);\n0924         if (r == 0) {\n0925           state = STATE_CONNECTING_WAIT_BANNER_AND_IDENTIFY;\n0926           ldout(async_msgr->cct, 10) << __func__ << " connect write banner done: "\n0927                                      << get_peer_addr() << dendl;\n0928         } else if (r > 0) {\n0929           state = STATE_WAIT_SEND;\n0930           state_after_send = STATE_CONNECTING_WAIT_BANNER_AND_IDENTIFY;\n0931           ldout(async_msgr->cct, 10) << __func__ << " connect wait for write banner: "\n0932                                << get_peer_addr() << dendl;\n0933         } else {\n0934           goto fail;\n0935         }\n0936\n0937         break;\n0938       }\n0223 }\n')),(0,_.kt)("h2",{id:"state_connecting_wait_banner_and_identify"},"STATE_CONNECTING_WAIT_BANNER_AND_IDENTIFY"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u8b80\u53d6 SERVER \u7aef\u9001\u4f86\u7684\u8cc7\u8a0a",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"CEPH_BANNER"),(0,_.kt)("li",{parentName:"ul"},"Address (Server\u672c\u8eab\uff0c\u4ee5\u53caServer\u770b\u5230\u7684 Client)\uff0c\u6240\u4ee5\u6709\u5169\u4efd\u3002"))),(0,_.kt)("li",{parentName:"ul"},"\u6bd4\u8f03\u5169\u908a\u7684 CEPH_BANNER"),(0,_.kt)("li",{parentName:"ul"},"\u6bd4\u8f03 peer addr (server address)",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"\u6211\u81ea\u5df1 socket \u770b\u5230\u7684"),(0,_.kt)("li",{parentName:"ul"},"\u5c0d\u65b9\u9001\u904e\u4f86\u7684"))),(0,_.kt)("li",{parentName:"ul"},"\u5c07\u81ea\u5df1\u7684 address \u9001\u7d66 server"),(0,_.kt)("li",{parentName:"ul"},"\u82e5\u6210\u529f\uff0c\u5c07\u72c0\u614b\u5207\u63db\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_CONNECTING_SEND_CONNECT_MSG")),(0,_.kt)("li",{parentName:"ul"},"\u82e5\u5931\u6557\uff0c\u5c07\u72c0\u614b\u5207\u63db\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_WAIT_SEND"),"\uff0c\u4e4b\u5f8c\u518d\u8655\u7406\u3002")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'0940     case STATE_CONNECTING_WAIT_BANNER_AND_IDENTIFY:\n0941       {\n0942         entity_addr_t paddr, peer_addr_for_me;\n0943         bufferlist myaddrbl;\n0944         unsigned banner_len = strlen(CEPH_BANNER);\n0945         unsigned need_len = banner_len + sizeof(ceph_entity_addr)*2;\n0946         r = read_until(need_len, state_buffer);\n0947         if (r < 0) {\n0948           ldout(async_msgr->cct, 1) << __func__ << " read banner and identify addresses failed" << dendl;\n0949           goto fail;\n0950         } else if (r > 0) {\n0951           break;\n0952         }\n0953\n0954         if (memcmp(state_buffer, CEPH_BANNER, banner_len)) {\n0955           ldout(async_msgr->cct, 0) << __func__ << " connect protocol error (bad banner) on peer "\n0956                                     << get_peer_addr() << dendl;\n0957           goto fail;\n0958         }\n0959\n0960         bufferlist bl;\n0961         bl.append(state_buffer+banner_len, sizeof(ceph_entity_addr)*2);\n0962         bufferlist::iterator p = bl.begin();\n0963         try {\n0964           ::decode(paddr, p);\n0965           ::decode(peer_addr_for_me, p);\n0966         } catch (const buffer::error& e) {\n0967           lderr(async_msgr->cct) << __func__ <<  " decode peer addr failed " << dendl;\n0968           goto fail;\n0969         }\n0970         ldout(async_msgr->cct, 20) << __func__ <<  " connect read peer addr "\n0971                              << paddr << " on socket " << cs.fd() << dendl;\n0972         if (peer_addr != paddr) {\n0973           if (paddr.is_blank_ip() && peer_addr.get_port() == paddr.get_port() &&\n0974               peer_addr.get_nonce() == paddr.get_nonce()) {\n0975             ldout(async_msgr->cct, 0) << __func__ <<  " connect claims to be " << paddr\n0976                                 << " not " << peer_addr\n0977                                 << " - presumably this is the same node!" << dendl;\n0978           } else {\n0979             ldout(async_msgr->cct, 0) << __func__ << " connect claims to be "\n0980                                 << paddr << " not " << peer_addr << " - wrong node!" << dendl;\n0981             goto fail;\n0982           }\n0983         }\n0984\n0985         ldout(async_msgr->cct, 20) << __func__ << " connect peer addr for me is " << peer_addr_for_me << dendl;\n0986         lock.unlock();\n0987         async_msgr->learned_addr(peer_addr_for_me);\n0988         if (async_msgr->cct->_conf->ms_inject_internal_delays) {\n0989           if (rand() % async_msgr->cct->_conf->ms_inject_socket_failures == 0) {\n0990             ldout(msgr->cct, 10) << __func__ << " sleep for "\n0991                                  << async_msgr->cct->_conf->ms_inject_internal_delays << dendl;\n0992             utime_t t;\n0993             t.set_from_double(async_msgr->cct->_conf->ms_inject_internal_delays);\n0994             t.sleep();\n0995           }\n0996         }\n0997\n0998         lock.lock();\n0999         if (state != STATE_CONNECTING_WAIT_BANNER_AND_IDENTIFY) {\n1000           ldout(async_msgr->cct, 1) << __func__ << " state changed while learned_addr, mark_down or "\n1001                                     << " replacing must be happened just now" << dendl;\n1002           return 0;\n1003         }\n1004\n1005         ::encode(async_msgr->get_myaddr(), myaddrbl, 0); // legacy\n1006         r = try_send(myaddrbl);\n1007         if (r == 0) {\n1008           state = STATE_CONNECTING_SEND_CONNECT_MSG;\n1009           ldout(async_msgr->cct, 10) << __func__ << " connect sent my addr "\n1010               << async_msgr->get_myaddr() << dendl;\n1011         } else if (r > 0) {\n1012           state = STATE_WAIT_SEND;\n1013           state_after_send = STATE_CONNECTING_SEND_CONNECT_MSG;\n1014           ldout(async_msgr->cct, 10) << __func__ << " connect send my addr done: "\n1015               << async_msgr->get_myaddr() << dendl;\n1016         } else {\n1017           ldout(async_msgr->cct, 2) << __func__ << " connect couldn\'t write my addr, "\n1018               << cpp_strerror(r) << dendl;\n1019           goto fail;\n1020         }\n1021\n1022         break;\n1023       }\n')),(0,_.kt)("h2",{id:"state_connecting_send_connect_msg"},"STATE_CONNECTING_SEND_CONNECT_MSG"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u8a2d\u5b9a ",(0,_.kt)("strong",{parentName:"li"},"connect_msg")," \u7684\u8cc7\u8a0a",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"\u5982\u540c\u4e4b\u524d\u6240\u8ff0\uff0c\u5305\u542b ",(0,_.kt)("strong",{parentName:"li"},"featrue"),", ",(0,_.kt)("strong",{parentName:"li"},"type"),"\u7b49\u3002"))),(0,_.kt)("li",{parentName:"ul"},"\u5c07\u8a72 ",(0,_.kt)("strong",{parentName:"li"},"connect_msg")," \u7684\u8cc7\u8a0a\u5c01\u88dd\u8d77\u4f86\u5230 ",(0,_.kt)("strong",{parentName:"li"},"bl"),"\u8b8a\u6578\u4e2d\uff0c\u900f\u904e ",(0,_.kt)("strong",{parentName:"li"},"try_send"),"\u9001\u51fa"),(0,_.kt)("li",{parentName:"ul"},"\u82e5\u6210\u529f\u5247\u5c07\u72c0\u614b\u5207\u63db\u5230 ",(0,_.kt)("strong",{parentName:"li"},"STATE_CONNECTING_WAIT_CONNECT_REPLY"))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'1025     case STATE_CONNECTING_SEND_CONNECT_MSG:\n1026       {\n1027         if (!got_bad_auth) {\n1028           delete authorizer;\n1029           authorizer = async_msgr->get_authorizer(peer_type, false);\n1030         }\n1031         bufferlist bl;\n1032\n1033         connect_msg.features = policy.features_supported;\n1034         connect_msg.host_type = async_msgr->get_myinst().name.type();\n1035         connect_msg.global_seq = global_seq;\n1036         connect_msg.connect_seq = connect_seq;\n1037         connect_msg.protocol_version = async_msgr->get_proto_version(peer_type, true);\n1038         connect_msg.authorizer_protocol = authorizer ? authorizer->protocol : 0;\n1039         connect_msg.authorizer_len = authorizer ? authorizer->bl.length() : 0;\n1040         if (authorizer)\n1041           ldout(async_msgr->cct, 10) << __func__ <<  " connect_msg.authorizer_len="\n1042                                      << connect_msg.authorizer_len << " protocol="\n1043                                      << connect_msg.authorizer_protocol << dendl;\n1044         connect_msg.flags = 0;\n1045         if (policy.lossy)\n1046           connect_msg.flags |= CEPH_MSG_CONNECT_LOSSY;  // this is fyi, actually, server decides!\n1047         bl.append((char*)&connect_msg, sizeof(connect_msg));\n1048         if (authorizer) {\n1049           bl.append(authorizer->bl.c_str(), authorizer->bl.length());\n1050         }\n1051         ldout(async_msgr->cct, 10) << __func__ << " connect sending gseq=" << global_seq << " cseq="\n1052             << connect_seq << " proto=" << connect_msg.protocol_version << dendl;\n1053\n1054         r = try_send(bl);\n1055         if (r == 0) {\n1056           state = STATE_CONNECTING_WAIT_CONNECT_REPLY;\n1057           ldout(async_msgr->cct,20) << __func__ << " connect wrote (self +) cseq, waiting for reply" << dendl;\n1058         } else if (r > 0) {\n1059           state = STATE_WAIT_SEND;\n1060           state_after_send = STATE_CONNECTING_WAIT_CONNECT_REPLY;\n1061           ldout(async_msgr->cct, 10) << __func__ << " continue send reply " << dendl;\n1062         } else {\n1063           ldout(async_msgr->cct, 2) << __func__ << " connect couldn\'t send reply "\n1064               << cpp_strerror(r) << dendl;\n1065           goto fail;\n1066         }\n1067\n1068         break;\n1069       }\n')),(0,_.kt)("h2",{id:"state_connecting_wait_connect_reply"},"STATE_CONNECTING_WAIT_CONNECT_REPLY"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u5f9e ",(0,_.kt)("strong",{parentName:"li"},"Server")," \u7aef\u8b80\u53d6\u8cc7\u6599\uff0c\u5c07\u8cc7\u6599\u653e\u5230 ",(0,_.kt)("strong",{parentName:"li"},"state_buffer"),"\uff0c\u6b64\u8cc7\u6599\u7684\u683c\u5f0f\u70ba ",(0,_.kt)("strong",{parentName:"li"},"ceph_msg_connect_reply"))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},"0110 struct ceph_msg_connect_reply {\n0111     __u8 tag;\n0112     __le64 features;     /* feature bits for this session */\n0113     __le32 global_seq;\n0114     __le32 connect_seq;\n0115     __le32 protocol_version;\n0116     __le32 authorizer_len;\n0117     __u8 flags;\n0118 } __attribute__ ((packed));\n")),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u5c07\u6b64\u8cc7\u8a0a\u8a18\u9304\u4e0b\u4f86\u5f8c\uff0c\u72c0\u614b\u5207\u63db\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_CONNECTING_WAIT_CONNECT_REPLY_AUTH"))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'1071     case STATE_CONNECTING_WAIT_CONNECT_REPLY:\n1072       {\n1073         r = read_until(sizeof(connect_reply), state_buffer);\n1074         if (r < 0) {\n1075           ldout(async_msgr->cct, 1) << __func__ << " read connect reply failed" << dendl;\n1076           goto fail;\n1077         } else if (r > 0) {\n1078           break;\n1079         }\n1080\n1081         connect_reply = *((ceph_msg_connect_reply*)state_buffer);\n1082\n1083         ldout(async_msgr->cct, 20) << __func__ << " connect got reply tag " << (int)connect_reply.tag\n1084                              << " connect_seq " << connect_reply.connect_seq << " global_seq "\n1085                              << connect_reply.global_seq << " proto " << connect_reply.protocol_version\n1086                              << " flags " << (int)connect_reply.flags << " features "\n1087                              << connect_reply.features << dendl;\n1088         state = STATE_CONNECTING_WAIT_CONNECT_REPLY_AUTH;\n1089\n1090         break;\n1091       }\n')),(0,_.kt)("h2",{id:"state_connecting_wait_connect_reply_auth"},"STATE_CONNECTING_WAIT_CONNECT_REPLY_AUTH"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u82e5\u524d\u8ff0\u56de\u50b3\u7684 ",(0,_.kt)("strong",{parentName:"li"},"ceph_msg_connect_reply")," \u6709 ",(0,_.kt)("strong",{parentName:"li"},"authorizer")," \u7684\u8cc7\u8a0a\uff0c\u5247\u9032\u884c\u984d\u5916\u8655\u7406\u3002"),(0,_.kt)("li",{parentName:"ul"},"\u6700\u5f8c\u547c\u53eb ",(0,_.kt)("inlineCode",{parentName:"li"},"handle_connect_reply")," \u9032\u884c\u8655\u7406",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"\u7406\u8ad6\u4e0a ",(0,_.kt)("strong",{parentName:"li"},"handle_connect_reply")," \u6703\u6539\u8b8a\u7576\u524d\u72c0\u614b\uff0c\u6700\u5f8c\u8b8a\u6210 ",(0,_.kt)("strong",{parentName:"li"},"STATE_CONNECTING_READY")))),(0,_.kt)("li",{parentName:"ul"},"\u4e0a\u8ff0\u8655\u7406\u5b8c\u7562\u5f8c\uff0c\u72c0\u614b\u5fc5\u9808\u8981\u6539\u8b8a\uff0c\u82e5\u6c92\u6709\u4ee3\u8868\u6709\u554f\u984c\uff0c\u76f4\u63a5 ",(0,_.kt)("strong",{parentName:"li"},"Assert"))),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre"},'1093     case STATE_CONNECTING_WAIT_CONNECT_REPLY_AUTH:\n1094       {\n1095         bufferlist authorizer_reply;\n1096         if (connect_reply.authorizer_len) {\n1097           ldout(async_msgr->cct, 10) << __func__ << " reply.authorizer_len=" << connect_reply.authorizer_len << dendl;\n1098           assert(connect_reply.authorizer_len < 4096);\n1099           r = read_until(connect_reply.authorizer_len, state_buffer);\n1100           if (r < 0) {\n1101             ldout(async_msgr->cct, 1) << __func__ << " read connect reply authorizer failed" << dendl;\n1102             goto fail;\n1103           } else if (r > 0) {\n1104             break;\n1105           }\n1106\n1107           authorizer_reply.append(state_buffer, connect_reply.authorizer_len);\n1108           bufferlist::iterator iter = authorizer_reply.begin();\n1109           if (authorizer && !authorizer->verify_reply(iter)) {\n1110             ldout(async_msgr->cct, 0) << __func__ << " failed verifying authorize reply" << dendl;\n1111             goto fail;\n1112           }\n1113         }\n1114         r = handle_connect_reply(connect_msg, connect_reply);\n1115         if (r < 0)\n1116           goto fail;\n1117\n1118         // state must be changed!\n1119         assert(state != STATE_CONNECTING_WAIT_CONNECT_REPLY_AUTH);\n1120         break;\n1121       }\n')),(0,_.kt)("h2",{id:"state_connecting_ready"},"STATE_CONNECTING_READY"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u9019\u908a\u6709\u500b\u6709\u8da3\u7684\u8a3b\u89e3 ",(0,_.kt)("strong",{parentName:"li"},"// hooray!"),"\uff0c\u4ee3\u8868\u5230\u9019\u4e00\u6b65\u9023\u7dda\u57fa\u672c\u4e0a\u5df2\u7d93\u5b8c\u6210\u4e86\uff0c\u5269\u4e0b\u6700\u5f8c\u4e00\u6b65\u9a5f\u5c31\u7d50\u675f\u4e86\u3002"),(0,_.kt)("li",{parentName:"ul"},"\u5c0d dispatch_queue \u8a2d\u5b9a\u7576\u524d connection",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"dispatch_queue \u9019\u908a\u6709\u5169\u7a2e\u985e\u578b\uff0c\u4e00\u7a2e\u662f\u5b58\u653e message\uff0c\u4e00\u7a2e\u5247\u662f Type + Connection\uff0c\u9019\u908a\u5c6c\u65bc\u7b2c\u4e8c\u7a2e"),(0,_.kt)("li",{parentName:"ul"},"\u5728 dispatch_queue \u7684 loop \u4e2d\uff0c\u6703\u91dd\u5c0d\u9019\u5169\u7a2e\u53bb\u8655\u7406\uff0c\u82e5\u662f messag \u7684\uff0c\u5247\u76f4\u63a5\u5c07\u6b64\u8a0a\u606f\u4e1f\u7d66\u6240\u6709\u8a3b\u518a\u7684 dispatcher\uff0c\u53cd\u4e4b\u5247\u6839\u64da type \u57f7\u884c\u4e0d\u540c\u7684\u4efb\u52d9"),(0,_.kt)("li",{parentName:"ul"},"\u9019\u908a\u653e\u5165\u7684\u662f D_CONNECT \u7684 event\uff0c\u6240\u4ee5\u4e4b\u5f8c\u6703\u57f7\u884c ",(0,_.kt)("inlineCode",{parentName:"li"},"ms_deliver_handle_connect")," \u9019\u652f function\u3002"),(0,_.kt)("li",{parentName:"ul"},"\u63a5\u8005\u9019\u652f function \u5247\u662f\u6703\u901a\u77e5\u6240\u6709 dispathcer \u76ee\u524d\u6709\u65b0\u7684\u9023\u7dda\u5230\u4f86\uff0c\u547c\u53eb\u5c0d\u61c9\u7684 ",(0,_.kt)("inlineCode",{parentName:"li"},"ms_handle_connect"),"\u4f86\u8655\u7406"))),(0,_.kt)("li",{parentName:"ul"},"\u547c\u53eb AsyncMessegner \u5167\u7684 ",(0,_.kt)("strong",{parentName:"li"},"ms_deliver_handle_fast_connect"),(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"fast_connect \u76f8\u5c0d\u65bc connect \u662f\u66f4\u65e9\u6703\u8655\u7406\u7684\u51fd\u5f0f\uff0c\u5e95\u5c64\u53ef\u78ba\u4fdd\u6b64 function \u4e00\u5b9a\u6703\u5728\u6709\u4efb\u4f55 message \u88ab\u8655\u7406\u524d\u5148\u547c\u53eb\u3002"))),(0,_.kt)("li",{parentName:"ul"},"\u5982\u679c\u7576\u524d queue \u5167\u6709\u8a0a\u606f\uff0c\u9019\u6642\u5019\u518d\u767c\u9001\u4e00\u500b\u5916\u90e8\u7684 write_handler\u628aqueue\u7d66\u6e05\u7a7a\u3002",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"\u53ef\u80fd\u662f\u7531\u65bc\u5148\u524d\u7684 try_send \u6c92\u6709\u6210\u529f"))),(0,_.kt)("li",{parentName:"ul"},"\u5230\u9019\u908a\u5f8c\uff0c\u9023\u7dda\u5c31\u5b8c\u6210\u4e86\uff0c\u53ef\u4ee5\u958b\u59cb\u4f9b\u61c9\u7528\u5c64\u5404\u7a2e\u767c\u9001\u8a0a\u606f\u4e86\u3002")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},"1163     case STATE_CONNECTING_READY:\n1164       {\n1165         // hooray!\n1166         peer_global_seq = connect_reply.global_seq;\n")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},'0155     while (!mqueue.empty()) {\n0156       QueueItem qitem = mqueue.dequeue();\n0157       if (!qitem.is_code())\n0158         remove_arrival(qitem.get_message());\n0159       lock.Unlock();\n0160\n0161       if (qitem.is_code()) {\n0162         if (cct->_conf->ms_inject_internal_delays &&\n0163             cct->_conf->ms_inject_delay_probability &&\n0164             (rand() % 10000)/10000.0 < cct->_conf->ms_inject_delay_probability) {\n0165           utime_t t;\n0166           t.set_from_double(cct->_conf->ms_inject_internal_delays);\n0167           ldout(cct, 1) << "DispatchQueue::entry  inject delay of " << t\n0168                         << dendl;\n0169           t.sleep();\n0170         }\n0171         switch (qitem.get_code()) {\n0172         case D_BAD_REMOTE_RESET:\n0173           msgr->ms_deliver_handle_remote_reset(qitem.get_connection());\n0174           break;\n0175         case D_CONNECT:\n0176           msgr->ms_deliver_handle_connect(qitem.get_connection());\n0177           break;\n0178         case D_ACCEPT:\n0179           msgr->ms_deliver_handle_accept(qitem.get_connection());\n0180           break;\n0181         case D_BAD_RESET:\n0182           msgr->ms_deliver_handle_reset(qitem.get_connection());\n0183           break;\n0184         case D_CONN_REFUSED:\n0185           msgr->ms_deliver_handle_refused(qitem.get_connection());\n0186           break;\n0187         default:\n0188           ceph_abort();\n0189         }\n0190       } else {\n0191         Message *m = qitem.get_message();\n0192         if (stop) {\n0193           ldout(cct,10) << " stop flag set, discarding " << m << " " << *m << dendl;\n0194           m->put();\n0195         } else {\n0196           uint64_t msize = pre_dispatch(m);\n0197           msgr->ms_deliver_dispatch(m);\n0198           post_dispatch(m, msize);\n0199         }\n\n')),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},"0610   /**\n0611    * Notify each Dispatcher of a new Connection. Call\n0612    * this function whenever a new Connection is initiated or\n0613    * reconnects.\n0614    *\n0615    * @param con Pointer to the new Connection.\n0616    */\n0617   void ms_deliver_handle_connect(Connection *con) {\n0618     for (list<Dispatcher*>::iterator p = dispatchers.begin();\n0619          p != dispatchers.end();\n0620          ++p)\n0621       (*p)->ms_handle_connect(con);\n0622   }\n")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},"0110   /**\n0111    * This function will be called synchronously whenever a Connection is\n0112    * newly-created or reconnects in the Messenger, if you support fast\n0113    * dispatch. It is guaranteed to be called before any messages are\n0114    * dispatched.\n0115    *\n0116    * @param con The new Connection which has been established. You are not\n0117    * granted a reference to it -- take one if you need one!\n0118    */\n0119   virtual void ms_handle_fast_connect(Connection *con) {}\n")),(0,_.kt)("p",null,"\u4e0a\u8ff0\u5728 ",(0,_.kt)("strong",{parentName:"p"},"Accpeting")," \u6216\u8005\u662f ",(0,_.kt)("strong",{parentName:"p"},"Connecting")," \u7684\u904e\u7a0b\u4e2d\uff0c\u6703\u900f\u904e\u4e0b\u5217\u5169\u500b\u65b9\u5f0f\u505a\u4e00\u4e9b\u6df1\u5c64\u7684\u8655\u7406\uff0c\u9019\u4e9b\u8655\u7406\u540c\u6642\u6703\u6539\u8b8a\u7576\u524d\u72c0\u614b\uff0c\u9019\u908a\u5c31\u7c21\u55ae\u5927\u81f4\u4e0a\u770b\u904e\u800c\u5df2\u3002"),(0,_.kt)("h2",{id:"handle_connect_reply"},"handle_connect_reply"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u6839\u64da reply \u5167\u7684 tag \u985e\u578b\u4f86\u57f7\u884c\u5404\u7a2e\u4e0d\u540c\u4e8b\u60c5, \u5927\u90e8\u5206\u90fd\u662f\u932f\u8aa4\u76f8\u95dc\u7684\u8655\u7406\uff0c\u82e5\u4e00\u5207\u90fd\u6b63\u5e38\u7684\u8a71\uff0c\u5247\u6703\u662f",(0,_.kt)("inlineCode",{parentName:"li"},"CEPH_MSGR_TAG_READY"),"\uff0c\u6b64\u6642\u6703\u5c07\u72c0\u614b\u5207\u63db\u6210 STATE_CONNECTING_READY",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"CEPH_MSGR_TAG_FEATURES"),(0,_.kt)("li",{parentName:"ul"},"CEPH_MSGR_TAG_BADPROTOVER"),(0,_.kt)("li",{parentName:"ul"},"CEPH_MSGR_TAG_BADAUTHORIZER"),(0,_.kt)("li",{parentName:"ul"},"CEPH_MSGR_TAG_RESETSESSION"),(0,_.kt)("li",{parentName:"ul"},"CEPH_MSGR_TAG_RETRY_GLOBAL"),(0,_.kt)("li",{parentName:"ul"},"CEPH_MSGR_TAG_RETRY_SESSION"),(0,_.kt)("li",{parentName:"ul"},"CEPH_MSGR_TAG_WAIT"),(0,_.kt)("li",{parentName:"ul"},"CEPH_MSGR_TAG_SEQ"),(0,_.kt)("li",{parentName:"ul"},"CEPH_MSGR_TAG_READY")))),(0,_.kt)("h2",{id:"handle_connect_msg"},"handle_connect_msg"),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u6839\u64da peer type \u53d6\u5f97\u5c0d\u61c9\u7684 proto_version\uff0c\u653e\u5230 ceph_msg_connect_reply \u7684\u8b8a\u6578\u4e2d")),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre",className:"language-c++"},"0671       case CEPH_ENTITY_TYPE_OSD: return CEPH_OSDC_PROTOCOL;\n0672       case CEPH_ENTITY_TYPE_MDS: return CEPH_MDSC_PROTOCOL;\n0673       case CEPH_ENTITY_TYPE_MON: return CEPH_MONC_PROTOCOL;\n")),(0,_.kt)("ul",null,(0,_.kt)("li",{parentName:"ul"},"\u82e5\u5169\u908a\u7684 proto_version \u4e0d\u4e00\u81f4\uff0c\u5247\u547c\u53eb ",(0,_.kt)("inlineCode",{parentName:"li"},"_reply_aceept")," \u53bb\u8655\u7406\u3002"),(0,_.kt)("li",{parentName:"ul"},"\u82e5\u5c0d\u65b9\u6709\u8981\u4f7f\u7528 cephX",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"\u6839\u64da\u4e0d\u540c\u7684 protocol type (OSD/MDS/MOM) \u9032\u884c\u4e0d\u540c\u7684\u8655\u7406"))),(0,_.kt)("li",{parentName:"ul"},"\u6aa2\u67e5\u5169\u908a\u7684 feature set \u662f\u5426\u6eff\u8db3\u5f7c\u6b64\uff0c\u82e5\u6709\u554f\u984c\u5247\u547c\u53eb ",(0,_.kt)("inlineCode",{parentName:"li"},"_reply_accept")," \u53bb\u8655\u7406"),(0,_.kt)("li",{parentName:"ul"},"\u9032\u884c\u7528\u6236\u9a57\u8b49\uff0c\u5931\u6557\u5247\u547c\u53eb ",(0,_.kt)("inlineCode",{parentName:"li"},"_reply_accept")),(0,_.kt)("li",{parentName:"ul"},"\u82e5\u4ee5\u524d peer addr \u66fe\u7d93\u6709 connection \u5b58\u5728\u904e\uff0c\u9019\u6642\u5019\u5c31\u8981\u9032\u884c\u4e00\u4e9b\u8655\u7406\uff0c\u4e3b\u8981\u7684\u8655\u7406\u90fd\u662f\u57fa\u65bc\u5169\u500b\u8b8a\u6578\u4f86\u6c7a\u5b9a\uff0cglobal_seq \u4ee5\u53ca connect_seq",(0,_.kt)("ul",{parentName:"li"},(0,_.kt)("li",{parentName:"ul"},"global_seq \u4ee3\u8868\u7684\u662f\u9019\u500bhost\u5df2\u7d93\u5efa\u7acb\u904e\u591a\u5c11\u689d connection"),(0,_.kt)("li",{parentName:"ul"},"connect_seq \u4ee3\u8868\u7684\u662f\u9019\u500b session\u5efa\u7acb\u904e\u591a\u5c11\u689d connection"))),(0,_.kt)("li",{parentName:"ul"},"\u67d0\u4e9b\u60c5\u6cc1\u4e0b\uff0c\u6703\u5617\u8a66\u6368\u68c4\u820a\u6709\u7684 connection \u4e26\u5efa\u7acb\u65b0\u7684 connection \u4f86\u4f7f\u7528"),(0,_.kt)("li",{parentName:"ul"},"\u67d0\u4e9b\u60c5\u6cc1\u5247\u662f\u6703\u7e7c\u7e8c\u4f7f\u7528\u820a\u6709\u7684 connection\uff0c\u7136\u5f8c\u628a\u4e00\u4e9b\u65b0\u7684\u8cc7\u8a0a\u8ce6\u4e88\u5230\u820a\u6709 connection \u7684\u6210\u54e1\u4e2d"),(0,_.kt)("li",{parentName:"ul"},"\u547c\u53eb accept_conn \u5c07\u9023\u7dda\u7d66\u8a18\u9304\u4e0b\u4f86\u653e\u5230 conns \u4e2d\uff0c\u4e26\u4e14\u5f9e accepting_conns \u4e2d\u79fb\u9664\uff0c"),(0,_.kt)("li",{parentName:"ul"},"\u6700\u5f8c\u5247\u5c07\u72c0\u614b\u6539\u6210 STATE_ACCEPTING_WAIT_SEQ")),(0,_.kt)("h1",{id:"summary"},"Summary"),(0,_.kt)("p",null,"\u6b64 ",(0,_.kt)("strong",{parentName:"p"},"AsyncConnection")," \u5167\u5bb9\u773e\u591a\uff0c\u76ee\u524d\u5148\u4e3b\u8981\u89c0\u5bdf\u5230\u6574\u500b\u5efa\u7acb\u9023\u7dda\u7684\u6b65\u9a5f\uff0c\u5305\u542b\u4e86 ",(0,_.kt)("strong",{parentName:"p"},"Accept")," \u4ee5\u53ca ",(0,_.kt)("strong",{parentName:"p"},"connect")," \u3002\n\u6709\u6a5f\u6703\u518d\u4f86\u628a ",(0,_.kt)("strong",{parentName:"p"},"read/write")," \u76f8\u95dc\u7684\u4ecb\u9762\u4e5f\u90fd\u770b\u4e00\u6b21\uff0c\u5230\u6642\u5019\u53ef\u4ee5\u66f4\u77ad\u89e3\u6574\u9ad4\u6536\u9001\u7684\u884c\u70ba\u3002"))}p.isMDXComponent=!0}}]);