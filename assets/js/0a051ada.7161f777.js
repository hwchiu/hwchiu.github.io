"use strict";(self.webpackChunkhwchiu=self.webpackChunkhwchiu||[]).push([[68328],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>u});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function p(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function _(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?p(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):p(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},p=Object.keys(e);for(r=0;r<p.length;r++)n=p[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(r=0;r<p.length;r++)n=p[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),v=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):_(_({},t),e)),n},l=function(e){var t=v(e.components);return r.createElement(s.Provider,{value:t},e.children)},i="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,p=e.originalType,s=e.parentName,l=a(e,["components","mdxType","originalType","parentName"]),i=v(n),d=o,u=i["".concat(s,".").concat(d)]||i[d]||c[d]||p;return n?r.createElement(u,_(_({ref:t},l),{},{components:n})):r.createElement(u,_({ref:t},l))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var p=n.length,_=new Array(p);_[0]=d;var a={};for(var s in t)hasOwnProperty.call(t,s)&&(a[s]=t[s]);a.originalType=e,a[i]="string"==typeof e?e:o,_[1]=a;for(var v=2;v<p;v++)_[v]=n[v];return r.createElement.apply(null,_)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},24501:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>_,default:()=>c,frontMatter:()=>p,metadata:()=>a,toc:()=>v});var r=n(87462),o=(n(67294),n(3905));const p={title:"OpenvSwitch - 2",date:"2013-12-09 10:03",comments:!0,tags:["SDN","Network","OpenvSwitch","SourceCode"]},_=void 0,a={unversionedId:"2013/openvswitch-source-2",id:"2013/openvswitch-source-2",title:"OpenvSwitch - 2",description:"ovs-vsctl add-port br eth1",source:"@site/docs/2013/openvswitch-source-2.md",sourceDirName:"2013",slug:"/2013/openvswitch-source-2",permalink:"/docs/2013/openvswitch-source-2",draft:!1,tags:[{label:"SDN",permalink:"/docs/tags/sdn"},{label:"Network",permalink:"/docs/tags/network"},{label:"OpenvSwitch",permalink:"/docs/tags/openv-switch"},{label:"SourceCode",permalink:"/docs/tags/source-code"}],version:"current",lastUpdatedBy:"HWC",frontMatter:{title:"OpenvSwitch - 2",date:"2013-12-09 10:03",comments:!0,tags:["SDN","Network","OpenvSwitch","SourceCode"]},sidebar:"techPost",previous:{title:"OpenvSwitch - overview",permalink:"/docs/2013/openvswitch-overview"},next:{title:"OpenvSwitch source code(3)",permalink:"/docs/2013/openvswitch-source-code3"}},s={},v=[],l={toc:v},i="wrapper";function c(e){let{components:t,...n}=e;return(0,o.kt)(i,(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"ovs-vsctl add-port br eth1\n(netlink)"),(0,o.kt)("p",null,"kernel side:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Register a generic netlink"),(0,o.kt)("li",{parentName:"ul"},"Call function when receive command by netlink from userspace (ovs-vsctl)"),(0,o.kt)("li",{parentName:"ul"},"Use the interface name to get the net_device"),(0,o.kt)("li",{parentName:"ul"},"Register the send and receive event handler.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Register generic netlink")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"static struct genl_ops dp_vport_genl_ops[] = {\n        { .cmd = OVS_VPORT_CMD_NEW,\n          .flags = GENL_ADMIN_PERM, /* Requires CAP_NET_ADMIN privilege. */\n          .policy = vport_policy,\n          .doit = ovs_vport_cmd_new\n        },\n        { .cmd = OVS_VPORT_CMD_DEL,\n          .flags = GENL_ADMIN_PERM, /* Requires CAP_NET_ADMIN privilege. */\n          .policy = vport_policy,\n          .doit = ovs_vport_cmd_del\n        },\n        { .cmd = OVS_VPORT_CMD_GET,\n          .flags = 0,               /* OK for unprivileged users. */\n          .policy = vport_policy,\n          .doit = ovs_vport_cmd_get,\n          .dumpit = ovs_vport_cmd_dump\n        },\n        { .cmd = OVS_VPORT_CMD_SET,\n          .flags = GENL_ADMIN_PERM, /* Requires CAP_NET_ADMIN privilege. */\n          .policy = vport_policy,\n          .doit = ovs_vport_cmd_set,\n        },\n};\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u5f9enetlink\u6536\u5230 ",(0,o.kt)("strong",{parentName:"li"},"OVS_VPORT_CMD_NEW"),"\u7684cmd\u6642\uff0c\u5c31\u6703\u57f7\u884c ",(0,o.kt)("strong",{parentName:"li"},"ovs_vport_cmd_new"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"static int ovs_vport_cmd_new(struct sk_buff *skb, struct genl_info *info)\n{\n        struct nlattr **a = info->attrs;\n        struct ovs_header *ovs_header = info->userhdr;\n        struct vport_parms parms;\n        struct sk_buff *reply;\n        struct vport *vport;\n        struct datapath *dp;\n        u32 port_no;\n        int err;\n\n        err = -EINVAL;\n        if (!a[OVS_VPORT_ATTR_NAME] || !a[OVS_VPORT_ATTR_TYPE] ||\n            !a[OVS_VPORT_ATTR_UPCALL_PID])\n                goto exit;\n\n        ovs_lock();\n        dp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);\n        err = -ENODEV;\n        if (!dp)\n                goto exit_unlock;\n\n        if (a[OVS_VPORT_ATTR_PORT_NO]) {\n                port_no = nla_get_u32(a[OVS_VPORT_ATTR_PORT_NO]);\n\n                err = -EFBIG;\n                if (port_no >= DP_MAX_PORTS)\n                        goto exit_unlock;\n\n                vport = ovs_vport_ovsl(dp, port_no);\n                err = -EBUSY;\n                if (vport)\n                        goto exit_unlock;\n        } else {\n                for (port_no = 1; ; port_no++) {\n                        if (port_no >= DP_MAX_PORTS) {\n                                err = -EFBIG;\n                                goto exit_unlock;\n                        }\n                        vport = ovs_vport_ovsl(dp, port_no);\n                        if (!vport)\n                                break;\n                }\n        }\n\n        parms.name = nla_data(a[OVS_VPORT_ATTR_NAME]);\n        parms.type = nla_get_u32(a[OVS_VPORT_ATTR_TYPE]);\n        parms.options = a[OVS_VPORT_ATTR_OPTIONS];\n        parms.dp = dp;\n        parms.port_no = port_no;\n        parms.upcall_portid = nla_get_u32(a[OVS_VPORT_ATTR_UPCALL_PID]);\n\n        vport = new_vport(&parms);\n        err = PTR_ERR(vport);\n        if (IS_ERR(vport))\n                goto exit_unlock;\n\n        err = 0;\n        if (a[OVS_VPORT_ATTR_STATS])\n                ovs_vport_set_stats(vport, nla_data(a[OVS_VPORT_ATTR_STATS]));\n\n        reply = ovs_vport_cmd_build_info(vport, info->snd_portid, info->snd_seq,\n                                         OVS_VPORT_CMD_NEW);\n        if (IS_ERR(reply)) {\n                err = PTR_ERR(reply);\n                ovs_dp_detach_port(vport);\n                goto exit_unlock;\n        }\n\n        ovs_notify(reply, info, &ovs_dp_vport_multicast_group);\n\nexit_unlock:\n        ovs_unlock();\nexit:\n        return err;\n}\n\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u9019\u908a\u6703\u547c\u53eb ",(0,o.kt)("strong",{parentName:"li"},"new_vport"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"/* Called with ovs_mutex. */\nstatic struct vport *new_vport(const struct vport_parms *parms)\n{\n        struct vport *vport;\n\n        vport = ovs_vport_add(parms);\n        if (!IS_ERR(vport)) {\n                struct datapath *dp = parms->dp;\n                struct hlist_head *head = vport_hash_bucket(dp, vport->port_no);\n\n                hlist_add_head_rcu(&vport->dp_hash_node, head);\n        }\n        return vport;\n}\n\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u9019\u908a\u6703\u547c\u53eb ",(0,o.kt)("strong",{parentName:"li"},"ovs_vport_add"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"\nstruct vport *ovs_vport_add(const struct vport_parms *parms)\n{\n        struct vport *vport;\n        int err = 0;\n        int i;\n\n        for (i = 0; i < ARRAY_SIZE(vport_ops_list); i++) {\n                if (vport_ops_list[i]->type == parms->type) {\n                        struct hlist_head *bucket;\n\n                        vport = vport_ops_list[i]->create(parms);\n                        if (IS_ERR(vport)) {\n                                err = PTR_ERR(vport);\n                                goto out;\n                        }\n\n                        bucket = hash_bucket(ovs_dp_get_net(vport->dp),\n                                             vport->ops->get_name(vport));\n                        hlist_add_head_rcu(&vport->hash_node, bucket);\n                        return vport;\n                }\n        }\n\n        err = -EAFNOSUPPORT;\n\nout:\n        return ERR_PTR(err);\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u9019\u908a\u6703\u57f7\u884c ",(0,o.kt)("strong",{parentName:"li"},"vport_ops_list","[i]","->create(parms)"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"/* List of statically compiled vport implementations.  Don't forget to also\n * add yours to the list at the bottom of vport.h. */\nstatic const struct vport_ops *vport_ops_list[] = {\n        &ovs_netdev_vport_ops,\n        &ovs_internal_vport_ops,\n#if IS_ENABLED(CONFIG_NET_IPGRE_DEMUX)\n        &ovs_gre_vport_ops,\n        &ovs_gre64_vport_ops,\n#endif\n        &ovs_vxlan_vport_ops,\n        &ovs_lisp_vport_ops,\n};\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u5047\u8a2d\u662f\u500bnetdev\u7684port,\u5c31\u6703\u57f7\u884c ",(0,o.kt)("strong",{parentName:"li"},"ovs_netdev_vport_ops"),"\u88e1\u9762\u7684create")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"\nconst struct vport_ops ovs_netdev_vport_ops = {\n        .type           = OVS_VPORT_TYPE_NETDEV,\n        .create         = netdev_create,\n        .destroy        = netdev_destroy,\n        .get_name       = ovs_netdev_get_name,\n        .send           = netdev_send,\n};\n\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u9019\u6642\u5019\u5c31\u6703\u57f7\u884c ",(0,o.kt)("strong",{parentName:"li"},"netdev_create"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"static struct vport *netdev_create(const struct vport_parms *parms)\n{\n        struct vport *vport;\n        struct netdev_vport *netdev_vport;\n        int err;\n\n        vport = ovs_vport_alloc(sizeof(struct netdev_vport),\n                                &ovs_netdev_vport_ops, parms);\n        if (IS_ERR(vport)) {\n                err = PTR_ERR(vport);\n                goto error;\n        }\n\n        netdev_vport = netdev_vport_priv(vport);\n\n        netdev_vport->dev = dev_get_by_name(ovs_dp_get_net(vport->dp), parms->name);\n        if (!netdev_vport->dev) {\n                err = -ENODEV;\n                goto error_free_vport;\n        }\n\n        if (netdev_vport->dev->flags & IFF_LOOPBACK ||\n            netdev_vport->dev->type != ARPHRD_ETHER ||\n            ovs_is_internal_dev(netdev_vport->dev)) {\n                err = -EINVAL;\n                goto error_put;\n        }\n\n        rtnl_lock();\n        err = netdev_master_upper_dev_link(netdev_vport->dev,\n                                           get_dpdev(vport->dp));\n        if (err)\n                goto error_unlock;\n\n        err = netdev_rx_handler_register(netdev_vport->dev, netdev_frame_hook,\n                                         vport);\n        if (err)\n                goto error_master_upper_dev_unlink;\n\n        dev_set_promiscuity(netdev_vport->dev, 1);\n        netdev_vport->dev->priv_flags |= IFF_OVS_DATAPATH;\n        rtnl_unlock();\n\n        netdev_init();\n        return vport;\n\nerror_master_upper_dev_unlink:\n        netdev_upper_dev_unlink(netdev_vport->dev, get_dpdev(vport->dp));\nerror_unlock:\n        rtnl_unlock();\nerror_put:\n        dev_put(netdev_vport->dev);\nerror_free_vport:\n        ovs_vport_free(vport);\nerror:\n        return ERR_PTR(err);\n}\n\n\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u9019\u908a\u6703\u8abf\u7528 ",(0,o.kt)("strong",{parentName:"li"}," dev_get_by_name ")," \u7528\u8a72name\u53d6\u5f97\u5c0d\u61c9\u7684device."),(0,o.kt)("li",{parentName:"ul"},"\u8abf\u7528 ",(0,o.kt)("strong",{parentName:"li"}," netdev_rx_handler_register ")," \u8a3b\u518a rx handler."),(0,o.kt)("li",{parentName:"ul"})),(0,o.kt)("p",null,"userspace side:"))}c.isMDXComponent=!0}}]);