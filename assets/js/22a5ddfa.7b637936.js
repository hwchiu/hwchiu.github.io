"use strict";(self.webpackChunkhwchiu=self.webpackChunkhwchiu||[]).push([[69148],{3905:(e,n,r)=>{r.d(n,{Zo:()=>s,kt:()=>b});var t=r(67294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function d(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?d(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):d(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function a(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},d=Object.keys(e);for(t=0;t<d.length;t++)r=d[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var d=Object.getOwnPropertySymbols(e);for(t=0;t<d.length;t++)r=d[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var _=t.createContext({}),l=function(e){var n=t.useContext(_),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},s=function(e){var n=l(e.components);return t.createElement(_.Provider,{value:n},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,d=e.originalType,_=e.parentName,s=a(e,["components","mdxType","originalType","parentName"]),p=l(r),u=i,b=p["".concat(_,".").concat(u)]||p[u]||c[u]||d;return r?t.createElement(b,o(o({ref:n},s),{},{components:r})):t.createElement(b,o({ref:n},s))}));function b(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var d=r.length,o=new Array(d);o[0]=u;var a={};for(var _ in n)hasOwnProperty.call(n,_)&&(a[_]=n[_]);a.originalType=e,a[p]="string"==typeof e?e:i,o[1]=a;for(var l=2;l<d;l++)o[l]=r[l];return t.createElement.apply(null,o)}return t.createElement.apply(null,r)}u.displayName="MDXCreateElement"},43634:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>_,contentTitle:()=>o,default:()=>c,frontMatter:()=>d,metadata:()=>a,toc:()=>l});var t=r(87462),i=(r(67294),r(3905));const d={title:"Linux Bridge MTU",authors:"hwchiu",tags:["Linux","Network"]},o=void 0,a={permalink:"/2023/10/31/linux-brideg",source:"@site/blog/2023/10-31-linux-brideg.md",title:"Linux Bridge MTU",description:"Linux Bridge \u7684 MTU \u8a2d\u5b9a\u4e0d\u5982\u4e00\u822c\u7db2\u5361\u7c21\u55ae\u8a2d\u5b9a\uff0c\u5176 MTU \u9810\u8a2d\u60c5\u6cc1\u4e0b\u6703\u81ea\u52d5\u8abf\u6574\uff0c\u6703\u81ea\u52d5\u4f7f\u7528\u6240\u6709 slave \u7db2\u5361\u4e0a\u6700\u5c0f\u7684\u503c\u4f86\u53d6\u4ee3",date:"2023-10-31T00:00:00.000Z",formattedDate:"October 31, 2023",tags:[{label:"Linux",permalink:"/tags/linux"},{label:"Network",permalink:"/tags/network"}],readingTime:2.845,hasTruncateMarker:!1,authors:[{name:"HungWei Chiu",title:"Blogger",url:"https://github.com/hwchiu",imageURL:"https://github.com/hwchiu.png",key:"hwchiu"}],frontMatter:{title:"Linux Bridge MTU",authors:"hwchiu",tags:["Linux","Network"]},nextItem:{title:"Kubevirt \u521d\u9ad4\u9a57",permalink:"/2023/10/10/kubevirt-macos"}},_={authorsImageUrls:[void 0]},l=[],s={toc:l},p="wrapper";function c(e){let{components:n,...r}=e;return(0,i.kt)(p,(0,t.Z)({},s,r,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Linux Bridge \u7684 MTU \u8a2d\u5b9a\u4e0d\u5982\u4e00\u822c\u7db2\u5361\u7c21\u55ae\u8a2d\u5b9a\uff0c\u5176 MTU \u9810\u8a2d\u60c5\u6cc1\u4e0b\u6703\u81ea\u52d5\u8abf\u6574\uff0c\u6703\u81ea\u52d5\u4f7f\u7528\u6240\u6709 slave \u7db2\u5361\u4e0a\u6700\u5c0f\u7684\u503c\u4f86\u53d6\u4ee3\n\u4ee5\u4e0b\u5217",(0,i.kt)("a",{parentName:"p",href:"https://elixir.bootlin.com/linux/latest/source/net/bridge/br_if.c#L695"},"\u7a0b\u5f0f\u78bc"),"\u4f86\u770b\uff0c\u525b\u6709\u4efb\u4f55 slave \u7db2\u5361\u52a0\u5165\u5230 bridge \u4e0a\u5f8c"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'int br_add_if(struct net_bridge *br, struct net_device *dev,\n          struct netlink_ext_ack *extack)\n{\n    struct net_bridge_port *p;\n    int err = 0;\n    unsigned br_hr, dev_hr;\n    bool changed_addr, fdb_synced = false;\n\n    /* Don\'t allow bridging non-ethernet like devices. */\n    if ((dev->flags & IFF_LOOPBACK) ||\n        dev->type != ARPHRD_ETHER || dev->addr_len != ETH_ALEN ||\n        !is_valid_ether_addr(dev->dev_addr))\n        return -EINVAL;\n\n    /* No bridging of bridges */\n    if (dev->netdev_ops->ndo_start_xmit == br_dev_xmit) {\n        NL_SET_ERR_MSG(extack,\n                   "Can not enslave a bridge to a bridge");\n        return -ELOOP;\n    }\n\n    /* Device has master upper dev */\n    if (netdev_master_upper_dev_get(dev))\n        return -EBUSY;\n\n    /* No bridging devices that dislike that (e.g. wireless) */\n    if (dev->priv_flags & IFF_DONT_BRIDGE) {\n        NL_SET_ERR_MSG(extack,\n                   "Device does not allow enslaving to a bridge");\n        return -EOPNOTSUPP;\n    }\n\n    p = new_nbp(br, dev);\n    if (IS_ERR(p))\n        return PTR_ERR(p);\n\n    call_netdevice_notifiers(NETDEV_JOIN, dev);\n\n    err = dev_set_allmulti(dev, 1);\n    if (err) {\n        br_multicast_del_port(p);\n        netdev_put(dev, &p->dev_tracker);\n        kfree(p);   /* kobject not yet init\'d, manually free */\n        goto err1;\n    }\n\n    err = kobject_init_and_add(&p->kobj, &brport_ktype, &(dev->dev.kobj),\n                   SYSFS_BRIDGE_PORT_ATTR);\n    if (err)\n        goto err2;\n\n    err = br_sysfs_addif(p);\n    if (err)\n        goto err2;\n\n    err = br_netpoll_enable(p);\n    if (err)\n        goto err3;\n\n    err = netdev_rx_handler_register(dev, br_get_rx_handler(dev), p);\n    if (err)\n        goto err4;\n\n    dev->priv_flags |= IFF_BRIDGE_PORT;\n\n    err = netdev_master_upper_dev_link(dev, br->dev, NULL, NULL, extack);\n    if (err)\n        goto err5;\n\n    dev_disable_lro(dev);\n\n    list_add_rcu(&p->list, &br->port_list);\n\n    nbp_update_port_count(br);\n    if (!br_promisc_port(p) && (p->dev->priv_flags & IFF_UNICAST_FLT)) {\n        /* When updating the port count we also update all ports\'\n         * promiscuous mode.\n         * A port leaving promiscuous mode normally gets the bridge\'s\n         * fdb synced to the unicast filter (if supported), however,\n         * `br_port_clear_promisc` does not distinguish between\n         * non-promiscuous ports and *new* ports, so we need to\n         * sync explicitly here.\n         */\n        fdb_synced = br_fdb_sync_static(br, p) == 0;\n        if (!fdb_synced)\n            netdev_err(dev, "failed to sync bridge static fdb addresses to this port\\n");\n    }\n\n    netdev_update_features(br->dev);\n\n    br_hr = br->dev->needed_headroom;\n    dev_hr = netdev_get_fwd_headroom(dev);\n    if (br_hr < dev_hr)\n        update_headroom(br, dev_hr);\n    else\n        netdev_set_rx_headroom(dev, br_hr);\n\n    if (br_fdb_add_local(br, p, dev->dev_addr, 0))\n        netdev_err(dev, "failed insert local address bridge forwarding table\\n");\n\n    if (br->dev->addr_assign_type != NET_ADDR_SET) {\n        /* Ask for permission to use this MAC address now, even if we\n         * don\'t end up choosing it below.\n         */\n        err = dev_pre_changeaddr_notify(br->dev, dev->dev_addr, extack);\n        if (err)\n            goto err6;\n    }\n\n    err = nbp_vlan_init(p, extack);\n    if (err) {\n        netdev_err(dev, "failed to initialize vlan filtering on this port\\n");\n        goto err6;\n    }\n\n    spin_lock_bh(&br->lock);\n    changed_addr = br_stp_recalculate_bridge_id(br);\n\n    if (netif_running(dev) && netif_oper_up(dev) &&\n        (br->dev->flags & IFF_UP))\n        br_stp_enable_port(p);\n    spin_unlock_bh(&br->lock);\n\n    br_ifinfo_notify(RTM_NEWLINK, NULL, p);\n\n    if (changed_addr)\n        call_netdevice_notifiers(NETDEV_CHANGEADDR, br->dev);\n\n    br_mtu_auto_adjust(br);\n    br_set_gso_limits(br);\n\n    kobject_uevent(&p->kobj, KOBJ_ADD);\n\n    return 0;\n\nerr6:\n    if (fdb_synced)\n        br_fdb_unsync_static(br, p);\n    list_del_rcu(&p->list);\n    br_fdb_delete_by_port(br, p, 0, 1);\n    nbp_update_port_count(br);\n    netdev_upper_dev_unlink(dev, br->dev);\nerr5:\n    dev->priv_flags &= ~IFF_BRIDGE_PORT;\n    netdev_rx_handler_unregister(dev);\nerr4:\n    br_netpoll_disable(p);\nerr3:\n    sysfs_remove_link(br->ifobj, p->dev->name);\nerr2:\n    br_multicast_del_port(p);\n    netdev_put(dev, &p->dev_tracker);\n    kobject_put(&p->kobj);\n    dev_set_allmulti(dev, -1);\nerr1:\n    return err;\n}\n')),(0,i.kt)("p",null,"\u5176\u4e2d\u4e0a\u8ff0\u7684\u91cd\u9ede\u662f ",(0,i.kt)("inlineCode",{parentName:"p"},"br_mtu_auto_adjust"),"\uff0c\u8a72 function \u7684\u5167\u5bb9\u5982\u4e0b\uff0c\u57fa\u672c\u4e0a\u5c31\u53bb\u627e\u51fa\u6700\u5c0f\uff2d\uff34\uff35\u4e26\u4e14\u8a2d\u5b9a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"void br_mtu_auto_adjust(struct net_bridge *br)\n{\n    ASSERT_RTNL();\n\n    /* if the bridge MTU was manually configured don't mess with it */\n    if (br_opt_get(br, BROPT_MTU_SET_BY_USER))\n        return;\n\n    /* change to the minimum MTU and clear the flag which was set by\n     * the bridge ndo_change_mtu callback\n     */\n    dev_set_mtu(br->dev, br_mtu_min(br));\n    br_opt_toggle(br, BROPT_MTU_SET_BY_USER, false);\n}\n")))}c.isMDXComponent=!0}}]);