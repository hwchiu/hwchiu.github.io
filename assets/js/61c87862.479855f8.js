"use strict";(self.webpackChunkhwchiu=self.webpackChunkhwchiu||[]).push([[52823],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>m});var r=n(67294);function p(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){p(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function _(e,t){if(null==e)return{};var n,r,p=function(e,t){if(null==e)return{};var n,r,p={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(p[n]=e[n]);return p}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(p[n]=e[n])}return p}var l=r.createContext({}),i=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=i(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,p=e.mdxType,a=e.originalType,l=e.parentName,s=_(e,["components","mdxType","originalType","parentName"]),d=i(n),u=p,m=d["".concat(l,".").concat(u)]||d[u]||c[u]||a;return n?r.createElement(m,o(o({ref:t},s),{},{components:n})):r.createElement(m,o({ref:t},s))}));function m(e,t){var n=arguments,p=t&&t.mdxType;if("string"==typeof e||p){var a=n.length,o=new Array(a);o[0]=u;var _={};for(var l in t)hasOwnProperty.call(t,l)&&(_[l]=t[l]);_.originalType=e,_[d]="string"==typeof e?e:p,o[1]=_;for(var i=2;i<a;i++)o[i]=n[i];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},82287:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>_,toc:()=>i});var r=n(87462),p=(n(67294),n(3905));const a={title:"OpenvSwitch source code(2)",date:"2013-12-13 09:18",comments:!0,tags:["SDN","Network","OpenvSwitch","SourceCode"],description:"\u9019\u7bc7\u6587\u7ae0\u4e2d\uff0c\u6211\u5011\u6c7a\u5b9a\u900f\u904e\u95b1\u8b80\u539f\u59cb\u78bc\u7684\u65b9\u5f0f\uff0c\u4f86\u77ad\u89e3 OpenvSwitch \u64cd\u4f5c\u4e0a\u6700\u5e38\u4f7f\u7528\u7684\u6307\u4ee4\uff0c\u4e5f\u5c31\u662f add-port \u9019\u500b\u6307\u4ee4\u6bcf\u6b21\u904b\u884c\u6642\uff0c\u6574\u500b\u7cfb\u7d71\u5230\u5e95\u600e\u9ebc\u904b\u884c\u7684\u3002\u85c9\u7531\u95b1\u8b80\u539f\u59cb\u78bc\u7684\u65b9\u5f0f\u4f86\u91d0\u6e05\u6574\u500b OpenvSwitch \u7684\u67b6\u69cb\uff0c\u5f9e User-space \u7684\u7a0b\u5e8f\u5230 Kerenel Space \u7684 Module, \u9019\u4e2d\u9593\u5230\u5e95\u662f\u600e\u9ebc\u8655\u7406\u7684\u3002"},o="Preface",_={unversionedId:"techPost/2013/openvswitch-3",id:"techPost/2013/openvswitch-3",title:"OpenvSwitch source code(2)",description:"\u9019\u7bc7\u6587\u7ae0\u4e2d\uff0c\u6211\u5011\u6c7a\u5b9a\u900f\u904e\u95b1\u8b80\u539f\u59cb\u78bc\u7684\u65b9\u5f0f\uff0c\u4f86\u77ad\u89e3 OpenvSwitch \u64cd\u4f5c\u4e0a\u6700\u5e38\u4f7f\u7528\u7684\u6307\u4ee4\uff0c\u4e5f\u5c31\u662f add-port \u9019\u500b\u6307\u4ee4\u6bcf\u6b21\u904b\u884c\u6642\uff0c\u6574\u500b\u7cfb\u7d71\u5230\u5e95\u600e\u9ebc\u904b\u884c\u7684\u3002\u85c9\u7531\u95b1\u8b80\u539f\u59cb\u78bc\u7684\u65b9\u5f0f\u4f86\u91d0\u6e05\u6574\u500b OpenvSwitch \u7684\u67b6\u69cb\uff0c\u5f9e User-space \u7684\u7a0b\u5e8f\u5230 Kerenel Space \u7684 Module, \u9019\u4e2d\u9593\u5230\u5e95\u662f\u600e\u9ebc\u8655\u7406\u7684\u3002",source:"@site/docs/techPost/2013/openvswitch-3.md",sourceDirName:"techPost/2013",slug:"/techPost/2013/openvswitch-3",permalink:"/docs/techPost/2013/openvswitch-3",draft:!1,tags:[{label:"SDN",permalink:"/docs/tags/sdn"},{label:"Network",permalink:"/docs/tags/network"},{label:"OpenvSwitch",permalink:"/docs/tags/openv-switch"},{label:"SourceCode",permalink:"/docs/tags/source-code"}],version:"current",frontMatter:{title:"OpenvSwitch source code(2)",date:"2013-12-13 09:18",comments:!0,tags:["SDN","Network","OpenvSwitch","SourceCode"],description:"\u9019\u7bc7\u6587\u7ae0\u4e2d\uff0c\u6211\u5011\u6c7a\u5b9a\u900f\u904e\u95b1\u8b80\u539f\u59cb\u78bc\u7684\u65b9\u5f0f\uff0c\u4f86\u77ad\u89e3 OpenvSwitch \u64cd\u4f5c\u4e0a\u6700\u5e38\u4f7f\u7528\u7684\u6307\u4ee4\uff0c\u4e5f\u5c31\u662f add-port \u9019\u500b\u6307\u4ee4\u6bcf\u6b21\u904b\u884c\u6642\uff0c\u6574\u500b\u7cfb\u7d71\u5230\u5e95\u600e\u9ebc\u904b\u884c\u7684\u3002\u85c9\u7531\u95b1\u8b80\u539f\u59cb\u78bc\u7684\u65b9\u5f0f\u4f86\u91d0\u6e05\u6574\u500b OpenvSwitch \u7684\u67b6\u69cb\uff0c\u5f9e User-space \u7684\u7a0b\u5e8f\u5230 Kerenel Space \u7684 Module, \u9019\u4e2d\u9593\u5230\u5e95\u662f\u600e\u9ebc\u8655\u7406\u7684\u3002"},sidebar:"techPost",previous:{title:"Openvswitch source code(1)",permalink:"/docs/techPost/2013/openvswitch-2"},next:{title:"OpenvSwitch - hmap",permalink:"/docs/techPost/2013/openvswitch-hmap"}},l={},i=[{value:"User space",id:"user-space",level:2},{value:"Gereric netlink",id:"gereric-netlink",level:2},{value:"Kernel space",id:"kernel-space",level:2}],s={toc:i},d="wrapper";function c(e){let{components:t,...n}=e;return(0,p.kt)(d,(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"preface"},"Preface"),(0,p.kt)("p",null,"\u7576\u4f7f\u7528 ",(0,p.kt)("strong",{parentName:"p"},"ovs-vsctl add-port br0 eth1"),"\u7684\u6642\u5019\uff0c\u5be6\u969b\u4e0a\u6703\u505a\u4ec0\u9ebc\u4e8b\u60c5\uff0c\u9019\u908a\u5206\u6210\u5169\u500b\u5c64\u9762\u4f86\u770b"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"User space"),(0,p.kt)("li",{parentName:"ul"},"Kernel space")),(0,p.kt)("p",null,"\u800c\u9019\u4e4b\u4e2d\u5247\u6703\u900f\u904e ",(0,p.kt)("strong",{parentName:"p"},"generic netlink"),"\u4f86\u6e9d\u901a"),(0,p.kt)("h2",{id:"user-space"},"User space"),(0,p.kt)("p",null,"\u9019\u90e8\u5206\u9084\u6709\u9ede\u5361\u4f4f\uff0c\u5c0d ",(0,p.kt)("strong",{parentName:"p"},"ovsdb")," \u6709\u66f4\u77ad\u89e3\u5f8c\u518d\u88dc\u5145\nbridge_reconfigure\nbridge_refresh_ofp_port\nbridge_refresh_one_ofp_port\niface_create\niface_do_create\nofproto_port_add"),(0,p.kt)("p",null,"VLOG_INFO"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"static int\nport_add(struct ofproto *ofproto_, struct netdev *netdev)\n{\n...\n    error = dpif_port_add(ofproto->backer->dpif, netdev, &port_no);\n\n...\n}\n")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},'int\ndpif_port_add(struct dpif *dpif, struct netdev *netdev, odp_port_t *port_nop)\n{\n    const char *netdev_name = netdev_get_name(netdev);\n    odp_port_t port_no = ODPP_NONE;\n    int error;\n\n    COVERAGE_INC(dpif_port_add);\n\n    if (port_nop) {\n        port_no = *port_nop;\n    }\n\n    error = dpif->dpif_class->port_add(dpif, netdev, &port_no);\n    if (!error) {\n        VLOG_DBG_RL(&dpmsg_rl, "%s: added %s as port %"PRIu32,\n                    dpif_name(dpif), netdev_name, port_no);\n    } else {\n        VLOG_WARN_RL(&error_rl, "%s: failed to add %s as port: %s",\n                     dpif_name(dpif), netdev_name, ovs_strerror(error));\n        port_no = ODPP_NONE;\n    }\n    if (port_nop) {\n        *port_nop = port_no;\n    }\n    return error;\n}\n\n')),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"static void\ndp_initialize(void)\n{\n    static struct ovsthread_once once = OVSTHREAD_ONCE_INITIALIZER;\n\n    if (ovsthread_once_start(&once)) {\n        int i;\n\n        for (i = 0; i < ARRAY_SIZE(base_dpif_classes); i++) {\n            dp_register_provider(base_dpif_classes[i]);\n        }\n        ovsthread_once_done(&once);\n    }\n}\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"\u9019\u908a\u6703\u53bb\u8a3b\u518a\u6bcf\u500b ",(0,p.kt)("strong",{parentName:"li"},"base_dipf_classes"),".")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"struct dpif_class {\n....\n    /* Adds 'netdev' as a new port in 'dpif'.  If '*port_no' is not\n     * UINT32_MAX, attempts to use that as the port's port number.\n     *\n     * If port is successfully added, sets '*port_no' to the new port's\n     * port number.  Returns EBUSY if caller attempted to choose a port\n     * number, and it was in use. */\n    int (*port_add)(struct dpif *dpif, struct netdev *netdev,\n                    odp_port_t *port_no);\n...\n\n}\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"dpif_class\u662f\u4e00\u500bbase class,\u88e1\u9762\u5b58\u653e\u7684\u90fd\u662ffunction pointer.")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"static const struct dpif_class *base_dpif_classes[] = {\n#ifdef LINUX_DATAPATH\n    &dpif_linux_class,\n#endif\n    &dpif_netdev_class,\n};\n\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"\u9019\u908a\u6703\u6839\u64datype\u53bb\u5be6\u4f8b\u5316\u4e0d\u540c\u985e\u578b\u7684 ",(0,p.kt)("strong",{parentName:"li"},"dpif_class"),",\u9019\u908a\u6211\u5011\u95dc\u5fc3\u7684\u662f ",(0,p.kt)("strong",{parentName:"li"},"dpif_linux_class"),".")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},'const struct dpif_class dpif_linux_class = {\n    "system",\n    dpif_linux_enumerate,\n    NULL,\n    dpif_linux_open,\n    dpif_linux_close,\n    dpif_linux_destroy,\n    NULL,                       /* run */\n    NULL,                       /* wait */\n    dpif_linux_get_stats,\n    dpif_linux_port_add,\n    dpif_linux_port_del,\n    dpif_linux_port_query_by_number,\n    dpif_linux_port_query_by_name,\n    dpif_linux_get_max_ports,\n    dpif_linux_port_get_pid,\n    dpif_linux_port_dump_start,\n    dpif_linux_port_dump_next,\n    dpif_linux_port_dump_done,\n    dpif_linux_port_poll,\n    dpif_linux_port_poll_wait,\n    dpif_linux_flow_get,\n    dpif_linux_flow_put,\n    dpif_linux_flow_del,\n    dpif_linux_flow_flush,\n    dpif_linux_flow_dump_start,\n    dpif_linux_flow_dump_next,\n    dpif_linux_flow_dump_done,\n    dpif_linux_execute,\n    dpif_linux_operate,\n    dpif_linux_recv_set,\n    dpif_linux_queue_to_priority,\n    dpif_linux_recv,\n    dpif_linux_recv_wait,\n    dpif_linux_recv_purge,\n};\n')),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"\u9019\u908a\u5b9a\u7fa9\u4e86 dpif_class\u7684\u4e00\u4e9b\u64cd\u4f5cfunction."),(0,p.kt)("li",{parentName:"ul"},"\u6211\u5011\u95dc\u5fc3\u7684 ",(0,p.kt)("strong",{parentName:"li"},"port_add")," \u5be6\u969b\u4e0a\u5c0d\u61c9\u7684\u662f ",(0,p.kt)("strong",{parentName:"li"},"dpif_linux_port_add"))),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"static int\ndpif_linux_port_add(struct dpif *dpif_, struct netdev *netdev,\n                    odp_port_t *port_nop)\n{\n    struct dpif_linux *dpif = dpif_linux_cast(dpif_);\n    int error;\n\n    ovs_mutex_lock(&dpif->upcall_lock);\n    error = dpif_linux_port_add__(dpif_, netdev, port_nop);\n    ovs_mutex_unlock(&dpif->upcall_lock);\n\n    return error;\n}\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"\u9019\u908a\u6703\u547c\u53eb ",(0,p.kt)("strong",{parentName:"li"},"dpif_linux_port_add__"),"\u53bb\u5275\u7acbvport.")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"static int\ndpif_linux_port_add__(struct dpif *dpif_, struct netdev *netdev,\n                      odp_port_t *port_nop)\n{\n....\n    request.cmd = OVS_VPORT_CMD_NEW;\n    request.dp_ifindex = dpif->dp_ifindex;\n    request.type = netdev_to_ovs_vport_type(netdev);\n...\n     error = dpif_linux_vport_transact(&request, &reply, &buf);\n...\n}\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"\u9019\u908a\u6703\u8a2d\u5b9arequest\u7684cmd\u70ba ",(0,p.kt)("strong",{parentName:"li"},"OVS_VPORT_CMD_NEW")),(0,p.kt)("li",{parentName:"ul"},"\u4f7f\u7528 ",(0,p.kt)("strong",{parentName:"li"},"dpif_linux_vport_transact")," \u628a\u9019\u500brequest\u900f\u904enetlink\u7684\u65b9\u5f0f\u9001\u5230kernel\u7aef\uff0ckernel\u7aef\u6703\u518d\u6839\u64da\u9019\u500brequest\u7684cmd\u4f86\u57f7\u884c\u7279\u5b9a\u7684function.")),(0,p.kt)("h2",{id:"gereric-netlink"},"Gereric netlink"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"static int dp_register_genl(void)\n{\n        int n_registered;\n        int err;\n        int i;\n\n        n_registered = 0;\n        for (i = 0; i < ARRAY_SIZE(dp_genl_families); i++) {\n                const struct genl_family_and_ops *f = &dp_genl_families[i];\n\n                err = genl_register_family_with_ops(f->family, f->ops,\n                                                    f->n_ops);\n                if (err)\n                        goto error;\n                n_registered++;\n\n                if (f->group) {\n                        err = genl_register_mc_group(f->family, f->group);\n                        if (err)\n                                goto error;\n                }\n        }\n\n        return 0;\n\nerror:\n        dp_unregister_genl(n_registered);\n        return err;\n}\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"\u7576 ",(0,p.kt)("strong",{parentName:"li"},"datapath")," kernel module\u88ab\u8f09\u5165\u7684\u6642\u5019\uff0c\u6703\u57f7\u884c\u5c0d\u61c9\u7684 ",(0,p.kt)("strong",{parentName:"li"},"init"),",\u88e1\u9762\u6703\u57f7\u884c ",(0,p.kt)("strong",{parentName:"li"},"dp_register_genl"),"."),(0,p.kt)("li",{parentName:"ul"},"\u9019\u908a\u6703\u547c\u53eb\u6240\u6709\u7684 ",(0,p.kt)("strong",{parentName:"li"},"dp_genl_families")," \u4f86\u8a3b\u518a ",(0,p.kt)("strong",{parentName:"li"},"generic netlink"),"\u76f8\u95dc\u7684function.")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"static const struct genl_family_and_ops dp_genl_families[] = {\n        { &dp_datapath_genl_family,\n          dp_datapath_genl_ops, ARRAY_SIZE(dp_datapath_genl_ops),\n          &ovs_dp_datapath_multicast_group },\n        { &dp_vport_genl_family,\n          dp_vport_genl_ops, ARRAY_SIZE(dp_vport_genl_ops),\n          &ovs_dp_vport_multicast_group },\n        { &dp_flow_genl_family,\n          dp_flow_genl_ops, ARRAY_SIZE(dp_flow_genl_ops),\n          &ovs_dp_flow_multicast_group },\n        { &dp_packet_genl_family,\n          dp_packet_genl_ops, ARRAY_SIZE(dp_packet_genl_ops),\n          NULL },\n};\n\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"\u9019\u908a\u5b9a\u7fa9\u4e86\u6240\u6709 ",(0,p.kt)("strong",{parentName:"li"},"gerneric netlink"),"\u76f8\u95dctype\u7684\u7d50\u69cb\u6210\u54e1 (dp,vport,flow,packet)")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"static struct genl_ops dp_vport_genl_ops[] = {\n        { .cmd = OVS_VPORT_CMD_NEW,\n          .flags = GENL_ADMIN_PERM, /* Requires CAP_NET_ADMIN privilege. */\n          .policy = vport_policy,\n          .doit = ovs_vport_cmd_new\n        },\n        { .cmd = OVS_VPORT_CMD_DEL,\n          .flags = GENL_ADMIN_PERM, /* Requires CAP_NET_ADMIN privilege. */\n          .policy = vport_policy,\n          .doit = ovs_vport_cmd_del\n        },\n        { .cmd = OVS_VPORT_CMD_GET,\n          .flags = 0,               /* OK for unprivileged users. */\n          .policy = vport_policy,\n          .doit = ovs_vport_cmd_get,\n          .dumpit = ovs_vport_cmd_dump\n        },\n        { .cmd = OVS_VPORT_CMD_SET,\n          .flags = GENL_ADMIN_PERM, /* Requires CAP_NET_ADMIN privilege. */\n          .policy = vport_policy,\n          .doit = ovs_vport_cmd_set,\n        },\n};\n\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"\u9019\u908a\u5b9a\u7fa9\u4e86 ",(0,p.kt)("strong",{parentName:"li"},"gerneric netlink")," \u76f8\u95dc\u7684vport operation."),(0,p.kt)("li",{parentName:"ul"},"\u7576 cmd \u662f ",(0,p.kt)("strong",{parentName:"li"},"OVS_VPORT_CMD_NEW"),"\u7684\u6642\u5019\uff0c\u5c31\u6703\u57f7\u884c\u5c0d\u61c9\u7684 function handler ",(0,p.kt)("strong",{parentName:"li"},"ovs_vport_cmd_new"))),(0,p.kt)("h2",{id:"kernel-space"},"Kernel space"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"static int ovs_vport_cmd_new(struct sk_buff *skb, struct genl_info *info)\n{\n...\n        parms.name = nla_data(a[OVS_VPORT_ATTR_NAME]);\n        parms.type = nla_get_u32(a[OVS_VPORT_ATTR_TYPE]);\n        parms.options = a[OVS_VPORT_ATTR_OPTIONS];\n        parms.dp = dp;\n        parms.port_no = port_no;\n        parms.upcall_portid = nla_get_u32(a[OVS_VPORT_ATTR_UPCALL_PID]);\n\n        vport = new_vport(&parms);\n...\n}\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"struct vport_parms parms \u7528\u4f86\u8a18\u9304\u4e00\u4e9bvport\u7684\u8cc7\u8a0a"),(0,p.kt)("li",{parentName:"ul"},"\u586b\u5beb\u76f8\u95dc\u8a0a\u606f\u5f8c\uff0c\u5c31\u547c\u53eb ",(0,p.kt)("strong",{parentName:"li"},"new_vport"),"\u4f86\u5275\u7acb vport")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"static struct vport *new_vport(const struct vport_parms *parms)\n{\n        struct vport *vport;\n\n        vport = ovs_vport_add(parms);\n        if (!IS_ERR(vport)) {\n                struct datapath *dp = parms->dp;\n                struct hlist_head *head = vport_hash_bucket(dp, vport->port_no);\n\n                hlist_add_head_rcu(&vport->dp_hash_node, head);\n        }\n        return vport;\n}\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"\u9019\u908a\u6703\u547c\u53eb ",(0,p.kt)("strong",{parentName:"li"},"*ovs_vport_add")," \u4f86\u5275\u7acb\u8a72vport")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"struct vport *ovs_vport_add(const struct vport_parms *parms)\n{\n        struct vport *vport;\n        int err = 0;\n        int i;\n\n        for (i = 0; i < ARRAY_SIZE(vport_ops_list); i++) {\n                if (vport_ops_list[i]->type == parms->type) {\n                        struct hlist_head *bucket;\n\n                        vport = vport_ops_list[i]->create(parms);\n                        if (IS_ERR(vport)) {\n                                err = PTR_ERR(vport);\n                                goto out;\n                        }\n\n                        bucket = hash_bucket(ovs_dp_get_net(vport->dp),\n                                             vport->ops->get_name(vport));\n                        hlist_add_head_rcu(&vport->hash_node, bucket);\n                        return vport;\n                }\n        }\n\n        err = -EAFNOSUPPORT;\n\nout:\n        return ERR_PTR(err);\n}\n\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"\u6383\u904e\u6240\u6709 ",(0,p.kt)("strong",{parentName:"li"},"vport_ops_list"),", \u5982\u679c\u90a3\u500bops\u7684 ",(0,p.kt)("strong",{parentName:"li"},"type"),"\u8ddf\u50b3\u9032\u4f86\u7684type\u662f\u4e00\u6a23\u7684\uff0c\u90a3\u5c31\u547c\u53eb\u5c0d\u61c9\u7684 ",(0,p.kt)("strong",{parentName:"li"},"create")," function.")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"static const struct vport_ops *vport_ops_list[] = {\n        &ovs_netdev_vport_ops,\n        &ovs_internal_vport_ops,\n#if IS_ENABLED(CONFIG_NET_IPGRE_DEMUX)\n        &ovs_gre_vport_ops,\n        &ovs_gre64_vport_ops,\n#endif\n        &ovs_vxlan_vport_ops,\n        &ovs_lisp_vport_ops,\n};\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"vport_ops \u6709\u591a\u7a2etype.\u9019\u908a\u6211\u5011\u5c08\u6ce8\u65bc ",(0,p.kt)("strong",{parentName:"li"},"ovs_netdev_vport_ops"),"\u9019\u7a2etype.")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"const struct vport_ops ovs_netdev_vport_ops = {\n        .type           = OVS_VPORT_TYPE_NETDEV,\n        .create         = netdev_create,\n        .destroy        = netdev_destroy,\n        .get_name       = ovs_netdev_get_name,\n        .send           = netdev_send,\n};\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"vport\u7576type\u662f ",(0,p.kt)("strong",{parentName:"li"},"netdev"),"\u7684\u6642\u5019\uff0c\u6210\u54e1\u7684function pointer\u5c31\u6703\u6309\u6b64\u8a2d\u5b9a\u70ba\u5404\u500bfunction."),(0,p.kt)("li",{parentName:"ul"},"\u53ef\u4ee5\u770b\u5230\u4ed6\u7684 ",(0,p.kt)("strong",{parentName:"li"},"create")," \u5c0d\u61c9\u5230 ",(0,p.kt)("strong",{parentName:"li"},"netdev_create"))),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"static struct vport *netdev_create(const struct vport_parms *parms)\n...\n        err = netdev_rx_handler_register(netdev_vport->dev, netdev_frame_hook,\n                                         vport);\n...\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"\u9019\u908a\u8a3b\u518anetdevice\u7684receive handler, handler\u70ba ",(0,p.kt)("strong",{parentName:"li"},"netdev_frame_hook"))),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-c"},"int netdev_rx_handler_register(struct net_device *dev,\n                                rx_handler_func_t *rx_handler,\n                                void *rx_handler_data)\n{\n         ASSERT_RTNL();\n\n         if (dev->rx_handler)\n                 return -EBUSY;\n\n         /* Note: rx_handler_data must be set before rx_handler */\n         rcu_assign_pointer(dev->rx_handler_data, rx_handler_data);\n         rcu_assign_pointer(dev->rx_handler, rx_handler);\n\n        return 0;\n}\n")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"\u9019\u908a\u6703\u628a\u8a2d\u5b9a\u8a72 ",(0,p.kt)("strong",{parentName:"li"},"net_device"),"\u4e2d\u7684\u5169\u500bpointer"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("strong",{parentName:"li"},"rx_handler_data")," \u9019\u908a\u5c31\u8a2d\u5b9a\u6210\u8a72vport."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("strong",{parentName:"li"},"rx_handler")," \u63a5\u6536\u5230\u5c01\u5305\u7684\u8655\u7406\u51fd\u5f0f\uff0c\u9019\u908a\u5c31\u662fnetdev_frame_hook\u3002")))}c.isMDXComponent=!0}}]);